#####d3/bar_brush.js:#####
// Setup SVG and margins
var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// Setup scales and axes
var x = d3.scaleBand().rangeRound([0, width]).padding(0.1),
    y = d3.scaleLinear().range([height, 0]);

var xAxis = d3.axisBottom(x),
    yAxis = d3.axisLeft(y).ticks(10);

// Setup the brush
var brush = d3.brushX()
    .extent([[0, 0], [width, height]])
    .on("end", brushed);

// Load data and create the bar chart
d3.csv("data.csv", type, function(error, data) {
  if (error) throw error;

  x.domain(data.map(function(d) { return d.name; }));
  y.domain([0, d3.max(data, function(d) { return d.value; })]);

  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);

  svg.append("g")
      .attr("class", "y axis")
      .call(yAxis)
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text("Value");

  svg.selectAll(".bar")
      .data(data)
    .enter().append("rect")
      .attr("class", "bar")
      .attr("x", function(d) { return x(d.name); })
      .attr("width", x.bandwidth())
      .attr("y", function(d) { return y(d.value); })
      .attr("height", function(d) { return height - y(d.value); });

  // Apply the brush to the svg
  svg.append("g")
      .attr("class", "brush")
      .call(brush);
});

function brushed() {
  var selection = d3.event.selection;
  // Handle the brush event and filter data based on the selection
}

function type(d) {
  d.value = +d.value; // coerce to number
  return d;
}


#####d3/bar_click.js:#####
// Setup SVG and margins
var margin = { top: 20, right: 20, bottom: 30, left: 40 },
  width = 960 - margin.left - margin.right,
  height = 500 - margin.top - margin.bottom;

var svg = d3.select("body").append("svg")
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.top + margin.bottom)
  .append("g")
  .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// Setup scales and axes
var x = d3.scaleBand().rangeRound([0, width]).padding(0.1),
  y = d3.scaleLinear().range([height, 0]);

var xAxis = d3.axisBottom(x),
  yAxis = d3.axisLeft(y).ticks(10);

// Define a click handler function
function barClicked(d) {
  d3.select(d).attr('fill', 'red');
}

// Load data and create the bar chart
d3.csv("data.csv", type, function (error, data) {
  if (error) throw error;

  x.domain(data.map(function (d) { return d.name; }));
  y.domain([0, d3.max(data, function (d) { return d.value; })]);

  svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);

  svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Value");

  svg.selectAll(".bar")
    .data(data)
    .enter().append("rect")
    .attr("class", "bar")
    .attr("x", function (d) { return x(d.name); })
    .attr("width", x.bandwidth())
    .attr("y", function (d) { return y(d.value); })
    .attr("height", function (d) { return height - y(d.value); })
    .on("click", barClicked); // Attach the click handler to each bar
});

function type(d) {
  d.value = +d.value; // coerce to number
  return d;
}


#####d3/bar_hover.js:#####
// Setup SVG and margins
var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// Setup scales and axes
var x = d3.scaleBand().rangeRound([0, width]).padding(0.1),
    y = d3.scaleLinear().range([height, 0]);

var xAxis = d3.axisBottom(x),
    yAxis = d3.axisLeft(y).ticks(10);

// Define hover functions
function handleMouseOver(d, i) {
  // Highlight the bar
  d3.select(this)
    .attr('opacity', 0.7);
  
  // Optionally, display additional information about the bar
  // For example, display a tooltip or update an info panel
  // This is a placeholder to customize
  console.log("Hovered on bar with data: ", d);
}

function handleMouseOut(d, i) {
  // Remove highlight from the bar
  d3.select(this)
    .attr('opacity', 1);

  // Optionally, hide the additional information displayed during hover
}

// Load data and create the bar chart
d3.csv("data.csv", type, function(error, data) {
  if (error) throw error;

  x.domain(data.map(function(d) { return d.name; }));
  y.domain([0, d3.max(data, function(d) { return d.value; })]);

  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);

  svg.append("g")
      .attr("class", "y axis")
      .call(yAxis)
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text("Value");

  svg.selectAll(".bar")
      .data(data)
    .enter().append("rect")
      .attr("class", "bar")
      .attr("x", function(d) { return x(d.name); })
      .attr("width", x.bandwidth())
      .attr("y", function(d) { return y(d.value); })
      .attr("height", function(d) { return height - y(d.value); })
      .on("mouseover", handleMouseOver)
      .on("mouseout", handleMouseOut);
});

function type(d) {
  d.value = +d.value; // coerce to number
  return d;
}


#####d3/bar_panzoom.js:#####
// Set up SVG and margins
var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

// Create SVG element
var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// Set up scales
var xScale = d3.scaleBand().range([0, width]).padding(0.1),
    yScale = d3.scaleLinear().range([height, 0]);

// Define the axes
var xAxis = d3.axisBottom(xScale),
    yAxis = d3.axisLeft(yScale).ticks(10);

// Set up the zoom behavior
var zoom = d3.zoom()
    .scaleExtent([1, 10])
    .translateExtent([[0, 0], [width, height]])
    .on("zoom", zoomed);

// Apply the zoom behavior to the SVG
svg.call(zoom);

// Load data and create the bar chart
d3.csv("data.csv").then(function(data) {
    // Process data and update scales
    xScale.domain(data.map(function(d) { return d.name; }));
    yScale.domain([0, d3.max(data, function(d) { return +d.value; })]);

    // Draw the bars
    svg.selectAll(".bar")
        .data(data)
        .enter().append("rect")
        .attr("class", "bar")
        .attr("x", function(d) { return xScale(d.name); })
        .attr("width", xScale.bandwidth())
        .attr("y", function(d) { return yScale(+d.value); })
        .attr("height", function(d) { return height - yScale(+d.value); });

    // Draw the axes
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis);
});

// The zoom function
function zoomed() {
    // Create new scale ojects based on event
    var new_xScale = d3.event.transform.rescaleX(xScale);
    var new_yScale = d3.event.transform.rescaleY(yScale);

    // Update axes
    svg.select(".x.axis").call(xAxis.scale(new_xScale));
    svg.select(".y.axis").call(yAxis.scale(new_yScale));

    // Update bars
    svg.selectAll(".bar")
        .attr("x", function(d) { return new_xScale(d.name); })
        .attr("width", new_xScale.bandwidth())
        .attr("y", function(d) { return new_yScale(+d.value); })
        .attr("height", function(d) { return height - new_yScale(+d.value); });
}


#####d3/dimpvis.js:#####
/** This file creates and coordinates a scatterplot and a slider according to the provided dataset
 * */

//Add a main svg which all visualization elements will be appended to
d3.select("#scatter").append("svg").attr("id", "mainSvg").on("click", function () {
  scatterplot.clearHintPath();
  scatterplot.clearPointLabels();
});
var screenWidth = window.innerWidth - 50;
var screenHeight = window.innerHeight - 50;
window.onload = function () {
  d3.select("#mainSvg").attr("width", screenWidth).attr("height", screenHeight);
  d3.select("#hintPathFormDiv").style("margin-left", (screenWidth * 0.6 + 90) + "px");
}

d3.select("#hintPathForm").selectAll("input").on("change", function change() {
  scatterplot.hintPathType = this.value;
});

//Create a new scatterplot visualization
var scatterplot = new Scatterplot(screenWidth * 0.6, screenHeight * 0.6, 50);

scatterplot.init();
//setHintPathType(scatterplot,1);

//Define the click interaction of the hint labels to invoke fast switching among views
scatterplot.clickHintLabelFunction = function (d) {
  d3.event.stopPropagation(); //Prevents the event from propagating down to the SVG
  scatterplot.animatePoints(scatterplot.draggedPoint, scatterplot.currentView, d.id);
  changeView(scatterplot, d.id);
  slider.updateSlider(d.id);
};

scatterplot.render(dataset, labels, xLabel, yLabel, title); //Draw the scatterplot, dataset is an array created in a separate js file containing the json data,
// and labels is an array representing the different views of the dataset

//Define the dragging interaction of the scatterplot points, which will continuously update the scatterplot
var dragPoint = d3.behavior.drag()
  .origin(function (d) { //Set the starting point of the drag interaction
    return { x: d.nodes[scatterplot.currentView][0], y: d.nodes[scatterplot.currentView][1] };
  }).on("dragstart", function (d) {
    scatterplot.clearHintPath();
    scatterplot.draggedPoint = d.id;
    scatterplot.previousDragAngle = 0; //To be safe, re-set this
    scatterplot.selectPoint(d);
  }).on("drag", function (d) {
    if (scatterplot.hintPathType != 1) {
      slider.animateTick(scatterplot.interpValue, scatterplot.currentView, scatterplot.nextView);
    }
    scatterplot.updateDraggedPoint(d.id, d3.event.x, d3.event.y, d.nodes);
  }).on("dragend", function (d) { //In this event, mouse coordinates are undefined, need to use the saved
    //coordinates of the scatterplot object
    scatterplot.snapToView(d.id, d.nodes);
    slider.updateSlider(scatterplot.currentView);
  });

//Apply the dragging function to all points of the scatterplot, making them all draggable
scatterplot.svg.selectAll(".displayPoints").call(dragPoint);

//Create a new slider widget as an alternative for switching views of the scatterplot visualization
var sliderSpacing = scatterplot.width / labels.length;
var slider = new Slider(35, screenHeight * 0.8, labels, "", "#666", sliderSpacing);
slider.init();
slider.render();

//Define the dragging interaction of the slider which will update the view of the scatterplot
slider.dragEvent = d3.behavior.drag()
  .on("dragstart", function () {
    scatterplot.clearHintPath();
  })
  .on("drag", function () {
    slider.updateDraggedSlider(d3.event.x);
    scatterplot.interpolatePoints(-1, slider.interpValue, slider.currentTick, slider.nextTick);
  })
  .on("dragend", function () {
    slider.snapToTick();
    changeView(scatterplot, slider.currentTick);
    scatterplot.redrawView(slider.currentTick);
  });

//Apply the dragging event to the slider's movable tick
slider.widget.select("#slidingTick").call(slider.dragEvent);

/** Constructor for a slider widget
 * x: the left margin
 * y: the right margin
 * id: id of the div tag to append the svg container
 * labels: an array of labels corresponding to a tick along the slider
 * description: a title for the slider
 * colour: the colour of the slider
 * spacing: spacing between ticks (in pixels)
 */
//TODO: Get rid of magic numbers and find a way to automatically compute them (e.g., positioning of slider and title relative to width)
function Slider(x, y, labels, description, colour, spacing) {
  // Save the position, size and display properties
  this.xpos = x;
  this.ypos = y;
  this.mouseX = -1;
  this.numTicks = labels.length;
  this.title = description;
  this.tickLabels = labels;
  this.displayColour = colour;
  this.tickSpacing = spacing;
  this.sliderOffset = x + (description.length * 20); //Font size of title is 20px
  this.width = this.sliderOffset + this.numTicks * this.tickSpacing;
  this.height = 50;
  this.tickYPos = 35; //Amount to translate the draggable tick by in the y coordinate
  this.anchorYPos = 12; //Amount to translate the anchor which follows the draggable tick when it is not placed on the main slider
  this.sliderHeight = 10; //Thickness of the main slider line

  this.currentTick = 0; //Start the slider always at the first tick
  this.nextTick = 1;  //The next tick is after the current one
  this.interpValue = 0; //Amount of distance travelled between ticks, used to interpolate other visualizations
  this.widget = null;  // Reference to the main widget
  this.sliderPos = this.sliderOffset; //The starting horizontal position of the slider tick (at the first tick)
  this.timeDirection = 1 //Direction travelling along time line (1 if forward, -1 if backwards)

  //Generate an array of x locations for each tick
  this.tickPositions = []; //All x locations of the ticks on the slider
  for (var i = 0; i < this.numTicks; i++) {
    if (i == 0) {
      this.tickPositions[i] = this.sliderOffset;
    } else {
      this.tickPositions[i] = this.tickPositions[i - 1] + this.tickSpacing;
    }
  }
}
/** Append a blank svg and g container to the div tag indicated by "id", this is where the widget
*  will be drawn.
* */
Slider.prototype.init = function () {
  this.widget = d3.select("#mainSvg").append("g").attr("id", "gSlider")
    .attr("width", this.width).attr("height", this.height)
    .attr("transform", "translate(" + this.xpos + "," + this.ypos + ")");
}
/** Render the widget onto the svg
*  Note: no data set is required because it was automatically generated in the constructor
* */
Slider.prototype.render = function () {
  var ref = this;

  //Add the title beside the slider
  this.widget.append("text").text(this.title).attr("class", "slider")
    .attr("x", 0).attr("y", 20).attr("fill", this.displayColour)
    .style("font-family", "sans-serif").style("font-size", "20px");

  //Prepare the data for drawing the slider ticks
  this.widget.selectAll("rect")
    .data(this.tickPositions.map(function (d, i) { return { id: i, value: d, label: ref.tickLabels[i] }; }))
    .enter().append("g").attr("class", "slider");

  //Draw the ticks
  this.widget.selectAll("g").append("svg:rect")
    .attr("x", function (d) { return d.value; })
    //.attr("y", function (d,i){return ((i==0)||(i==ref.numTicks-1))?(10-ref.sliderHeight/2):10})
    .attr("y", function (d, i) { return (10 - ref.sliderHeight / 2) })
    .attr("width", 2)//.attr("height", function (d,i){return ((i==0)||(i==ref.numTicks-1))?(12+ref.sliderHeight):12})
    .attr("height", function (d, i) { return (12 + ref.sliderHeight) })
    .style("fill", ref.displayColour)
    .attr("class", "ticks");

  //Draw the labels for each tick
  this.widget.selectAll("g").append("svg:text")
    .text(function (d) { return d.label; })
    .attr("x", function (d) { return d.value }).attr("y", 0)
    .style("font-family", "sans-serif").style("font-size", "14px")
    .style("fill", function (d, i) {
      if (ref.tickLabels.length > 25) { //Only display every 5 labels to reduce clutter
        if (i % 5 == 0) return ref.displayColour;
        else return "none";
      }
      return ref.displayColour;
    })
    .attr("text-anchor", "middle").attr("class", "tickLabels");

  //Draw a long line through all ticks
  this.widget.append("rect").attr("class", "slider")
    .attr("x", ref.sliderOffset).attr("y", 10)
    .attr("width", ref.tickPositions[ref.numTicks - 1] - ref.sliderOffset)
    .attr("height", ref.sliderHeight)
    .attr("fill", ref.displayColour);

  //Draw the draggable slider tick
  /**this.widget.append("rect")
      .attr("transform", function(d) { return "translate(" +ref.sliderPos + "," + ref.tickYPos + ")"; })
    .attr("rx",4).attr("ry",4) //For curved edges on the rectangle
    .attr("width", 10).attr("height", 20)
    .attr("stroke", "white").attr("fill", ref.displayColour)
    .style("cursor", "pointer").attr("id","slidingTick");*/

  //Draw a triangle draggable tick
  this.widget.append("path").attr("d", d3.svg.symbol().type("triangle-up").size(180))
    .attr("transform", "translate(" + ref.sliderPos + "," + ref.tickYPos + ")")
    .attr("fill", ref.displayColour).style("stroke", "white")
    .style("cursor", "pointer").attr("id", "slidingTick").attr("class", "slider");
  //Draw an anchor to attach the triangle with the main slider bar
  this.widget.append("rect").attr("transform", "translate(" + (ref.sliderPos + 1) + "," + ref.anchorYPos + ")")
    .attr("stroke", "none").style("fill", "#bdbdbd").attr("width", 1).attr("height", (ref.sliderHeight - 4))
    .style("cursor", "pointer").attr("id", "anchor").attr("class", "slider");
}
/** Re-draws the dragged tick by translating it according to the x-coordinate of the mouse
*  mouseX: The x-coordinate of the mouse, received from the drag event
* */
Slider.prototype.updateDraggedSlider = function (mouseX) {
  var ref = this;
  this.mouseX = mouseX; //Save the mouse position
  var translateX;

  var current = ref.tickPositions[ref.currentTick];
  var next = ref.tickPositions[ref.nextTick];
  if (ref.currentTick == 0) { //First tick
    if (mouseX <= current) {//Out of bounds: Passed first tick
      translateX = current;
    } else if (mouseX >= next) {
      ref.currentTick = ref.nextTick;
      ref.nextTick++;
      ref.interpValue = (ref.timeDirection == -1) ? 1 : 0;
      translateX = mouseX;
    } else {
      ref.setInterpolation(mouseX, current, next);
      translateX = mouseX;
    }
  } else if (ref.nextTick == (ref.numTicks - 1)) { //Last tick
    if (mouseX >= next) {  //Out of bounds: Passed last tick
      translateX = next;
    } else if (mouseX <= current) {
      ref.nextTick = ref.currentTick;
      ref.currentTick--;
      ref.interpValue = (ref.timeDirection == -1) ? 1 : 0;
      translateX = mouseX;
    } else {
      ref.setInterpolation(mouseX, current, next);
      translateX = mouseX;
    }
  } else { //A tick in between the end ticks
    if (mouseX <= current) { //Passed current
      ref.nextTick = ref.currentTick;
      ref.currentTick--;
      ref.interpValue = (ref.timeDirection == -1) ? 1 : 0;
    } else if (mouseX >= next) { //Passed next
      ref.currentTick = ref.nextTick;
      ref.nextTick++;
      ref.interpValue = (ref.timeDirection == -1) ? 1 : 0;
    } else {
      ref.setInterpolation(mouseX, current, next);
    }
    translateX = mouseX;
  }

  this.widget.select("#slidingTick").attr("transform", "translate(" + translateX + "," + ref.tickYPos + ")");
  this.widget.select("#anchor").attr("width", translateX - ref.sliderOffset);
  //this.widget.select("#anchor").attr("transform", "translate(" + translateX + "," + ref.anchorYPos + ")");
}
/** Determines how far the slider has travelled between two ticks (current and next) and sets
* the interpolation value accordingly (as percentage travelled)
* current,next: the tick indices
* mouseX: x-coordinate of mouse
* */
Slider.prototype.setInterpolation = function (mouseX, current, next) {
  var totalDistance = Math.abs(next - current);
  var distanceTravelled = Math.abs(mouseX - current);
  var newInterp = distanceTravelled / totalDistance;

  this.timeDirection = (newInterp > this.interpValue) ? 1 : (newInterp < this.interpValue) ? -1 : this.interpValue;
  this.interpValue = newInterp;
}
/** Updates the location of the draggable tick to the new view
* */
Slider.prototype.updateSlider = function (newView) {
  var ref = this;
  //Update the view tracker variables
  if (newView == ref.numTicks) {  //Last point of path
    ref.nextTick = newView;
    ref.currentTick = newView - 1;
  } else { //A point somewhere in the middle
    ref.currentTick = newView;
    ref.nextTick = newView + 1;
  }
  //Redraw the draggable tick at the new view
  this.widget.select("#slidingTick")
    //.attr("x",function (){return ref.tickPositions[newView];});
    .attr("transform", function () { return "translate(" + ref.tickPositions[newView] + "," + ref.tickYPos + ")"; });
  this.widget.select("#anchor").attr("width", this.tickPositions[newView] - this.sliderOffset);
}
/** Snaps the draggable tick to the nearest tick on the slider after the mouse is
*  released
* */
Slider.prototype.snapToTick = function () {
  var ref = this;
  this.widget.select("#slidingTick")
    //.attr("x",function (){
    .attr("transform", function () {
      var current = ref.tickPositions[ref.currentTick];
      var next = ref.tickPositions[ref.nextTick];
      var currentDist = Math.abs(current - ref.mouseX);
      var nextDist = Math.abs(next - ref.mouseX);
      if (currentDist > nextDist) {
        ref.currentTick = ref.nextTick;
        ref.nextTick++;
        ref.widget.select("#anchor").attr("width", next - ref.sliderOffset);
        return "translate(" + next + "," + ref.tickYPos + ")";
        //return (next-5);
      }
      ref.widget.select("#anchor").attr("width", current - ref.sliderOffset);
      return "translate(" + current + "," + ref.tickYPos + ")";
      //return (current-5);
    });

}
/** The tick is drawn according the to the provided interpolation amount,
*  and interpolation occurs between current and next view
*  Note: This function can be used to update the slider as another visualization
*  object is dragged (e.g., scatterplot point)
* */
Slider.prototype.animateTick = function (interpAmount, currentView, nextView) {
  var ref = this;
  if (interpAmount != 0) {
    this.widget.select("#slidingTick")
      .attr("transform", function () {
        var current = ref.tickPositions[currentView];
        var next = ref.tickPositions[nextView];
        var interpX = d3.interpolate(current, next)(interpAmount);
        ref.widget.select("#anchor").attr("width", interpX - ref.sliderOffset)
        return "translate(" + interpX + "," + ref.tickYPos + ")";
      });
  }
}

/** Constructor for a scatterplot visualization
 * w: width of the graph
 * h: height of the graph
 * p: a padding value, to format the axes
*/
function Scatterplot(w, h, p) {
  // Position and size attributes for drawing the svg
  this.padding = p;
  this.width = w;
  this.height = h;
  this.pointRadius = 8;
  this.loopRadius = 40;
  this.xLabel = "";
  this.yLabel = "";
  this.graphTitle = "";
  this.hintPathType = 0;

  this.loopCurrent = 0;
  this.loopNext = 1;

  // Create a variable to reference the main svg
  this.svg = null;
  this.numPoints = -1; //Set this later

  //Variables to track dragged point location within the hint path, all assigned values when the dataset is provided (in render())
  this.currentView = 0;
  this.nextView = 1;
  this.lastView = -1;  //The index of the last view of the dataset
  this.mouseX = -1; //Keep track of mouse coordinates for the dragend event
  this.mouseY = -1;
  this.interpValue = 0; //Stores the current interpolation value (percentage travelled) when a point is dragged between two views
  this.labels = []; //Stores the labels of the hint path
  this.ambiguousPoints = [];  //Keeps track of any points which are ambiguous when the hint path is rendered, by assigning the point a flag
  this.loops = []; //Stores points to draw for interaction loops (if any)
  this.timeDirection = 1; //Tracks the direction travelling over time

  //Save some angle values
  this.halfPi = Math.PI / 2;
  this.threePi_two = Math.PI * 3 / 2;
  this.twoPi = Math.PI * 2;
  this.pi = Math.PI;

  //Variables to track interaction events
  this.draggedPoint = -1;
  this.isAmbiguous = 0;  //Whether or not the point being dragged has at least one ambiguous case, set to 0 if none, and 1 otherwise

  //Event functions, declared later in this file or in the init file (if visualization is
  // interacting with another visualization) after the object has been instantiated
  this.placeholder = function () { };
  this.clickHintLabelFunction = this.placeholder;
  this.hintPathGenerator = d3.svg.line().interpolate("linear");

  this.clickedPoints = []; //Keeps track of which points to show labels for

  this.pointColour = "00A2E8";
  this.hintPathColour = "#aec7e8";

  this.hintPathPoints_flashlight = []; //For the flashlight hint path only, for keeping track of points currently visible on the hint path
}
/** Append a blank svg and g container to the div tag indicated by "id", this is where the visualization
*  will be drawn. Also, add a blur filter for the hint path effect.
* */
Scatterplot.prototype.init = function () {

  this.svg = d3.select("#mainSvg")
    .append("g").attr("id", "gScatterplot")
    .attr("transform", "translate(" + this.padding + "," + this.padding + ")");

  //Add the blur filter used for the hint path to the SVG so other elements can call it
  this.svg.append("svg:defs").append("svg:filter")
    .attr("id", "blur").append("svg:feGaussianBlur")
    .attr("stdDeviation", 2);

  //Add the blur filter for interaction loops
  this.svg.append("svg:defs").append("svg:filter")
    .attr("id", "blurLoop").append("svg:feGaussianBlur")
    .attr("stdDeviation", 1);

  //Add the blur filter for the partial hint path
  this.svg.append("svg:defs").append("svg:filter")
    .attr("id", "blur2").append("svg:feGaussianBlur")
    .attr("stdDeviation", 2);

  //Add the blur filter for the flashlight hint path
  this.svg.append("svg:defs").append("svg:filter")
    .attr("id", "blurFlashlight").append("svg:feGaussianBlur")
    .attr("stdDeviation", 2);
}
/** Render the visualization onto the svg
* data: The dataset to be visualized
* labels: A list of labels for the hint path, indicating all the different views of the visualization
*
* Data MUST be provided in the following array format:
* n is the number of views (or number of labels on the hint path)
* Object{"points":{[x,y],[x,y]...n},
*        "label":"name of data point" (optional)
*       }
*       ..... number of data points
* */
Scatterplot.prototype.render = function (data, labels, xLabel, yLabel, title) {
  var ref = this; //Reference variable
  //Save the parameters in global variables
  this.labels = labels;
  this.lastView = labels.length - 1;
  this.numPoints = data.length;
  this.xLabel = xLabel;
  this.yLabel = yLabel;
  this.graphTitle = title;

  //Find the max and min values of the points, used to scale the axes and the dataset
  var max_x = d3.max(data.map(function (d) { return d3.max(d.points.map(function (a) { return a[0]; })); }));
  var max_y = d3.max(data.map(function (d) { return d3.max(d.points.map(function (a) { return a[1]; })); }));
  var min_y = d3.min(data.map(function (d) { return d3.min(d.points.map(function (a) { return a[1]; })); }));

  //Create the scales by mapping the x,y to the svg size
  var xScale = d3.scale.linear().domain([0, max_x]).range([0, ref.width]);
  var yScale = d3.scale.linear().domain([min_y, max_y]).range([ref.height, 0]);
  //var yScale =  d3.scale.linear().domain([min_y, 50000000,max_y]).range([ref.height,ref.height/2,0]); //polylinear scale for the internet user dataset

  //Call the function which draws the axes
  this.drawAxes(xScale, yScale);

  // Set up the data for drawing the points according to the values in the data set
  this.svg.selectAll("circle")
    .data(data.map(function (d, i) {
      //Re-scale the points such that they are drawn within the svg container
      var scaledPoints = [];
      var interpolatedYears = [];
      for (var j = 0; j < d.points.length; j++) {
        //Check for missing data, interpolate based on surrounding points
        if (d.points[j][0] == "missing" || d.points[j][1] == "missing") {
          var newPoint = ref.interpolateMissingPoint(d.points, j);
          interpolatedYears.push(1);
          scaledPoints[j] = [xScale(newPoint.x) + ref.padding, yScale(newPoint.y)];
        } else {
          interpolatedYears.push(0);
          scaledPoints[j] = [xScale(d.points[j][0]) + ref.padding, yScale(d.points[j][1])];
        }
      }
      return { nodes: scaledPoints, id: i, label: d.label, interpYears: interpolatedYears };
    }))
    .enter().append("g")
    .attr("class", "gDisplayPoints").attr("id", function (d) { return "gDisplayPoints" + d.id });

  //Draw the data points
  this.svg.selectAll(".gDisplayPoints").append("svg:circle")
    .attr("cx", function (d) { return d.nodes[ref.currentView][0]; })
    .attr("cy", function (d) { return d.nodes[ref.currentView][1]; })
    .attr("r", this.pointRadius).attr("class", "displayPoints")
    .attr("id", function (d) { return "displayPoints" + d.id; })
    /** .attr("title", function (d) {return d.label;})*/
    .style("fill-opacity", 1).style("stroke", "#FFF").style("stroke-width", 1)
    .style("fill", this.pointColour).style("fill-opacity", 1);

  //Append an empty g element to contain the hint path
  this.svg.append("g").attr("id", "hintPath");
}
/**Interpolates the value for a year with missing data by using surrounding points
* points: the array of all points over time
* year: the year index of the missing data
* */
Scatterplot.prototype.interpolateMissingPoint = function (points, year) {
  var interpolator;
  if (year > 0 && year < points.length - 1) { //Not the first or last year
    interpolator = d3.interpolate({ x: points[year - 1][0], y: points[year - 1][1] },
      { x: points[year + 1][0], y: points[year + 1][1] });
  } else {
    interpolator = d3.interpolate({ x: 0, y: 0 },  //TODO:deal with end points, this is just a placeholder
      { x: 1, y: 1 });
  }
  return interpolator(0.5);
}
/** Draws the axes  and the graph title on the SVG
*  xScale: a function defining the scale of the x-axis
*  yScale: a function defining the scale of the y-axis
* */
Scatterplot.prototype.drawAxes = function (xScale, yScale) {

  //Define functions to create the axes
  var xAxis = d3.svg.axis().scale(xScale).orient("bottom")
    .tickSize(-this.height, 0, 0);
  var yAxis = d3.svg.axis().scale(yScale).orient("left")
    .tickSize(-this.width, 0, 0);

  // Add the title of the graph
  this.svg.append("text").attr("id", "graphTitle")
    .attr("class", "axis").text(this.graphTitle)
    .attr("x", 1).attr("y", -15);

  // Add the x-axis
  this.svg.append("g").attr("class", "axis")
    .attr("transform", "translate(" + this.padding + "," + this.height + ")")
    .call(xAxis).selectAll("line").style("fill", "none").style("stroke", "#BDBDBD");

  // Add the y-axis
  this.svg.append("g").attr("class", "axis")
    .attr("transform", "translate(" + this.padding + ",0)")
    .call(yAxis).selectAll("line").style("fill", "none").style("stroke", "#BDBDBD");

  // Add an x-axis label
  this.svg.append("text").attr("class", "axisLabel")
    .attr("x", this.width)
    .attr("y", this.height + this.padding - 10)
    .text(this.xLabel);

  // Add a y-axis label
  this.svg.append("text").attr("class", "axisLabel")
    .attr("x", -15).attr("transform", "rotate(-90)")
    .text(this.yLabel);
}
/** Appends an anchor to the svg, if there isn't already one
* */
Scatterplot.prototype.appendAnchor = function () {
  if (this.svg.select("#anchor").empty()) {
    this.svg.select("#hintPath").append("circle")
      .attr("id", "anchor").attr("r", this.pointRadius).style("stroke", "none")
      .style("fill", "none");
  }
}
/** Re-draws the anchor, based on the dragging along the loop
* interp: amount along the loop to draw the anchor at
* groupNumber: to select the id of the loop
* */
Scatterplot.prototype.redrawAnchor = function (interp, groupNumber) {
  var loopPath = d3.select("#loop" + groupNumber).node();
  var totalLength = loopPath.getTotalLength();
  var newPoint = loopPath.getPointAtLength(totalLength * interp);
  this.svg.select("#anchor").attr("cx", newPoint.x).attr("cy", newPoint.y).style("stroke", "#c7c7c7");
}
/**Hides the circle anchor by removing it's stroke colour
* */
Scatterplot.prototype.hideAnchor = function () {
  this.svg.select("#anchor").style("stroke", "none");
}
/** Removes an anchor from the svg, if one is appended
* */
Scatterplot.prototype.removeAnchor = function () {
  if (!this.svg.select("#anchor").empty()) {
    this.svg.select("#anchor").remove();
  }
}
/** Re-draws the dragged point by projecting it onto the the line segment according to
*  the minimum distance.  As the point is dragged, the views are updated and the rest
*  of the points are animated
*  id: The id of the dragged point, for selecting by id
*  mousex,y: the mouse coordinates
*  nodes: the points along the hint path
* */
Scatterplot.prototype.updateDraggedPoint = function (id, mouseX, mouseY, nodes) {
  if (this.hintPathType == 1) {
    this.updateDraggedPoint_flashlight(id, mouseX, mouseY, nodes);
    return;
  }
  var pt1_x = nodes[this.currentView][0];
  var pt2_x = nodes[this.nextView][0];
  var pt1_y = nodes[this.currentView][1];
  var pt2_y = nodes[this.nextView][1];
  var newPoint = [];

  if (this.isAmbiguous == 1) { //Ambiguous cases exist on the hint path

    var currentPointInfo = this.ambiguousPoints[this.currentView];
    var nextPointInfo = this.ambiguousPoints[this.nextView];

    if (currentPointInfo[0] == 1 && nextPointInfo[0] == 0) { //Approaching loop from left side of hint path (not on loop yet)
      this.loopCurrent = 3;
      this.loopNext = 4;
      newPoint = this.dragAlongPath(id, pt1_x, pt1_y, pt2_x, pt2_y);
    } else if (currentPointInfo[0] == 0 && nextPointInfo[0] == 1) { //Approaching loop from right side on hint path (not on loop yet)
      this.loopCurrent = 0;
      this.loopNext = 1;
      newPoint = this.dragAlongPath(id, pt1_x, pt1_y, pt2_x, pt2_y);
    } else if (currentPointInfo[0] == 1 && nextPointInfo[0] == 1) { //In middle of stationary point sequence
      this.dragAlongLoop(id, currentPointInfo[1], mouseX, mouseY);
      return;
    } else {
      newPoint = this.dragAlongPath(id, pt1_x, pt1_y, pt2_x, pt2_y);
    }
  } else { //No ambiguous cases exist
    newPoint = this.dragAlongPath(id, pt1_x, pt1_y, pt2_x, pt2_y);
  }

  var draggedPoint = this.svg.select("#displayPoints" + id);

  if (this.hintPathType == 3) { //Combined hint path mode
    //Find the distance from mouse to the point along the path
    var distance = findPixelDistance(this.mouseX, this.mouseY, newPoint[0], newPoint[1]);
    if (distance > 100) {
      this.hintPathType = 1;
    }
    draggedPoint.style("fill-opacity", 1 - Math.abs(findPixelDistance(this.mouseX, this.mouseY, newPoint[0], newPoint[1]) / 100));
  }

  //Re-draw the dragged point
  draggedPoint.attr("cx", newPoint[0]).attr("cy", newPoint[1]);
  this.animatePointLabel(id, newPoint[0], newPoint[1]);

  //Save the mouse coordinates
  this.mouseX = mouseX;
  this.mouseY = mouseY;
}
/** Re-draws the dragged point according to the mouse position, changing the hint path
* display according to the flashlight design
*  id: The id of the dragged point, for selecting by id
*  mousex,y: the mouse coordinates
*  nodes: the points along the hint path
* */
Scatterplot.prototype.updateDraggedPoint_flashlight = function (id, mouseX, mouseY, nodes) {
  //TODO: ambiguity?
  if (this.hintPathType == 3) { //Check if near the time line hint path, if using combined hint path mode

  }

  this.drawHintPath_flashlight([mouseX, mouseY], nodes);
  //Re-draw the dragged point
  this.svg.select("#displayPoints" + id).attr("cx", mouseX).attr("cy", mouseY);
  this.animatePointLabel(id, mouseX, mouseY);

  //Save the mouse coordinates
  this.mouseX = mouseX;
  this.mouseY = mouseY;
}
/** Calculates the new position of the dragged point
* id: of the dragged point
* pt1, pt2: the boundary points (of current and next view)
* @return the coordinates of the newPoint as an array [x,y]
* */
Scatterplot.prototype.dragAlongPath = function (id, pt1_x, pt1_y, pt2_x, pt2_y) {

  //Get the two points of the line segment currently dragged along
  var minDist = this.minDistancePoint(this.mouseX, this.mouseY, pt1_x, pt1_y, pt2_x, pt2_y);
  var newPoint = []; //The new point to draw on the line
  var t = minDist[2]; //To test whether or not the dragged point will pass pt1 or pt2

  //Update the position of the dragged point
  if (t < 0) { //Passed current
    this.moveBackward();
    newPoint = [pt1_x, pt1_y];
  } else if (t > 1) { //Passed next
    this.moveForward();
    newPoint = [pt2_x, pt2_y];
  } else { //Some in between the views (pt1 and pt2)
    this.interpolatePoints(id, t, this.currentView, this.nextView);
    this.interpolateLabelColour(t);
    newPoint = [minDist[0], minDist[1]];
    //Save the values
    this.timeDirection = this.findTimeDirection(t);
    this.interpValue = t; //Save the interpolation amount
    if (this.hintPathType == 2) {
      redrawPartialHintPath_line(this, this.ambiguousPoints);
    }
  }
  return newPoint;
}
/** Sets the time direction based on the interpolation amount, currently not needed for the interaction
*  But can be used to log events.
* @return: the new direction travelling in time
* */
Scatterplot.prototype.findTimeDirection = function (interpAmount) {
  var direction = (interpAmount > this.interpValue) ? 1 : (interpAmount < this.interpValue) ? -1 : this.timeDirection;

  if (this.timeDirection != direction) { //Switched directions
    console.log("switched directions " + direction + " currentInterp " + this.interpValue + " newInterp " + interpAmount + " " + this.currentView + " " + this.nextView);
  }
  return direction;
}
/** Updates the view variables to move the visualization forward
* (passing the next view)
* */
Scatterplot.prototype.moveForward = function () {
  if (this.nextView < this.lastView) { //Avoid index out of bounds
    this.currentView = this.nextView;
    this.nextView++;
    this.timeDirection = 1;
    this.interpValue = 0;
  }
}
/** Updates the view variables to move the visualization backward
* (passing the current view)
* */
Scatterplot.prototype.moveBackward = function () {
  if (this.currentView > 0) { //Avoid index out of bounds
    this.nextView = this.currentView;
    this.currentView--;
    this.timeDirection = -1;
    this.interpValue = 1;
  }
}
/**Interpolates the label transparency between start and end view, this fading effect is used for
* distinguishing how close the user is from transitioning views the stationary ambiguous cases.
* interp: the interpolation amount (amount travelled across start to end)
* */
Scatterplot.prototype.interpolateLabelColour = function (interp) {
  var ref = this;
  this.svg.selectAll(".hintLabels").attr("fill-opacity", function (d) {
    if (d.id == ref.currentView) { //Dark to light
      return d3.interpolate(1, 0.5)(interp);
    } else if (d.id == ref.nextView) { //Light to dark
      return d3.interpolate(0.5, 1)(interp);
    }
    return 0.5;
  });
}
Scatterplot.prototype.dragAlongLoop = function (id, groupNumber, mouseX, mouseY) {

  var loopData = this.svg.select("#loop" + groupNumber).data().map(function (d) { return [d.cx, d.cy, d.orientationAngle, d.points2, d.years] });

  //var loopGenerator = d3.svg.line().interpolate("linear"); 
  //this.svg.select("#hintPath").append("path").attr("d",loopGenerator(loopData[0][3])).style("fill","none").style("stroke","#FFF");


  //d.points[0] = stationary point
  //d.points[1] = to the left of the stationary pt (forward path)
  //d.points[2..] = etc.. keep going counter clockwise
  // this.svg.append("circle").attr("cx",loopData[0][3][3][0]).attr("cy",loopData[0][3][3][1]).attr("r",10).style("fill","red");
  var loopPoints = loopData[0][3];
  var pt1_x = loopPoints[this.loopCurrent][0];
  var pt1_y = loopPoints[this.loopCurrent][1];
  var pt2_x = loopPoints[this.loopNext][0];
  var pt2_y = loopPoints[this.loopNext][1];

  var minDist = this.minDistancePoint(mouseX, mouseY, pt1_x, pt1_y, pt2_x, pt2_y);
  var newPoint = []; //The new point to draw on the line
  var t = minDist[2]; //To test whether or not the dragged point will pass pt1 or pt2

  var angles = this.calculateMouseAngle(minDist[0], minDist[1], loopData[0][2], loopData[0][0], loopData[0][1]);
  var loopInterp = this.convertMouseToLoop_interp(angles[2]);

  //Get the loop's boundary years
  var startYear = loopData[0][4][0];
  var endYear = loopData[0][4][loopData[0][4].length - 1];

  if (t < 0) { //Passed current on loop
    this.loopNext = this.loopCurrent;
    this.loopCurrent--;
    if (this.loopCurrent < 0) { //Check if the view was passed
      if (this.currentView > startYear) { //In the middle of the loop (2 is the border view)
        this.moveBackward();
        this.loopCurrent = 3;
        this.loopNext = 4;
      } else { //Move back to the full hint path
        this.loopCurrent = 0;
        this.loopNext = 1;
        this.moveBackward();
      }
    }
    //console.log("backward"+this.loopCurrent+" "+this.loopNext+" views"+this.currentView+" "+this.nextView);
  } else if (t > 1) { //Passed next on the loop
    this.loopCurrent = this.loopNext;
    this.loopNext++;
    if (this.loopCurrent > 3) { //Check if the view was passed
      if (this.nextView < endYear) { //Not at the border view
        this.loopCurrent = 0;
        this.loopNext = 1;
        this.moveForward();
      } else {
        this.loopCurrent = 3;
        this.loopNext = 4;
        this.moveForward();
      }
    }
    //console.log("forward"+this.loopCurrent+" "+this.loopNext+" views"+this.currentView+" "+this.nextView);
  } else { //Some in between the views (pt1 and pt2), redraw the anchor and the view
    //this.svg.select("#anchor").attr("cx",minDist[0]).attr("cy",minDist[1]).style("stroke","#c7c7c7");       
    this.interpAmount = angles[2];
    this.timeDirection = this.findTimeDirection(this.interpAmount, id);
    this.interpolatePoints(id, this.interpAmount, this.currentView, this.nextView);
    this.interpolateLabelColour(this.interpAmount);
    if (this.hintPathType == 2) {
      redrawPartialHintPath_line(this, this.ambiguousPoints, this.id);
    }
  }
  this.redrawAnchor(loopInterp, groupNumber);
}
/**Finds the angle of the mouse w.r.t the center of the loop
* @return [angle,positiveAngle,interpAmount]
* */
Scatterplot.prototype.calculateMouseAngle = function (mouseX, mouseY, orientationAngle, loopCx, loopCy) {

  var newAngle;
  var subtractOne = 0; //For adjusting the interpolation value

  if (orientationAngle < this.halfPi && orientationAngle >= 0) { //Between 0 (inclusive) and 90
    newAngle = Math.atan2(mouseY - loopCy, loopCx - mouseX) + orientationAngle; //0/360 deg
  } else if (orientationAngle < this.twoPi && orientationAngle >= this.threePi_two) { //Between 360/0 and 270 (inclusive)
    subtractOne = 1;
    newAngle = Math.atan2(loopCx - mouseX, mouseY - loopCy) - (orientationAngle - this.threePi_two);  //270 deg
  } else if (orientationAngle < this.threePi_two && orientationAngle >= this.pi) { //Between 270 and 180 (inclusive)
    newAngle = Math.atan2(loopCy - mouseY, mouseX - loopCx) + (orientationAngle - this.pi); //180 deg
  } else {
    subtractOne = 1;
    newAngle = Math.atan2(mouseX - loopCx, loopCy - mouseY) - (orientationAngle - this.halfPi); // 90 deg
  }

  var positiveAngle = (newAngle < 0) ? ((this.pi - newAngle * (-1)) + this.pi) : newAngle;

  var interpAmount = (subtractOne == 1) ? (1 - positiveAngle / this.twoPi) : (positiveAngle / this.twoPi);

  return [newAngle, positiveAngle, interpAmount];
}
/** Adjusts the interpolation value of the mouse angle (1/0 mark is at the stationary point) to draw correctly on
*  the loop (where 0.5 is at the stationary point)
* */
Scatterplot.prototype.convertMouseToLoop_interp = function (mouseInterp) {
  return (mouseInterp >= 0 && mouseInterp < 0.5) ? (mouseInterp + 0.5) : (mouseInterp - 0.5);
}
/**"Animates" the rest of the points while one is being dragged
* Uses the 't' parameter, which represents approximately how far along a line segment
* the dragged point has travelled.  The positions of the rest of the points are interpolated
* based on this t parameter and re-drawn at this interpolated position
* id: The id of the dragged point
* interpAmount: The t parameter, or amount to interpolate by
* startView,endView: Define the range to interpolate across
* */
Scatterplot.prototype.interpolatePoints = function (id, interpAmount, startView, endView) {
  var ref = this;
  this.svg.selectAll(".displayPoints").filter(function (d) { return d.id != id; })
    .each(function (d) {
      var interpolator = d3.interpolate({ x: d.nodes[startView][0], y: d.nodes[startView][1] },
        { x: d.nodes[endView][0], y: d.nodes[endView][1] }); //Function to linearly interpolate between points at current and next view
      var newPoint = interpolator(interpAmount);
      //Update the position of the point according to the interpolated point position
      d3.select(this).attr("cx", newPoint.x).attr("cy", newPoint.y);

      //Update the labels (if visible)
      if (ref.clickedPoints.indexOf(d.id) != -1) ref.animatePointLabel(d.id, newPoint.x, newPoint.y);
    })
}
/**Re-draws a point label according to the specified position (new position of the point) by
* updating its x and y attributes
* @param id of the point label
* @param x,y, new position of the label
* */
Scatterplot.prototype.animatePointLabel = function (id, x, y) {
  var ref = this;
  this.svg.select("#pointLabel" + id).attr("x", x).attr("y", y - ref.pointRadius);
}
/** Snaps to the nearest view once a dragged point is released
*  Nearest view is the closest position (either current or next) to the
*  most recent position of the dragged point. View tracking variables are
*  updated according to which view is "snapped" to.
*  id: The id of the dragged point
*  points: All points along the hint path
* */
Scatterplot.prototype.snapToView = function (id, points) {
  if (this.hintPathType == 1) { //Snapping is different for flashlight hint path
    this.snapToView_flashlight(id, points);
    return;
  }
  var distanceCurrent, distanceNext;
  if (this.ambiguousPoints[this.currentView][0] == 1 && this.ambiguousPoints[this.nextView][0] == 1) { //Current and next are stationary points
    distanceCurrent = this.interpValue;
    distanceNext = 0.5;
  } else { //Non-ambiguous point
    //Calculate the distances from the dragged point to both current and next
    distanceCurrent = this.calculateDistance(this.mouseX, this.mouseY, points[this.currentView][0], points[this.currentView][1]);
    distanceNext = this.calculateDistance(this.mouseX, this.mouseY, points[this.nextView][0], points[this.nextView][1]);
  }

  //Based on the smaller distance, update the scatter plot to that view
  if (distanceCurrent > distanceNext && this.nextView <= this.lastView) { //Snapping to next view
    this.currentView = this.nextView;
    this.nextView = this.nextView + 1;
  }

  //Redraw the view
  this.redrawView(this.currentView);
}
/** Snaps to the nearest view once a dragged point is released
*  Nearest view is the closest position
*  id: The id of the dragged point
*  points: All points along the hint path
* */
Scatterplot.prototype.snapToView_flashlight = function (id, points) {
  var minDist = Number.MAX_VALUE;
  var viewToSnapTo = -1;
  var currentPointIndex = -1;
  //TODO: might want to save the current positions visible on the hint path to avoid re-calculating all distances
  for (var i = 0; i < this.hintPathPoints_flashlight.length; i++) {
    currentPointIndex = this.hintPathPoints_flashlight[i];
    var currentDist = this.calculateDistance(points[currentPointIndex][0], points[currentPointIndex][1], this.mouseX, this.mouseY);
    if (currentDist < minDist) {
      minDist = currentDist;
      viewToSnapTo = currentPointIndex;
    }
  }
  if (viewToSnapTo < this.lastView) {
    this.currentView = viewToSnapTo;
    this.nextView = this.currentView + 1;
  }
  this.drawHintPath_flashlight(points[viewToSnapTo], points);
  this.redrawView(viewToSnapTo);
}
/** Animates all points in the scatterplot along their hint paths from
*  startView to endView, this function is called when "fast-forwarding"
*  is invoked (by clicking a year label on the hint path)
*  id: of the dragged point (if any)
*  startView, endView: animation goes from start to end view
*  Resources: http://bl.ocks.org/mbostock/1125997
*            http://bost.ocks.org/mike/transition/
* */
Scatterplot.prototype.animatePoints = function (id, startView, endView) {

  if (this.hintPathType == 1) { //Go directly to the year, when using flashlight path
    this.redrawView(endView);
    return;
  }

  if (startView == endView) return;
  var ref = this;
  //Determine the travel direction (e.g., forward or backward in time)
  var direction = 1;
  if (startView > endView) direction = -1;

  //Define some counter variables to keep track of the views passed during the transition
  var totalObjects = this.numPoints;
  var objectCounter = -1;
  var animateView = startView; //Indicates when to switch the views (after all points are finished transitioning)

  //Apply multiple transitions to each display point by chaining them
  this.svg.selectAll(".displayPoints").each(animate());

  //Recursively invoke this function to chain transitions, a new transition is added once
  //the current one is finished
  function animate() {
    objectCounter++;
    if (objectCounter == totalObjects) {
      animateView = animateView + direction;
      objectCounter = 0;
    }

    //Ensure the animateView index is not out of bounds
    if (direction == 1 && animateView >= endView) { return };
    if (direction == -1 && animateView <= endView) { return };

    return function (d) {
      //Re-draw each point at the current view in the animation sequence
      d3.select(this).transition(400).ease("linear")
        .attr("cx", d.nodes[animateView][0])
        .attr("cy", d.nodes[animateView][1])
        .each("end", animate());
      ref.animatePointLabel(d.id, d.nodes[animateView][0], d.nodes[animateView][1]);
      //Re-colour the labels along the hint path (if a path is visible)
      if (d.id == id) {
        d3.selectAll(".hintLabels").attr("fill-opacity", function (b) { return ((b.id == animateView) ? 1 : 0.5) });
      }
    };
  }
}
/** Redraws the scatterplot's point labels at the specified view
*  view: the view to draw
* */
Scatterplot.prototype.redrawPointLabels = function (view) {
  var ref = this;
  this.svg.selectAll(".pointLabels").filter(function (d) { return (ref.clickedPoints.indexOf(d.id) != -1) })
    .attr("x", function (d) { return d.nodes[view][0]; })
    .attr("y", function (d) { return d.nodes[view][1] - ref.pointRadius; });
}
/** Redraws the scatterplot at a specified view
*  view: the view to draw
*  NOTE: view tracking variables are not updated by this function
* */
Scatterplot.prototype.redrawView = function (view) {
  /**if (this.hintPathType==2){ //Partial hint path
      hideSmallHintPath(this);
  }*/
  if (this.hintPathType == 0) { //Trajectory
    this.hideAnchor();
    //Re-colour the hint path labels
    this.svg.selectAll(".hintLabels").attr("fill-opacity", function (d) { return ((d.id == view) ? 1 : 0.5) });
    this.svg.selectAll(".displayPoints")/**.transition().duration(300)*/
      .attr("cx", function (d) { return d.nodes[view][0]; })
      .attr("cy", function (d) { return d.nodes[view][1]; });

  } else if (this.hintPathType == 1) { //Flashlight
    this.svg.selectAll(".displayPoints").transition().duration(300)
      .attr("cx", function (d) { return d.nodes[view][0]; })
      .attr("cy", function (d) { return d.nodes[view][1]; });
  }
  this.redrawPointLabels(view);
}
/** Called each time a new point is dragged.  Searches for ambiguous regions, and draws the hint path
*  */
Scatterplot.prototype.selectPoint = function (point) {
  //In case next view went out of bounds (from snapping to view), re-adjust the view variables
  var drawingView = adjustView(this);

  //First check for ambiguous cases in the hint path of the dragged point, then draw loops (if any)
  this.checkAmbiguous(point.id, point.nodes);

  if (this.isAmbiguous == 1) {
    this.appendAnchor();
  }

  if (this.hintPathType == 0) { //Trajectory path
    this.drawHintPath(drawingView, point.nodes, point.interpYears);
  } else if (this.hintPathType == 1) { //Flashlight path
    this.drawHintPath_flashlight(point.nodes[drawingView], point.nodes);
  } else if (this.hintPathType == 2) { //Partial hint path used in evaluation
    drawPartialHintPath_line(this, 0, point.nodes);
    redrawPartialHintPath_line(this, this.ambiguousPoints);
  } else if (this.hintPathType == 3) { //Combined
    this.drawHintPath(drawingView, point.nodes, point.interpYears);
  }

  if (this.clickedPoints.indexOf(point.id) == -1) {
    this.clickedPoints.push(point.id);
    this.drawPointLabel(point.id);
  }
  var ref = this;
  //Fade out the other points using a transition
  this.svg.selectAll(".displayPoints").filter(function (d) { return (ref.clickedPoints.indexOf(d.id) == -1) })
    .transition().duration(300).style("fill-opacity", 0.3);//.style("stroke-opacity",0.3);
}
/** Draws a label at the top of the selected point
* */
//TODO: draw a line from the corner of the label to the point
Scatterplot.prototype.drawPointLabel = function (id) {
  var ref = this;
  //Add labels to the points
  var gElement = this.svg.select("#gDisplayPoints" + id);
  gElement.append("text")
    .attr("x", function (d) { return d.nodes[ref.currentView][0]; })
    .attr("y", function (d) { return d.nodes[ref.currentView][1] - ref.pointRadius; })
    .attr("class", "pointLabels").attr("id", function (d) { return "pointLabel" + d.id })
    .text(function (d) { return d.label; });

  /**var bbox =  this.svg.select("#pointLabel"+id).node().getBBox();
  var padding = 2;

  gElement.append("rect").attr("x", bbox.x-padding).attr("y", bbox.y-padding)
      .attr("height",bbox.height+padding*2).attr("width",bbox.width+padding*2)
      .attr("rx",5).attr("ry",5)
      .attr("class","pointLabels").style("fill","#EDEDED").style("fill-opacity",0.3)
      .style("stroke","#EDEDED").style("stroke-opacity",1);*/
}
/** Displays a trajectory hint path by appending its svg components to the main svg
*  view: view to draw at
*  points: all points along the hint path
*  interpPts: points that have been interpolated (missing data)
* */
Scatterplot.prototype.drawHintPath = function (view, points, interpPts) {
  var ref = this;
  //Draw the hint path labels, reposition any which are in a stationary sequence
  var adjustedPoints = this.placeLabels(points);

  this.svg.select("#hintPath").selectAll("text")
    .data(adjustedPoints.map(function (d, i) {
      return { x: d[0] + ref.pointRadius, y: d[1] + ref.pointRadius, id: i }
    })).enter().append("svg:text")
    .text(function (d, i) {
      if (interpPts[i] == 1) return "";  //Don't show the labels of interpolated years
      return ref.labels[d.id];
    }).attr("x", function (d) { return d.x; })
    .attr("y", function (d) { return d.y; })
    .attr("class", "hintLabels")
    .attr("fill-opacity", function (d) { return ((d.id == view) ? 1 : 0.5) })
    .attr("id", function (d) { return "hintLabels" + d.id })
    .style("font-family", "sans-serif").style("font-size", "10px").style("text-anchor", "middle")
    .style("fill", "#666").on("click", this.clickHintLabelFunction);

  //Render the hint path line
  this.svg.select("#hintPath").append("svg:path")
    .attr("d", this.hintPathGenerator(points))
    .attr("id", "path").attr("filter", "url(#blur)")
    .style("fill", "none").style("stroke-width", 1.5).style("stroke", this.pointColour);
}
/** Re-draws a flashlight style hint path as the point is dragged
*  currentPosition: position of the dragged point
*  points: all points along the hint path
* */
Scatterplot.prototype.drawHintPath_flashlight = function (currentPosition, points) {
  this.svg.select("#hintPath").selectAll(".hintLabels").remove();
  this.svg.select("#hintPath").selectAll("path").remove();
  this.hintPathPoints_flashlight = [];

  //TODO: ambiguity?
  //var currentPosition = points[view];
  var distances = [];
  for (var i = 0; i < points.length; i++) { //Grab the closest n points to the current position
    distances.push([this.calculateDistance(currentPosition[0], currentPosition[1], points[i][0], points[i][1]), i]);
  }
  distances.sort(function (a, b) { return a[0] - b[0] }); //Sort ascending
  var maxDistance = distances[4][0]; //For scaling the transparency

  var pathPoints = [];
  var ref = this;
  for (var i = 0; i < 4; i++) { //Start at 1, we know the zero distance will be the first element in the sorted array
    pathPoints.push(points[distances[i][1]]);
    var pointIndex = distances[i][1];
    this.svg.select("#hintPath").append("svg:path")
      .attr("d", this.hintPathGenerator([points[pointIndex], currentPosition]))
      .attr("id", "path").attr("filter", "url(#blurFlashlight)").attr("opacity", Math.abs(1 - distances[i][0] / maxDistance))
      .style("fill", "none").style("stroke-width", 1).style("stroke", this.pointColour);
    this.hintPathPoints_flashlight.push(pointIndex);
  }

  //Draw the hint path labels
  this.svg.select("#hintPath").selectAll("text").data(pathPoints.map(function (d, i) {
    return { x: d[0], y: d[1], id: ref.hintPathPoints_flashlight[i], id2: i }
  })).enter().append("text").text(function (d) { return ref.labels[d.id] }).attr("x", function (d) { return d.x; })
    .attr("y", function (d) { return d.y; }).attr("class", "hintLabels")
    .attr("fill-opacity", function (d) { return Math.abs(1 - distances[d.id2][0] / maxDistance) })
    .attr("id", function (d) { return "hintLabels" + d.id })
    .style("font-family", "sans-serif").style("font-size", "10px").style("text-anchor", "middle")
    .style("fill", "#666").on("click", this.clickHintLabelFunction);
}
/**This function places labels in ambiguous cases such that they do not overlap
* points: a 2D array of positions of each label [x,y]...
* */
Scatterplot.prototype.placeLabels = function (points) {
  if (this.isAmbiguous == 0) { return points } //No ambiguous cases, don't need to adjust the points

  var ref = this;
  var offset = -1;
  var indexCounter = -1;
  var x = 0;
  var y = 0;
  var adjustedPoints = points.map(function (d, i) {
    if (ref.ambiguousPoints[i][0] == 1 /**|| ref.ambiguousPoints[i][0] == 2*/) {
      if (ref.ambiguousPoints[i][1] != offset) {
        indexCounter = -1;
        offset = ref.ambiguousPoints[i][1];
        x = d[0];
        y = d[1];
      }
      indexCounter++;
      return [x + 25 * indexCounter, y - 10];
    }
    return [d[0], d[1]];
  });
  return adjustedPoints;
}
/**This function places labels in ambiguous cases for a flashlight hint path, aligned vertically and equally spaced
* points: a 2D array of positions of each label [x,y]...
* */
Scatterplot.prototype.placeLabels_flashlight = function (points) {
  if (this.isAmbiguous == 0) { return points } //No ambiguous cases, don't need to adjust the points

  var ref = this;
  var offset = -1;
  var indexCounter = -1;
  var x = 0;
  var y = 0;
  var adjustedPoints = points.map(function (d, i) {
    if (ref.ambiguousPoints[i][0] == 1 /**|| ref.ambiguousPoints[i][0] == 2*/) {
      if (ref.ambiguousPoints[i][1] != offset) {
        indexCounter = -1;
        offset = ref.ambiguousPoints[i][1];
        x = d[0];
        y = d[1];
      }
      indexCounter++;
      return [x, y + 25 * indexCounter];
    }
    return [d[0], d[1]];
  });
  return adjustedPoints;
}
/** Draws interaction loops as svg paths onto the hint path (if point has stationary cases)
*  id: of the dragged point
* */
Scatterplot.prototype.drawLoops = function (id, points) {
  //Create a function for drawing a loop around a stationary point, as an interaction path
  var loopGenerator = d3.svg.line().tension(0).interpolate("basis-closed"); //Closed B-spline
  var ref = this;

  //Draw all loops at their respective stationary points
  this.svg.select("#hintPath").selectAll(".loops")
    .data(points.map(function (d, i) {
      var loopPoints = [];
      loopPoints = ref.calculateLoopPoints(d[0], d[1], d[2]);
      var x = d[0] + (ref.loopRadius / 2) * Math.cos(d[2]);
      var y = d[1] + (ref.loopRadius / 2) * Math.sin(d[2]);
      var repeatedYears = [];
      for (var j = 0; j < ref.ambiguousPoints.length; j++) {
        if (ref.ambiguousPoints[j][0] == 1 && ref.ambiguousPoints[j][1] == i) {
          repeatedYears.push(j);
        }
      }
      return { points: loopPoints[0], id: i, orientationAngle: d[2], cx: x, cy: y, points2: loopPoints[1], years: repeatedYears };
    }))
    .enter().append("path").attr("class", "loops")
    .attr("d", function (d) { return loopGenerator(d.points); })
    .attr("id", function (d, i) { return "loop" + i; })
    .style("fill", "none").style("stroke", "#666").style("stroke-dasharray", "3,3")
    .attr("filter", "url(#blurLoop)");
}
/** Clears the hint path by removing it, also re-sets the transparency of the faded out points and the isAmbiguous flag */
Scatterplot.prototype.clearHintPath = function () {
  this.isAmbiguous = 0;
  this.removeAnchor();

  //Remove the hint path svg elements
  this.svg.select("#hintPath").selectAll("text").remove();
  this.svg.select("#hintPath").selectAll("path").remove();
  this.svg.select("#hintPath").selectAll("circle").remove();

  //Re-set the transparency of faded out points
  this.svg.selectAll(".displayPoints").style("fill-opacity", 1);
}
/**Clears the point labels when the background is clicked
* */
Scatterplot.prototype.clearPointLabels = function () {
  this.svg.selectAll(".pointLabels").remove();
  this.clickedPoints = [];
}
/** Calculates the distance between two points
* (x1,y1) is the first point
* (x2,y2) is the second point
* @return the distance, avoiding the square root
* */
Scatterplot.prototype.calculateDistance = function (x1, y1, x2, y2) {
  var term1 = x1 - x2;
  var term2 = y1 - y2;
  return (term1 * term1) + (term2 * term2);
}
/** Finds the minimum distance between a point at (x,y), with respect
* to a line segment defined by points (pt1_x,pt1_y) and (pt2_x,pt2_y)
* Code based on: http://stackoverflow.com/questions/849211/shortest
* -distance-between-a-point-and-a-line-segment
* Formulas can be found at: http://paulbourke.net/geometry/pointlineplane/
* @return the point on the line at the minimum distance and the t parameter, as an array: [x,y,t]
* */
Scatterplot.prototype.minDistancePoint = function (x, y, pt1_x, pt1_y, pt2_x, pt2_y) {

  var distance = this.calculateDistance(pt1_x, pt1_y, pt2_x, pt2_y);
  //Two points of the line segment are the same
  if (distance == 0) return [pt1_x, pt1_y, 0];

  var t = ((x - pt1_x) * (pt2_x - pt1_x) + (y - pt1_y) * (pt2_y - pt1_y)) / distance;
  if (t < 0) return [pt1_x, pt1_y, t]; //Point projection goes beyond pt1
  if (t > 1) return [pt2_x, pt2_y, t]; //Point projection goes beyond pt2

  //Otherwise, point projection lies on the line somewhere
  var minX = pt1_x + t * (pt2_x - pt1_x);
  var minY = pt1_y + t * (pt2_y - pt1_y);
  return [minX, minY, t];
}
/** Computes the points to lie along an interaction loop
* Note: this function is only called in findLoops()
* x,y: Define the center point of the loop (sort of)
* angle: the angle to orient the loop at
* @return an array of all loop points and the year index in the format: [[x,y], etc.]
* */
Scatterplot.prototype.calculateLoopPoints = function (x, y, angle) {
  var drawingPoints = [];
  var loopWidth = Math.PI / 5; //Change this value to expand/shrink the width of the loop

  //The first point of the path should be the original point, as a reference for drawing the loop
  drawingPoints.push([x, y]);

  //Generate some polar coordinates to complete the round part of the loop
  drawingPoints.push([(x + this.loopRadius * Math.cos(angle + loopWidth)), (y + this.loopRadius * Math.sin(angle + loopWidth))]);
  drawingPoints.push([(x + this.loopRadius * Math.cos(angle)), (y + this.loopRadius * Math.sin(angle))]);
  drawingPoints.push([(x + this.loopRadius * Math.cos(angle - loopWidth)), (y + this.loopRadius * Math.sin(angle - loopWidth))]);

  //The last point of the path should be the original point, as a reference for drawing the loop
  drawingPoints.push([x, y]);

  //Hack here!!!- another set of points for handling dragging around loops
  var loopPoints = [];
  loopWidth = Math.PI / 7; //Change this value to expand/shrink the width of the loop
  var adjustedRadius = this.loopRadius - 10;
  //The first point of the path should be the original point, as a reference for drawing the loop
  loopPoints.push([x, y]);

  //TODO: automatically assign dragging direction to loops
  //Generate some polar coordinates to complete the round part of the loop
  //HACK: use this when dragging segways to the left
  /**loopPoints.push([(x + adjustedRadius*Math.cos(angle+loopWidth)),(y+ adjustedRadius*Math.sin(angle+loopWidth))]);
  loopPoints.push([(x + adjustedRadius*Math.cos(angle)),(y+ adjustedRadius*Math.sin(angle))]);
  loopPoints.push([(x + adjustedRadius*Math.cos(angle-loopWidth)),(y+ adjustedRadius*Math.sin(angle-loopWidth))]);*/

  //HACK: use this point order when dragging segways right
  loopPoints.push([(x + adjustedRadius * Math.cos(angle - loopWidth)), (y + adjustedRadius * Math.sin(angle - loopWidth))]);
  loopPoints.push([(x + adjustedRadius * Math.cos(angle)), (y + adjustedRadius * Math.sin(angle))]);
  loopPoints.push([(x + adjustedRadius * Math.cos(angle + loopWidth)), (y + adjustedRadius * Math.sin(angle + loopWidth))]);

  //The last point of the path should be the original point, as a reference for drawing the loop
  loopPoints.push([x, y]);

  return [drawingPoints, loopPoints];
}
/** Search for ambiguous cases in a list of points.  Ambiguous cases are tagged as '1' and non-ambiguous are '0'.
*  If ambiguous cases are found, draws loops.
*  This function populates the following global array:
*  this.ambiguousPoints:[[type,group]..total number of points on hint path], Group is an index indicating
*  which group stationary points the point belongs to.
*
*  id: of the dragged point
*  points: an array of points to search within for ambiguity
* */
Scatterplot.prototype.checkAmbiguous = function (id, points) {
  var j, currentPoint;
  var repeatedPoints = [];
  var foundIndex = -1;
  var groupNum = 0;

  //Clear and re-set the global arrays
  this.ambiguousPoints = [];
  //this.closePoints = [];
  for (j = 0; j <= this.lastView; j++) {
    this.ambiguousPoints[j] = [0];
    //this.closePoints[j] = [0];
  }
  var savedIndex = -1;
  //Populate the stationary and revisiting points array
  //Search for points that match in the x and y values (called "stationary points")
  for (j = 0; j <= this.lastView; j++) {
    currentPoint = points[j];
    for (var k = 0; k <= this.lastView; k++) {
      if (j != k) {
        var distance = findPixelDistance(points[k][0], points[k][1], currentPoint[0], currentPoint[1]);
        if ((points[k][0] == currentPoint[0] && points[k][1] == currentPoint[1]) || (distance <= 10)) { //A repeated point is found
          if (Math.abs(k - j) == 1) { //Stationary point
            this.isAmbiguous = 1;
            if (Math.abs(savedIndex - j) > 1 && savedIndex != -1) {
              groupNum++;
            }
            this.ambiguousPoints[j] = [1, groupNum];
            savedIndex = j;
          }/**else{ //Found a revisiting point
                       if (this.ambiguousPoints[j][0] ==0){ //Don't want to overwrite a stationary point
                           this.ambiguousPoints[j] = [2,groupNum];
                       }
                   }*/
        }
      }
    }
  }   //Draw the interaction loop(s) (if any)
  if (this.isAmbiguous == 1) {
    //TODO: automatically orient the loops such that they blend with the path
    var currentGroupNum = -1;
    for (var i = 0; i < this.ambiguousPoints.length; i++) {
      if (this.ambiguousPoints[i].length > 1) {
        if (this.ambiguousPoints[i][1] != currentGroupNum) {
          repeatedPoints.push([points[i][0], points[i][1], Math.PI * 3 / 2]);
        }
        currentGroupNum = this.ambiguousPoints[i][1];
      }
    }
    this.drawLoops(id, repeatedPoints);
  }
}
/** Search for x,y in a 2D array with the format: [[x,y]..number of points]
*  x,y: the point to search for
*  array: the array to search within
*  @return -1 if no match is found, or the index of the found match
* */
Scatterplot.prototype.findInArray = function (x, y, array) {
  if (array.length == 0) return -1;
  for (var j = 0; j < array.length; j++) {
    if (array[j][0] == x && array[j][1] == y) {
      return j;
    }
  }
  return -1;
}

/**
 * This file contains functions which can be used across all prototypes,
 * mostly shared across barchart, heatmap and piechart (since they are very similar)
 *
 * All functions must be passed a variable containing a reference to the object (this)
 * in order to access object variables and/or functions
 */
//TODO: move functions related to user study to a separate file
/**Clears the visualization elements appended to the SVG (used when the dataset is changed
 * objectClass: is the class name e.g., ".bars", assigned to all data objects associated with the
 * visualization
 * */
function clearVis(objectClass) {
  if (!d3.selectAll(objectClass).empty()) {
    d3.selectAll(objectClass).remove();
    d3.selectAll(".axisLabel").remove();
    d3.selectAll(".axis").remove();
    d3.select("#hintPath").remove();
    d3.select("#legend").remove();
  }
}
/**Checks if a mobile device is being used, called when the page loads
 * @return true if mobile, false otherwise
 * This code is from: http://stackoverflow.com/questions/3514784/what-is-the-best-way-to-detect-a-handheld-device-in-jquery
 * */
function checkDevice() {
  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    return true;
  }
  return false;
}
/**Changes some display properties of the hint path, such as increasing the stroke width and
 * making the colour lighter.  To make the hint path look nicer in it's non-blurred form
 * */
function drawMobileHintPath(objectRef) {
  objectRef.svg.select("#path").style("stroke-opacity", 0.5).style("stroke-width", 4);
  objectRef.svg.select("#underlayer").style("stroke-width", 5);
}
/**Resolves the user's coordinates depending on whether there is touch or mouse interaction
 * */
function getUserCoords(objectRef) {
  if (d3.touches(objectRef).length > 0) {
    return [d3.touches(objectRef)[0][0], d3.touches(objectRef)[0][1]];
  }
  return [d3.event.x, d3.event.y];
}
//////////////////////Updating important object variables//////////////////////

/** Updates the view variables to move the visualization forward
 * (passing the next view), also sets the direction travelling in time
 * draggingDirection: set to 1/-1 (physical dragging direction of user)
 *                    set to 0, if unknown
 * */
function moveForward(objectRef, draggingDirection) {

  if (objectRef.nextView < objectRef.lastView) { //Avoid index out of bounds
    objectRef.currentView = objectRef.nextView;
    objectRef.nextView++;
    //objectRef.timeDirection = 1;
  } else if (draggingDirection != 0) {
    if (draggingDirection != objectRef.previousDragDirection) { //Flip the direction when at the end of the hint path
      objectRef.timeDirection = (objectRef.timeDirection == 1) ? -1 : 1;
    }
  }
}
/**Finds the pixel distance from the user's point to the dragged data object's point
 * @return the pixel distance (calculated with the euclidean distance formula)
 * */
function findPixelDistance(userX, userY, objectX, objectY) {
  var term1 = userX - objectX;
  var term2 = userY - objectY;
  return Math.sqrt((term1 * term1) + (term2 * term2));
}
/** Updates the view tracking variables when the view is being changed by an external
 * visualization (e.g., slider)
 * */
function changeView(objectRef, newView) {
  if (newView == 0) {
    objectRef.currentView = newView
    objectRef.nextView = newView + 1;
  } else if (newView == objectRef.lastView) {
    objectRef.nextView = newView;
    objectRef.currentView = newView - 1;
  } else {
    objectRef.currentView = newView;
    objectRef.nextView = newView + 1;
  }
}
/**Adjusts the view variables in case they have gone out of bounds
 * @return the view to draw the visualization at */
function adjustView(objectRef) {
  if (objectRef.nextView > objectRef.lastView) {
    objectRef.nextView--;
    objectRef.currentView--;
    objectRef.interpValue = 0;
    return objectRef.nextView;
  } else if (objectRef.nextView == objectRef.lastView) {
    return objectRef.nextView;
  }
  return objectRef.currentView;
}
/** Updates the view variables to move the visualization backward
 * (passing the current view), also sets the direction travelling
 *  over time
 * draggingDirection: set to 1/-1 (physical dragging direction of user)
 *                    set to 0, if unknown
 * */
function moveBackward(objectRef, draggingDirection) {
  if (objectRef.currentView > 0) { //Avoid index out of bounds
    objectRef.nextView = objectRef.currentView;
    objectRef.currentView--;
    objectRef.interpValue = 0;
    //objectRef.timeDirection = -1;
  } else if (draggingDirection != 0) {
    if (draggingDirection != objectRef.previousDragDirection) { //Flip the direction when at the end of the hint path
      objectRef.timeDirection = (objectRef.timeDirection == 1) ? -1 : 1;
    }
  }
}
/** Checks if the mouse is in bounds defined by a and b, updates the interpolation amount
 *  mouse: the mouse position
 *  @return start,end: boundary values are returned if the given
 *                     mouse position is equal to or has crossed it
 *          mouse: The mouse value, if in bounds
 * */
function checkBounds(objectRef, a, b, mouse) {
  //Resolve the boundaries for comparison, start is lower value, end is higher
  var start, end;
  if (a > b) {
    end = a;
    start = b;
  } else {
    start = a;
    end = b;
  }

  //Check if the mouse is between start and end values
  if (mouse <= start) {
    return start;
  } else if (mouse >= end) {
    return end;
  }
  return mouse;
}
/** Calculates the interpolation amount  (percentage travelled) of the mouse, between views.
 *   Uses the interpolation amount to find the direction travelling over time and saves it
 *   in the global variable (interpValue). Also, updates the direction travelling over time (
 *   if there is a change in dragging direction)
 *
 *   a,b: position of boundary values (mouse is currently in between)
 *   mouse: position of the mouse
 *   draggingDirection: physical dragging direction of the user
 *   ambiguity: a flag, = 1, ambiguous case
 *                      = 0, normal case
 */
function findInterpolation(objectRef, a, b, mouse, ambiguity, draggingDirection) {
  var distanceTravelled, currentInterpValue;
  var total = Math.abs(b - a);
  //Calculate the new interpolation amount
  if (ambiguity == 0) {
    distanceTravelled = Math.abs(mouse - a);
    currentInterpValue = distanceTravelled / total;
  } else {
    if (objectRef.passedMiddle == 0) { //Needs to be re-mapped to lie between [0,0.5] (towards the peak/trough)
      distanceTravelled = Math.abs(mouse - a);
      currentInterpValue = distanceTravelled / (total * 2);
    } else { //Needs to be re-mapped to lie between [0.5,1] (passed the peak/trough)
      distanceTravelled = Math.abs(mouse - b);
      currentInterpValue = (distanceTravelled + total) / (total * 2);
    }
  }
  //Set the direction travelling over time (1: forward, -1: backward)
  if (draggingDirection != objectRef.previousDragDirection) {
    objectRef.timeDirection = (objectRef.timeDirection == -1) ? 1 : -1;
  }
  //objectRef.timeDirection = (currentInterpValue > objectRef.interpValue)? 1 : (currentInterpValue < objectRef.interpValue)?-1 : objectRef.timeDirection;

  //Save the current interpolation value
  objectRef.interpValue = currentInterpValue;
}
/**Infers the time direction when user arrives at areas on the hint path where interaction is ambiguous (e.g., peaks)
 * Inference is based on previous direction travelling over time.  The views are updated (forward or backward)
 * whenever the dragging direction changes.
 * draggingDirection: physical dragging direction of the user
 * atCurrent: the view which user is currently at or passing (=0 if at next view, =1 if at current)
 * */
function inferTimeDirection(objectRef, draggingDirection, atCurrent) {

  if (objectRef.previousDragDirection != draggingDirection) {
    if (atCurrent == 0 && objectRef.timeDirection == 1) {
      moveForward(objectRef, draggingDirection);
    } else if (atCurrent == 1 && objectRef.timeDirection == -1) {
      moveBackward(objectRef, draggingDirection);
    }
  }
}

/**Updates variables for dragging along the sine wave:
 *  pathDirection: vertical direction of the approaching portion of the sine wave (e.g., at next view)
 *  value: of the stationary object
 *  passedMiddle: a flag to determine how to calculate the interpolation (0: interp is between 0 and <0.5,
 *  1: interp is between 0.5 and < 1)
 * */
function setSineWaveVariables(objectRef, pathDirection, value, passedMiddle) {
  objectRef.passedMiddle = passedMiddle;
  objectRef.pathDirection = pathDirection;
  objectRef.peakValue = (pathDirection == 1) ? (value - objectRef.amplitude) : (objectRef.amplitude + value);
}
//////////////////////Indicators along the hint path//////////////////////

/** Appends a progress indicator to the svg (with id "progress"), if there isn't already one
 *  data: 2d array of points for drawing the entire hint path line
 * */
function appendProgress(objectRef, data) {

  if (objectRef.svg.select("#progress").empty()) {
    //Add the blur filter to the SVG so other elements can call it
    objectRef.svg.append("svg:defs").append("svg:filter")
      .attr("id", "blurProgress")
      .append("svg:feGaussianBlur")
      .attr("stdDeviation", 3);

    objectRef.svg.select("#hintPath").append("path").datum(data)
      .attr("id", "progress").attr("filter", "url(#blurProgress)");
  }
}


/** Re-draws a progress indicator using the stroke dash interpolation example by mike bobstock:
 * http://bl.ocks.org/mbostock/5649592
 * interpAmount: how far travelled between views
 * translateAmount: to animate the progress path with the hint path
 * type: of progress path (small segments or entire path)
 * */
function drawProgress(objectRef, interpAmount, translateAmount, type) {
  var myRef = objectRef;

  if (!objectRef.svg.select("#progress").empty()) {

    //Create the interpolation function and get the total length of the path
    var length = d3.select("#progress").node().getTotalLength();
    var interpStr = d3.interpolateString("0," + length, length + "," + length);
    //Make some adjustments according to the type of progress path selected
    if (type == 0 && interpAmount == 0) { //Small progress paths, at the point of transitioning views
      this.svg.select("#progress").attr("d", function (d) { return myRef.hintPathGenerator([d[myRef.currentView], d[myRef.nextView]]) });
    } else if (type == 1) { //Large progress path, adjust the interpolation
      interpAmount = (objectRef.currentView - 1) / objectRef.lastView + interpAmount / objectRef.lastView;
    }

    //Re-colour the progress path
    this.svg.select("#progress").attr("stroke-dasharray", interpStr(interpAmount))
      .attr("transform", "translate(" + (-translateAmount) + ")");
  }
}
/** Sets the type of hint path to be drawn
 *  Type: Full hint path = 0, partial hint path (removed labels) = 1
 * */
function setHintPathType(objectRef, type) {
  objectRef.hintPathType = type;
}

//////////////////////Indicators along a sine wave (interaction path)//////////////////////

/** Appends an anchor to the svg (with id 'anchor), if there isn't already one
 *  x,y: starting position of the anchor
 *  type: of anchor 0 - inner elastic, 1 - outer elastic, 2 - circle, 3 - circle and elastic
 * */
function appendAnchor(objectRef, x, y, type) {
  var myRef = objectRef;
  if (objectRef.svg.select("#anchor").empty()) {
    if (type == 0 || type == 1) { //Inner or outer elastic
      objectRef.svg.select("#hintPath").append("path").datum([[x, y]]).style("stroke", "none")
        .attr("d", myRef.hintPathGenerator).attr("id", "anchor");
    } else if (type == 2) { //Circle
      objectRef.svg.select("#hintPath").append("circle").attr("cx", x).attr("cy", y).attr("r", 4).style("stroke", "none").attr("id", "anchor");
    } else if (type == 3) { //Circle + elastic
      objectRef.svg.select("#hintPath").append("g").attr("id", "anchor");
      objectRef.svg.select("#anchor").append("circle").attr("cx", x).attr("cy", y).attr("r", 4).style("stroke", "none");
      objectRef.svg.select("#anchor").append("path").datum([[x, y]]).style("stroke", "none")
        .attr("d", objectRef.hintPathGenerator);
    }
  }
}

/** Re-draws the anchor, depends on the type of anchor (see function above for the scheme)
 * objY = y-value of the data object
 * mouseX, mouseY: mouse coordinates during dragging
 * newY = newY lies along the sine wave somewhere
 * */
function redrawAnchor(objectRef, objY, mouseX, mouseY, newY, type) {
  var myRef = objectRef;
  if (type == 0) { //Outer elastic
    objectRef.svg.select("#anchor").attr("d", function (d) { return myRef.hintPathGenerator([[mouseX, mouseY], [d[0][0], newY]]); })
      .style("stroke", "#c7c7c7");
  } else if (type == 1) { //Inner Elastic
    objectRef.svg.select("#anchor").attr("d", function (d) { return myRef.hintPathGenerator([[d[0][0], objY], [d[0][0], newY]]); })
      .style("stroke", "#c7c7c7");
  } else if (type == 2) { //Circle
    objectRef.svg.select("#anchor").attr("cy", newY).style("stroke", "#c7c7c7");
  } else if (type == 3) { //Circle and elastic
    objectRef.svg.select("#anchor").select("path").attr("d", function (d) { return myRef.hintPathGenerator([[d[0][0], objY], [d[0][0], newY]]); })
      .style("stroke", "#c7c7c7");
    objectRef.svg.select("#anchor").select("circle").attr("cy", newY).style("stroke", "#c7c7c7");
  }
}

/**Hides an anchor by removing it's colour
 * */
function hideAnchor(objectRef, type) {
  if (type == 0 || type == 1 || type == 2) {
    objectRef.svg.select("#anchor").style("stroke", "none");
  } else if (type == 3) {
    objectRef.svg.select("#anchor").select("circle").style("stroke", "none");
    objectRef.svg.select("#anchor").select("path").style("stroke", "none");
  }
}
/** Removes an anchor from the svg
 * */
function removeAnchor(objectRef) {
  if (!objectRef.svg.select("#anchor").empty()) {
    objectRef.svg.select("#anchor").remove();
  }
}
/**Draws a colour scale showing what is assigned to each colour
 * colours: the different colours to map the values to
 * labels: the labels to identify each colour
 * x,y: left and top margins of the scale
 * w,h: of the colour blocks in the legend
 * spacing: between the colour blocks (optional, but must be 1 if none is desired)
 * */
function drawColourLegend(objectRef, colours, labels, x, y, w, h, spacing) {

  //Prepare the data for drawing the scale
  objectRef.svg.selectAll(".legend").data(colours.map(function (d, i) {
    var yCoord = i * h * spacing + y;
    return { colour: d, id: i, label: labels[i], y: yCoord };
  })).enter().append("g").attr("class", "legend");

  //Draw the colours as rectangles
  objectRef.svg.selectAll(".legend").append("rect")
    .attr("x", x).attr("y", function (d) { return d.y })
    .attr("width", w).attr("height", h)
    .style("fill", function (d) { return d.colour });

  //Draw the labels for each colour
  objectRef.svg.selectAll(".legend").append("text").attr("x", x + w + 5)
    .attr("y", function (d) { return (d.y + h / 2 * spacing) })
    .style("fill", "#666")
    .text(function (d) { return d.label })
}
/** Search for ambiguous cases in a list of values along the hint path.  Ambiguous objects are tagged as 1, this is stored in
 *  ambiguousObjs
 *
 *  To alleviate interaction in regions where the heights are very similar (within valueThreshold), we also consider
 *  these objects to be stationary in value.
 * */
function checkAmbiguous(objectRef, values, valueThreshold) {
  var j, currentObj;
  var ambiguousObjs = [];
  var length = values.length;
  objectRef.isAmbiguous = 0;

  for (j = 0; j <= length; j++) {
    ambiguousObjs[j] = [0];
  }

  //Search for values that match
  for (j = 0; j < length; j++) {
    currentObj = values[j];
    for (var k = 0; k < length; k++) {
      if (j != k && Math.abs(values[k] - currentObj) <= valueThreshold) { //A repeated (or almost repeated) value is found
        if (Math.abs(k - j) == 1) { //Stationary value
          objectRef.isAmbiguous = 1;
          ambiguousObjs[j] = [1];
        }

      }
    }
  }
  if (objectRef.isAmbiguous == 1) {
    //Generate points for drawing an interaction path
    return findInteractionPaths(ambiguousObjs, values, valueThreshold);
  }
  return [ambiguousObjs, []];
}
/** Creates an array containing all data for drawing a sine wave:
 * interactionPaths[] = [[points for the sine wave]..number of paths]
 * */
function findInteractionPaths(ambiguousObjs, values, valueThreshold) {
  var indices = [];
  var pathNumber = 0;
  var firstPath = false;
  var length = values.length;
  var interactionPaths = [];

  for (var j = 0; j < length; j++) {
    if (ambiguousObjs[j][0] == 1) {
      if (j != 0 && (ambiguousObjs[j - 1][0] != 1 ||
        (ambiguousObjs[j - 1][0] == 1 && Math.abs(values[j] - values[j - 1]) > valueThreshold))) { //Starting a new path
        if (!firstPath) {
          firstPath = true;
        } else {
          interactionPaths.push(indices);
          indices = [];
          pathNumber++;
        }
      }
      ambiguousObjs[j].push(pathNumber);
      indices.push(j);
    }
  }
  interactionPaths.push(indices);

  return [ambiguousObjs, interactionPaths];
}
/**Highlights data object(s) with the specified id in the highlightColour from the class of data objects
 * Used for completing the tasks in the user evaluation
 * id2 and newColour2 are optional, if N/A then set it as -1
 * */
function highlightDataObject(id1, id2, className, origColour, newColour1, newColour2) {
  d3.selectAll(className).style("fill", function (d) {
    return (d.id == id1) ? newColour1 : (d.id == id2) ? newColour2 : origColour;
  });
}
/**Function which shows info (year labels, middle ticks) on the slider widget */
function showSliderInfo(sliderRef) {
  sliderRef.widget.selectAll(".tickLabels").style("fill", sliderRef.displayColour);
}
/**Function which hides info (year labels, middle ticks) on the slider widget.
 * This is used during the user evaluation to remove information about time */
function hideSliderInfo(sliderRef) {
  //Hide the tick labels
  sliderRef.widget.selectAll(".tickLabels").style("fill", "none");
  //Hide all ticks except the end ones
  /** sliderRef.widget.selectAll(".ticks")
       .style("fill",function(d,i){return ((i==0)||(i==sliderRef.numTicks-1))?sliderRef.displayColour:"none"});*/

}

#####d3/dust_magnet.js:#####


#####d3/edge_bundling.js:#####
const colornone = "#ccc";
const colorout = "#f00";
const colorin = "#00f";

function id(node) {
  return `${node.parent ? id(node.parent) + "." : ""}${node.data.name}`;
}

function bilink(root) {
  const map = new Map(root.leaves().map(d => [id(d), d]));
  for (const d of root.leaves()) d.incoming = [], d.outgoing = d.data.imports.map(i => [d, map.get(i)]);
  for (const d of root.leaves()) for (const o of d.outgoing) o[1].incoming.push(o);
  return root;
}

function hierarchy(data, delimiter = ".") {
  let root;
  const map = new Map;
  data.forEach(function find(data) {
    const { name } = data;
    if (map.has(name)) return map.get(name);
    const i = name.lastIndexOf(delimiter);
    map.set(name, data);
    if (i >= 0) {
      find({ name: name.substring(0, i), children: [] }).children.push(data);
      data.name = name.substring(i + 1);
    } else {
      root = data;
    }
    return data;
  });
  return root;
}

d3.json("flare.json").then(data => {

  const width = 954;
  const radius = width / 2;

  const tree = d3.cluster()
    .size([2 * Math.PI, radius - 100]);
  const root = tree(bilink(d3.hierarchy(data)
    .sort((a, b) => d3.ascending(a.height, b.height) || d3.ascending(a.data.name, b.data.name))));

  const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", width)
    .attr("viewBox", [-width / 2, -width / 2, width, width])
    .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif;");

  const node = svg.append("g")
    .selectAll()
    .data(root.leaves())
    .join("g")
    .attr("transform", d => `rotate(${d.x * 180 / Math.PI - 90}) translate(${d.y},0)`)
    .append("text")
    .attr("dy", "0.31em")
    .attr("x", d => d.x < Math.PI ? 6 : -6)
    .attr("text-anchor", d => d.x < Math.PI ? "start" : "end")
    .attr("transform", d => d.x >= Math.PI ? "rotate(180)" : null)
    .text(d => d.data.name)
    .each(function (d) { d.text = this; })
    .on("mouseover", overed)
    .on("mouseout", outed)
    .call(text => text.append("title").text(d => `${id(d)}
${d.outgoing.length} outgoing
${d.incoming.length} incoming`));

  const line = d3.lineRadial()
    .curve(d3.curveBundle.beta(0.85))
    .radius(d => d.y)
    .angle(d => d.x);

  const link = svg.append("g")
    .attr("stroke", colornone)
    .attr("fill", "none")
    .selectAll()
    .data(root.leaves().flatMap(leaf => leaf.outgoing))
    .join("path")
    .style("mix-blend-mode", "multiply")
    .attr("d", ([i, o]) => line(i.path(o)))
    .each(function (d) { d.path = this; });

  function overed(event, d) {
    link.style("mix-blend-mode", null);
    d3.select(this).attr("font-weight", "bold");
    d3.selectAll(d.incoming.map(d => d.path)).attr("stroke", colorin).raise();
    d3.selectAll(d.incoming.map(([d]) => d.text)).attr("fill", colorin).attr("font-weight", "bold");
    d3.selectAll(d.outgoing.map(d => d.path)).attr("stroke", colorout).raise();
    d3.selectAll(d.outgoing.map(([, d]) => d.text)).attr("fill", colorout).attr("font-weight", "bold");
  }

  function outed(event, d) {
    link.style("mix-blend-mode", "multiply");
    d3.select(this).attr("font-weight", null);
    d3.selectAll(d.incoming.map(d => d.path)).attr("stroke", null);
    d3.selectAll(d.incoming.map(([d]) => d.text)).attr("fill", null).attr("font-weight", null);
    d3.selectAll(d.outgoing.map(d => d.path)).attr("stroke", null);
    d3.selectAll(d.outgoing.map(([, d]) => d.text)).attr("fill", null).attr("font-weight", null);
  }
});

#####d3/force_directed_layout.js:#####
d3.json('miserables.json').then(data => {
  // Specify the dimensions of the chart.
  const width = 928;
  const height = 600;

  // Specify the color scale.
  const color = d3.scaleOrdinal(d3.schemeCategory10);

  // The force simulation mutates links and nodes, so create a copy
  // so that re-evaluating this cell produces the same result.
  const links = data.links.map(d => ({ ...d }));
  const nodes = data.nodes.map(d => ({ ...d }));

  // Create a simulation with several forces.
  const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id))
    .force("charge", d3.forceManyBody())
    .force("center", d3.forceCenter(width / 2, height / 2))
    .on("tick", ticked);

  // Create the SVG container.
  const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", [0, 0, width, height])
    .attr("style", "max-width: 100%; height: auto;");

  // Add a line for each link, and a circle for each node.
  const link = svg.append("g")
    .attr("stroke", "#999")
    .attr("stroke-opacity", 0.6)
    .selectAll()
    .data(links)
    .join("line")
    .attr("stroke-width", d => Math.sqrt(d.value));

  const node = svg.append("g")
    .attr("stroke", "#fff")
    .attr("stroke-width", 1.5)
    .selectAll()
    .data(nodes)
    .join("circle")
    .attr("r", 5)
    .attr("fill", d => color(d.group));

  node.append("title")
    .text(d => d.id);

  // Add a drag behavior.
  node.call(d3.drag()
    .on("start", dragstarted)
    .on("drag", dragged)
    .on("end", dragended));

  // Set the position attributes of links and nodes each time the simulation ticks.
  function ticked() {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    node
      .attr("cx", d => d.x)
      .attr("cy", d => d.y);
  }

  // Reheat the simulation when drag starts, and fix the subject position.
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }

  // Update the subject (dragged node) position during drag.
  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }

  // Restore the target alpha so the simulation cools after dragging ends.
  // Unfix the subject position now that its no longer being dragged.
  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }

  // When this cell is re-run, stop the previous simulation. (This doesnt
  // really matter since the target alpha is zero and the simulation will
  // stop naturally, but its a good practice.)
  invalidation.then(() => simulation.stop());
})

#####d3/helper_line.js:#####
// Create a helper line function
function helperLine(selection) {
  const line = selection.selectAll("path.helper-line")
    .data([null])
    .join("path")
    .attr("class", "helper-line");

  function updateLine(event) {
    const [xm, ym] = d3.pointer(event);
    line.attr("d", `M${xm},${ym} L${xm},0 L0,${ym}`);
  }

  selection.on("mousemove", updateLine)
    .on("mouseleave", () => line.attr("d", null));

  updateLine({ target: selection.node() });
}

// Create a simple chart with a helper line
const width = 600;
const height = 400;

const svg = d3.select("#chart")
  .append("svg")
  .attr("width", width)
  .attr("height", height);

const chartArea = svg.append("g")
  .attr("transform", `translate(50, 50)`);

chartArea.append("rect")
  .attr("width", width - 100)
  .attr("height", height - 100)
  .attr("fill", "none")
  .attr("stroke", "black");

// Call the helper line function on the chart area
chartArea.call(helperLine);

#####d3/index_chart.js:#####
stocks = (Promise.all([
  FileAttachment("AAPL.csv").csv({ typed: true }).then((values) => ["AAPL", values]),
  FileAttachment("AMZN.csv").csv({ typed: true }).then((values) => ["AMZN", values]),
  FileAttachment("GOOG.csv").csv({ typed: true }).then((values) => ["GOOG", values]),
  FileAttachment("IBM.csv").csv({ typed: true }).then((values) => ["IBM", values]),
  FileAttachment("MSFT.csv").csv({ typed: true }).then((values) => ["MSFT", values]),
])).flatMap(([Symbol, values]) => values.map(d => ({ Symbol, ...d })))

// Specify the charts dimensions.
const width = 928;
const height = 600;
const marginTop = 20;
const marginRight = 40;
const marginBottom = 30;
const marginLeft = 40;

// Create the horizontal time scale.
const x = d3.scaleUtc()
  .domain(d3.extent(stocks, d => d.Date))
  .range([marginLeft, width - marginRight])
  .clamp(true)

// Normalize the series with respect to the value on the first date. Note that normalizing
// the whole series with respect to a different date amounts to a simple vertical translation,
// thanks to the logarithmic scale! See also https://observablehq.com/@d3/change-line-chart
const series = d3.groups(stocks, d => d.Symbol).map(([key, values]) => {
  const v = values[0].Close;
  return { key, values: values.map(({ Date, Close }) => ({ Date, value: Close / v })) };
});

// Create the vertical scale. For each series, compute the ratio *s* between its maximum and
// minimum values; the path is going to move between [1 / s, 1] when the reference date
// corresponds to its maximum and [1, s] when it corresponds to its minimum. To have enough
// room, the scale is based on the series that has the maximum ratio *k*  (in this case, AMZN).
const k = d3.max(series, ({ values }) => d3.max(values, d => d.value) / d3.min(values, d => d.value));
const y = d3.scaleLog()
  .domain([1 / k, k])
  .rangeRound([height - marginBottom, marginTop])

// Create a color scale to identify series.
const z = d3.scaleOrdinal(d3.schemeCategory10).domain(series.map(d => d.Symbol));

// For each given series, the update function needs to identify the dateclosest to the current
// datethat actually contains a value. To do this efficiently, it uses a bisector:
const bisect = d3.bisector(d => d.Date).left;

// Create the SVG container.
const svg = d3.create("svg")
  .attr("width", width)
  .attr("height", height)
  .attr("viewBox", [0, 0, width, height])
  .attr("style", "max-width: 100%; height: auto; -webkit-tap-highlight-color: transparent;");

// Create the axes and central rule.
svg.append("g")
  .attr("transform", `translate(0,${height - marginBottom})`)
  .call(d3.axisBottom(x).ticks(width / 80).tickSizeOuter(0))
  .call(g => g.select(".domain").remove());

svg.append("g")
  .attr("transform", `translate(${marginLeft},0)`)
  .call(d3.axisLeft(y)
    .ticks(null, x => +x.toFixed(6) + ""))
  .call(g => g.selectAll(".tick line").clone()
    .attr("stroke-opacity", d => d === 1 ? null : 0.2)
    .attr("x2", width - marginLeft - marginRight))
  .call(g => g.select(".domain").remove());

const rule = svg.append("g")
  .append("line")
  .attr("y1", height)
  .attr("y2", 0)
  .attr("stroke", "black");

// Create a line and a label for each series.
const serie = svg.append("g")
  .style("font", "bold 10px sans-serif")
  .selectAll("g")
  .data(series)
  .join("g");

const line = d3.line()
  .x(d => x(d.Date))
  .y(d => y(d.value));

serie.append("path")
  .attr("fill", "none")
  .attr("stroke-width", 1.5)
  .attr("stroke-linejoin", "round")
  .attr("stroke-linecap", "round")
  .attr("stroke", d => z(d.key))
  .attr("d", d => line(d.values));

serie.append("text")
  .datum(d => ({ key: d.key, value: d.values[d.values.length - 1].value }))
  .attr("fill", d => z(d.key))
  .attr("paint-order", "stroke")
  .attr("stroke", "white")
  .attr("stroke-width", 3)
  .attr("x", x.range()[1] + 3)
  .attr("y", d => y(d.value))
  .attr("dy", "0.35em")
  .text(d => d.key);

// Define the update function, that translates each of the series vertically depending on the
// ratio between its value at the current date and the value at date 0. Thanks to the log
// scale, this gives the same result as a normalization by the value at the current date.
function update(date) {
  date = d3.utcDay.round(date);
  rule.attr("transform", `translate(${x(date) + 0.5},0)`);
  serie.attr("transform", ({ values }) => {
    const i = bisect(values, date, 0, values.length - 1);
    return `translate(0,${y(1) - y(values[i].value / values[0].value)})`;
  });
  svg.property("value", date).dispatch("input"); // for viewof compatibility
}

// Create the introductory animation. It repeatedly calls the update function for dates ranging
// from the last to the first date of the x scale.
d3.transition()
  .ease(d3.easeCubicOut)
  .duration(1500)
  .tween("date", () => {
    const i = d3.interpolateDate(x.domain()[1], x.domain()[0]);
    return t => update(i(t));
  });

// When the user mouses over the chart, update it according to the date that is
// referenced by the horizontal position of the pointer.
svg.on("mousemove touchmove", function (event) {
  update(x.invert(d3.pointer(event, this)[0]));
  d3.event.preventDefault();
});

// Sets the date to the start of the x axis. This is redundant with the transition above;
// uncomment if you want to remove the transition.
// update(x.domain()[0]);


#####d3/map_brush.js:#####
// Load the county data and create the map
Promise.all([
  d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/counties-albers-10m.json"),
  d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-albers-10m.json")
]).then(([counties, states]) => {
  const width = 960;
  const height = 600;

  const svg = d3.select("#map")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  const path = d3.geoPath();

  const map = svg.append("g")
    .attr("cursor", "grab");

  map.append("g")
    .selectAll("path")
    .data(topojson.feature(states, states.objects.states).features)
    .join("path")
    .attr("fill", "none")
    .attr("stroke", "white")
    .attr("d", path);

  const county = map.append("g")
    .selectAll("path")
    .data(topojson.feature(counties, counties.objects.counties).features)
    .join("path")
    .attr("class", "county")
    .attr("d", path);

  const brush = d3.brush()
    .extent([[0, 0], [width, height]])
    .on("brush", brushed);

  map.call(brush);

  function brushed(event) {
    const extent = event.selection;
    county.classed("selected", feature => extent && path.bounds(feature).some(bound => extent[0][0] <= bound[0] && bound[0] <= extent[1][0] && extent[0][1] <= bound[1] && bound[1] <= extent[1][1]));
  }
});

#####d3/map_click.js:#####
// Load the county data and create the map
Promise.all([
  d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/counties-albers-10m.json"),
  d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-albers-10m.json")
]).then(([counties, states]) => {
  const width = 960;
  const height = 600;

  const svg = d3.select("#map")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  const path = d3.geoPath();

  const map = svg.append("g");

  map.append("g")
    .selectAll("path")
    .data(topojson.feature(states, states.objects.states).features)
    .join("path")
    .attr("fill", "none")
    .attr("stroke", "white")
    .attr("d", path);

  const county = map.append("g")
    .selectAll("path")
    .data(topojson.feature(counties, counties.objects.counties).features)
    .join("path")
    .attr("class", "county")
    .attr("d", path)
    .on("click", clicked);

  let selectedCounty = null;

  function clicked(event, d) {
    if (selectedCounty) selectedCounty.classed("selected", false);
    selectedCounty = d3.select(this).classed("selected", true);
  }
});

#####d3/map_hover.js:#####
// Load the county data and create the map
Promise.all([
  d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/counties-albers-10m.json"),
  d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-albers-10m.json")
]).then(([counties, states]) => {
  const width = 960;
  const height = 600;

  const svg = d3.select("#map")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  const path = d3.geoPath();

  const map = svg.append("g");

  map.append("g")
    .selectAll("path")
    .data(topojson.feature(states, states.objects.states).features)
    .join("path")
    .attr("fill", "none")
    .attr("stroke", "white")
    .attr("d", path);

  const county = map.append("g")
    .selectAll("path")
    .data(topojson.feature(counties, counties.objects.counties).features)
    .join("path")
    .attr("class", "county")
    .attr("d", path)
    .on("mouseover", showTooltip)
    .on("mouseout", hideTooltip);

  const tooltip = d3.select("#tooltip");

  function showTooltip(event, d) {
    d3.select(this).classed("hovered", true);
    tooltip
      .style("left", `${event.pageX + 10}px`)
      .style("top", `${event.pageY + 10}px`)
      .html(`<b>${d.properties.NAME}, ${d.properties.STATE_NAME}</b>`);
  }

  function hideTooltip() {
    d3.selectAll(".county").classed("hovered", false);
    tooltip.html("");
  }
});

#####d3/map_panzoom.js:#####
// Load the county data and create the map
Promise.all([
  d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/counties-albers-10m.json"),
  d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-albers-10m.json")
]).then(([counties, states]) => {
  const width = 960;
  const height = 600;

  const svg = d3.select("#map")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  const path = d3.geoPath();

  const map = svg.append("g");

  map.append("g")
    .selectAll("path")
    .data(topojson.feature(states, states.objects.states).features)
    .join("path")
    .attr("fill", "none")
    .attr("stroke", "white")
    .attr("d", path);

  const county = map.append("g")
    .selectAll("path")
    .data(topojson.feature(counties, counties.objects.counties).features)
    .join("path")
    .attr("class", "county")
    .attr("d", path);

  // Set up pan and zoom behavior
  const zoom = d3.zoom()
    .scaleExtent([1, 8])
    .on("zoom", zoomed);

  svg.call(zoom);

  function zoomed(event) {
    map.attr("transform", event.transform);
  }
});

#####d3/scatter_brush.js:#####
d3.json("./data/test100.json").then(function (data) {
    // Define margin, width, and height
    const margin = { top: 20, right: 20, bottom: 30, left: 40 };
    const width = 260 - margin.left - margin.right;
    const height = 250 - margin.top - margin.bottom;

    // Create scales for x and y axes
    const x = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.x)])
        .range([0, width]);

    const y = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.y)])
        .range([height, 0]);

    // Create SVG element
    const svg = d3
        .select("#LibraPlayground")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Add x-axis
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x));

    // Add y-axis
    svg.append("g")
        .attr("class", "y axis")
        .call(d3.axisLeft(y));

    // Add dots for each data point
    const dots = svg.selectAll(".dot")
        .data(data)
        .enter().append("circle")
        .attr("class", "dot")
        .attr("cx", d => x(d.x))
        .attr("cy", d => y(d.y))
        .attr("r", 5)
        .attr("fill", "steelblue")
        .attr("opacity", 0.7);;

    // Add brush
    const brush = d3.brush()
        .extent([[0, 0], [width, height]])
        .on("start brush end", brushed);

    svg.append("g")
        .attr("class", "brush")
        .call(brush);

    let selectedPoints = [];

    function brushed(event) {
        const selection = event.selection;
        selectedPoints = [];

        if (selection) {
            dots.classed("selected", function (d) {
                const isSelected = selection[0][0] <= x(d.x) && x(d.x) <= selection[1][0] &&
                    selection[0][1] <= y(d.y) && y(d.y) <= selection[1][1];
                if (isSelected) {
                    d3.select(this)
                        .attr("fill", "red")
                        .attr("opacity", 1);
                } else {
                    d3.select(this).attr("fill", "steelblue")
                        .attr("opacity", 0.7);
                }
                return isSelected;
            });
        } else {
            dots.attr("fill", "steelblue")
                .attr("opacity", 0.7);
        }

        // Output selected points to console
        // console.log("Selected points:", selectedPoints);
    }
}).catch(function (error) {
    console.log(error);
});

#####d3/scatter_click.js:#####
// Load the data
d3.json("https://cdn.jsdelivr.net/npm/vega-datasets@2/data/movies.json").then(function(data) {
  // Define dimensions and margins
  const width = 600;
  const height = 500;
  const margin = { top: 20, right: 20, bottom: 30, left: 40 };

  // Create scales
  const x = d3.scaleLinear().range([margin.left, width - margin.right]);
  const y = d3.scaleLinear().range([height - margin.bottom, margin.top]);

  // Create SVG and main group
  const svg = d3.select("#chart")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  const g = svg.append("g");

  // Define domain ranges
  x.domain(d3.extent(data, d => d.Rotten_Tomatoes_Rating));
  y.domain(d3.extent(data, d => d.IMDB_Rating));

  // Add x-axis
  g.append("g")
    .attr("transform", `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(x).ticks(10));

  // Add y-axis
  g.append("g")
    .attr("transform", `translate(${margin.left},0)`)
    .call(d3.axisLeft(y).ticks(10));

  // Add dots
  const dots = g.selectAll(".dot")
    .data(data)
    .enter().append("circle")
    .attr("class", "dot")
    .attr("r", 5)
    .attr("cx", d => x(d.Rotten_Tomatoes_Rating))
    .attr("cy", d => y(d.IMDB_Rating))
    .on("click", clicked);

  let selectedDot = null;

  function clicked(event, d) {
    if (selectedDot) selectedDot.classed("selected", false);
    selectedDot = d3.select(this).classed("selected", true);
  }
});

#####d3/scatter_excentric_labeling.js:#####


#####d3/scatter_hover.js:#####
d3.json("./data/test100.json").then(function (data) {
    // Define margin, width, and height
    const margin = { top: 20, right: 20, bottom: 30, left: 40 };
    const width = 260 - margin.left - margin.right;
    const height = 250 - margin.top - margin.bottom;

    // Create scales for x and y axes
    const x = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.x)])
        .range([0, width]);

    const y = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.y)])
        .range([height, 0]);

    // Create SVG element
    const svg = d3
        .select("#LibraPlayground")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Add x-axis
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x));

    // Add y-axis
    svg.append("g")
        .attr("class", "y axis")
        .call(d3.axisLeft(y));

    // Add dots for each data point
    const dots = svg.selectAll(".dot")
        .data(data)
        .enter().append("circle")
        .attr("class", "dot")
        .attr("cx", d => x(d.x))
        .attr("cy", d => y(d.y))
        .attr("r", 5)
        .attr("fill", "steelblue")
        .attr("opacity", 0.7);

    // Add labels
    svg.append("text")
        .attr("class", "label")
        .attr("x", width / 2)
        .attr("y", height + margin.bottom)
        .style("text-anchor", "middle")
        .text("x");

    svg.append("text")
        .attr("class", "label")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 - margin.left)
        .attr("x", 0 - (height / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text("Miles per Gallon");

    // Add hover functionality
    dots.on("mouseover", function (event, d) {
        d3.select(this)
            .attr("fill", "red")
            .attr("opacity", 1);
    })
        .on("mouseout", function (event, d) {
            d3.select(this)
                .attr("fill", "steelblue")
                .attr("opacity", 0.7);
        });
}).catch(function (error) {
    console.log(error);
});

#####d3/scatter_panzoom.js:#####
d3.json("./data/test100.json").then(function (data) {

  const margin = { top: 20, right: 20, bottom: 30, left: 40 };
  const width = 260 - margin.left - margin.right;
  const height = 250 - margin.top - margin.bottom;


  // Create SVG element
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  // .append("g")
  // .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
  // Create scales
  const xScale = d3.scaleLinear()
    .domain([0, d3.max(data, d => d.x)])
    .range([0, width]);

  const yScale = d3.scaleLinear()
    .domain([0, d3.max(data, d => d.y)])
    .range([height, 0]);

  // Add x-axis
  svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(xScale));

  // Add y-axis
  svg.append("g")
    .attr("class", "y axis")
    .call(d3.axisLeft(yScale));
  // Create circles for the scatter plot
  svg.selectAll("circle")
    .data(data)
    .enter()
    .append("circle")
    .attr("cx", d => xScale(d.x))
    .attr("cy", d => yScale(d.y))
    .attr("r", 5)
    .attr("fill", "steelblue");

  // Create zoom behavior
  const zoom = d3.zoom()
    .scaleExtent([0.1, 10])
    .on("zoom", (event) => {
      const { transform } = event;
      svg.selectAll("circle")
        .attr("transform", transform);
    });

  // Apply zoom behavior to the SVG container
  svg.call(zoom);
});

#####d3/scatter_semantic_panzoom.js:#####
// Load the data
d3.json("https://cdn.jsdelivr.net/npm/vega-datasets@2/data/movies.json").then(function(data) {
  // Define dimensions and margins
  const width = 600;
  const height = 500;
  const margin = { top: 20, right: 20, bottom: 30, left: 40 };

  // Create scales
  const x = d3.scaleLinear().range([margin.left, width - margin.right]);
  const y = d3.scaleLinear().range([height - margin.bottom, margin.top]);

  // Create SVG and main group
  const svg = d3.select("#chart")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  const g = svg.append("g");

  // Define domain ranges
  const xExtent = d3.extent(data, d => d.Rotten_Tomatoes_Rating);
  const yExtent = d3.extent(data, d => d.IMDB_Rating);
  x.domain(xExtent);
  y.domain(yExtent);

  // Add x-axis
  g.append("g")
    .attr("transform", `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(x).ticks(10));

  // Add y-axis
  g.append("g")
    .attr("transform", `translate(${margin.left},0)`)
    .call(d3.axisLeft(y).ticks(10));

  // Add dots
  const dots = g.selectAll(".dot")
    .data(data)
    .enter().append("circle")
    .attr("class", "dot")
    .attr("r", 5)
    .attr("cx", d => x(d.Rotten_Tomatoes_Rating))
    .attr("cy", d => y(d.IMDB_Rating));

  // Set up pan and zoom behavior
  const zoom = d3.zoom()
    .on("zoom", zoomed);

  svg.call(zoom);

  function zoomed(event) {
    const transform = event.transform;
    const xScale = transform.rescaleX(x);
    const yScale = transform.rescaleY(y);

    g.selectAll(".dot")
      .attr("cx", d => xScale(d.Rotten_Tomatoes_Rating))
      .attr("cy", d => yScale(d.IMDB_Rating));

    g.select(".x.axis")
      .call(d3.axisBottom(xScale).ticks(10));

    g.select(".y.axis")
      .call(d3.axisLeft(yScale).ticks(10));
  }
});

#####d3/splom_brush.js:#####
d3.csv("./data/md100.csv").then(function (data) {
    console.log(data);
    function brush(cell, circle, svg, { padding, size, x, y, columns }) {
        const brush = d3.brush()
            .extent([[padding / 2, padding / 2], [size - padding / 2, size - padding / 2]])
            .on("start", brushstarted)
            .on("brush", brushed)
            .on("end", brushended);

        cell.call(brush);

        let brushCell;

        // Clear the previously-active brush, if any.
        function brushstarted() {
            if (brushCell !== this) {
                d3.select(brushCell).call(brush.move, null);
                brushCell = this;
            }
        }

        // Highlight the selected circles.
        function brushed({ selection }, [i, j]) {
            let selected = [];
            if (selection) {
                const [[x0, y0], [x1, y1]] = selection;
                circle.classed("hidden",
                    d => x0 > x[i](d[columns[i]])
                        || x1 < x[i](d[columns[i]])
                        || y0 > y[j](d[columns[j]])
                        || y1 < y[j](d[columns[j]]));
                selected = data.filter(
                    d => x0 < x[i](d[columns[i]])
                        && x1 > x[i](d[columns[i]])
                        && y0 < y[j](d[columns[j]])
                        && y1 > y[j](d[columns[j]]));
            }
            svg.property("value", selected).dispatch("input");
        }

        // If the brush is empty, select all circles.
        function brushended({ selection }) {
            if (selection) return;
            svg.property("value", []).dispatch("input");
            circle.classed("hidden", false);
        }
    }

    const chart = (() => {
        // Specify the charts dimensions.
        const width = 928;
        const height = width;
        const padding = 28;
        const columns = data.columns.filter(d => typeof data[0][d] === "number");
        const size = (width - (columns.length + 1) * padding) / columns.length + padding;

        // Define the horizontal scales (one for each row).
        const x = columns.map(c => d3.scaleLinear()
            .domain(d3.extent(data, d => d[c]))
            .rangeRound([padding / 2, size - padding / 2]))

        // Define the companion vertical scales (one for each column).
        const y = x.map(x => x.copy().range([size - padding / 2, padding / 2]));

        // Define the color scale.
        const color = d3.scaleOrdinal()
            .domain(data.map(d => d.species))
            .range(d3.schemeCategory10);

        // Define the horizontal axis (it will be applied separately for each column).
        const axisx = d3.axisBottom()
            .ticks(6)
            .tickSize(size * columns.length);
        const xAxis = g => g.selectAll("g").data(x).join("g")
            .attr("transform", (d, i) => `translate(${i * size},0)`)
            .each(function (d) { return d3.select(this).call(axisx.scale(d)); })
            .call(g => g.select(".domain").remove())
            .call(g => g.selectAll(".tick line").attr("stroke", "#ddd"));

        // Define the vertical axis (it will be applied separately for each row).
        const axisy = d3.axisLeft()
            .ticks(6)
            .tickSize(-size * columns.length);
        const yAxis = g => g.selectAll("g").data(y).join("g")
            .attr("transform", (d, i) => `translate(0,${i * size})`)
            .each(function (d) { return d3.select(this).call(axisy.scale(d)); })
            .call(g => g.select(".domain").remove())
            .call(g => g.selectAll(".tick line").attr("stroke", "#ddd"));

        const svg = d3.select('#LibraPlayground').append('svg')
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [-padding, 0, width, height]);

        svg.append("style")
            .text(`circle.hidden { fill: #000; fill-opacity: 1; r: 1px; }`);

        svg.append("g")
            .call(xAxis);

        svg.append("g")
            .call(yAxis);

        const cell = svg.append("g")
            .selectAll("g")
            .data(d3.cross(d3.range(columns.length), d3.range(columns.length)))
            .join("g")
            .attr("transform", ([i, j]) => `translate(${i * size},${j * size})`);

        cell.append("rect")
            .attr("fill", "none")
            .attr("stroke", "#aaa")
            .attr("x", padding / 2 + 0.5)
            .attr("y", padding / 2 + 0.5)
            .attr("width", size - padding)
            .attr("height", size - padding);

        cell.each(function ([i, j]) {
            d3.select(this).selectAll("circle")
                .data(data.filter(d => !isNaN(d[columns[i]]) && !isNaN(d[columns[j]])))
                .join("circle")
                .attr("cx", d => x[i](d[columns[i]]))
                .attr("cy", d => y[j](d[columns[j]]));
        });

        const circle = cell.selectAll("circle")
            .attr("r", 3.5)
            .attr("fill-opacity", 0.7)
            .attr("fill", d => color(d.species));

        // Ignore this line if you don't need the brushing behavior.
        cell.call(brush, circle, svg, { padding, size, x, y, columns });

        svg.append("g")
            .style("font", "bold 10px sans-serif")
            .style("pointer-events", "none")
            .selectAll("text")
            .data(columns)
            .join("text")
            .attr("transform", (d, i) => `translate(${i * size},${i * size})`)
            .attr("x", padding)
            .attr("y", padding)
            .attr("dy", ".71em")
            .text(d => d);

        svg.property("value", [])
        return Object.assign(svg.node(), { scales: { color } });
    })();
});

#####d3/timeseries_overviewdetail.js:#####
d3.csv("data/stocks/ts100.csv").then(function (data) {
    data = data.map(({ Date: d, Close }) => ({ date: new Date(d), value: +Close }))
    console.log(data);
    // Your D3 code here
    const width = 720;
    const height = 440;
    const focusHeight = 100;
    const margin = { top: 20, right: 20, bottom: 30, left: 40 };

    const x = d3.scaleUtc()
        .domain(d3.extent(data, d => d.date))
        .range([margin.left, width - margin.right])

    const y = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.value)])
        .range([height - margin.bottom, margin.top])

    const xAxis = (g, x, height) => g
        .attr("transform", `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(x).ticks(width / 80).tickSizeOuter(0))

    const yAxis = (g, y, title) => g
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(y))
        .call(g => g.select(".domain").remove())
        .call(g => g.selectAll(".title").data([title]).join("text")
            .attr("class", "title")
            .attr("x", -margin.left)
            .attr("y", 10)
            .attr("fill", "currentColor")
            .attr("text-anchor", "start")
            .text(title))

    const area = (x, y) => d3.area()
        .defined(d => !isNaN(d.value))
        .x(d => x(d.date))
        .y0(y(0))
        .y1(d => y(d.value));

    const chart = (() => {
        const svg = d3
            .select("#LibraPlayground")
            .append('svg')
            .attr('width', width)
            .attr("viewBox", [0, 0, width, height])
            .style("display", "block");

        const clipId = 'clipId';

        svg
            .append("clipPath")
            .attr("id", clipId)
            .append("rect")
            .attr("x", margin.left)
            .attr("y", 0)
            .attr("height", height)
            .attr("width", width - margin.left - margin.right);

        const gx = svg.append("g");

        const gy = svg.append("g");

        const path = svg
            .append("path")
            .datum(data)
            .attr("clip-path", 'url(#' + clipId + ')')
            .attr("fill", "steelblue");

        return Object.assign(svg.node(), {
            update(focusX, focusY) {
                gx.call(xAxis, focusX, height);
                gy.call(yAxis, focusY, data.y);
                path.attr("d", area(focusX, focusY));
            }
        })
    })();


    let [minX, maxX] = [x.domain()[0], x.domain()[1]];

    const focus = (() => {
        const svg = d3
            .select("#LibraPlayground")
            .append('svg')
            .attr('width', width)
            .attr("viewBox", [0, 0, width, focusHeight])
            .style("display", "block");

        const brush = d3
            .brushX()
            .extent([
                [margin.left, 0.5],
                [width - margin.right, focusHeight - margin.bottom + 0.5]
            ])
            .on("brush", brushed)
            .on("end", brushended);

        const defaultSelection = [
            x(d3.utcDay.offset(x.domain()[1], -1)),
            x.range()[1]
        ];

        svg.append("g").call(xAxis, x, focusHeight);

        var brushY = y.copy().range([focusHeight - margin.bottom, 4]);
        svg
            .append("path")
            .datum(data)
            .attr("fill", "steelblue")
            .attr("d", area(x, brushY));

        const gb = svg.append("g").call(brush).call(brush.move, defaultSelection);

        function brushed({ selection }) {
            if (selection) {
                [minX, maxX] = selection.map(x.invert, x).map(d3.utcDay.round);
                const maxY = d3.max(data, d => minX <= d.date && d.date <= maxX ? d.value : NaN);
                chart.update(x.copy().domain([minX, maxX]), y.copy().domain([0, maxY]));
            }
        }

        function brushended({ selection }) {
            if (!selection) {
                gb.call(brush.move, defaultSelection);
            }
        }

        return svg.node();
    })();

    const maxY = d3.max(data, d => minX <= d.date && d.date <= maxX ? d.value : NaN);
    chart.update(x.copy().domain([minX, maxX]), y.copy().domain([0, maxY]));
});

#####d3/treemap_brush.js:#####
// Load the data
d3.json("https://cdn.jsdelivr.net/npm/vega-datasets@2/data/flare.json").then(function(data) {
  // Define dimensions
  const width = 960;
  const height = 600;

  // Create a treemap layout
  const treemap = d3.treemap()
    .size([width, height])
    .paddingInner(1);

  // Create the root node
  const root = d3.hierarchy(data)
    .sum(d => d.value)
    .sort((a, b) => b.value - a.value);

  // Calculate the treemap layout
  treemap(root);

  // Create the SVG container
  const svg = d3.select("#treemap")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("font", "10px sans-serif");

  // Add a group for the treemap nodes
  const nodes = svg.selectAll("g")
    .data(root.leaves())
    .enter().append("g")
    .attr("transform", d => `translate(${d.x0},${d.y0})`);

  // Add rectangles for each node
  nodes.append("rect")
    .attr("id", d => "node-" + d.data.id)
    .attr("class", "node")
    .attr("width", d => d.x1 - d.x0)
    .attr("height", d => d.y1 - d.y0)
    .style("fill", d => d.children ? null : d.parent.data.color);

  // Add brush
  const brush = d3.brush()
    .on("start brush end", brushed);

  svg.call(brush);

  function brushed(event) {
    const selection = event.selection;
    nodes.select("rect")
      .classed("selected", d => selection && d.x0 >= selection[0][0] && d.x1 <= selection[1][0] && d.y0 >= selection[0][1] && d.y1 <= selection[1][1]);
  }
});

#####d3/treemap_click.js:#####
// Load the data
d3.json("https://cdn.jsdelivr.net/npm/vega-datasets@2/data/flare.json").then(function(data) {
  // Define dimensions
  const width = 960;
  const height = 600;

  // Create a treemap layout
  const treemap = d3.treemap()
    .size([width, height])
    .paddingInner(1);

  // Create the root node
  const root = d3.hierarchy(data)
    .sum(d => d.value)
    .sort((a, b) => b.value - a.value);

  // Calculate the treemap layout
  treemap(root);

  // Create the SVG container
  const svg = d3.select("#treemap")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("font", "10px sans-serif");

  // Add a group for the treemap nodes
  const nodes = svg.selectAll("g")
    .data(root.leaves())
    .enter().append("g")
    .attr("transform", d => `translate(${d.x0},${d.y0})`);

  // Add rectangles for each node
  const rects = nodes.append("rect")
    .attr("id", d => "node-" + d.data.id)
    .attr("class", "node")
    .attr("width", d => d.x1 - d.x0)
    .attr("height", d => d.y1 - d.y0)
    .style("fill", d => d.children ? null : d.parent.data.color)
    .on("click", clicked);

  let selectedNode = null;

  function clicked(event, d) {
    if (selectedNode) selectedNode.classed("selected", false);
    selectedNode = d3.select(this).classed("selected", true);
  }
});

#####d3/treemap_excentric_labeling.js:#####


#####d3/treemap_hover.js:#####
// Load the data
d3.json("https://cdn.jsdelivr.net/npm/vega-datasets@2/data/flare.json").then(function(data) {
  // Define dimensions
  const width = 960;
  const height = 600;

  // Create a treemap layout
  const treemap = d3.treemap()
    .size([width, height])
    .paddingInner(1);

  // Create the root node
  const root = d3.hierarchy(data)
    .sum(d => d.value)
    .sort((a, b) => b.value - a.value);

  // Calculate the treemap layout
  treemap(root);

  // Create the SVG container
  const svg = d3.select("#treemap")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("font", "10px sans-serif");

  // Add a group for the treemap nodes
  const nodes = svg.selectAll("g")
    .data(root.leaves())
    .enter().append("g")
    .attr("transform", d => `translate(${d.x0},${d.y0})`);

  // Add rectangles for each node
  const rects = nodes.append("rect")
    .attr("id", d => "node-" + d.data.id)
    .attr("class", "node")
    .attr("width", d => d.x1 - d.x0)
    .attr("height", d => d.y1 - d.y0)
    .style("fill", d => d.children ? null : d.parent.data.color)
    .on("mouseover", showTooltip)
    .on("mouseout", hideTooltip);

  const tooltip = d3.select("#tooltip");

  function showTooltip(event, d) {
    d3.select(this).classed("hovered", true);
    tooltip
      .style("left", `${event.pageX + 10}px`)
      .style("top", `${event.pageY + 10}px`)
      .html(`<b>${d.data.name}</b><br>Value: ${d.value}`);
  }

  function hideTooltip() {
    d3.selectAll(".node").classed("hovered", false);
    tooltip.html("");
  }
});

#####d3/treemap_panzoom.js:#####
d3.json('flare.json').then(data => {
  // Specify the chart's dimensions
  const width = 954;
  const height = 600;

  // Create the treemap layout
  const treemap = d3.treemap()
    .size([width, height])
    .padding(1)
    .round(true);

  // Compute the treemap layout
  const root = d3.hierarchy(data)
    .sum(d => d.value)
    .sort((a, b) => b.value - a.value);

  // Create the treemap using the computed layout
  treemap(root);

  // Create the SVG container
  const svg = d3.create("svg")
    .attr("viewBox", [0, 0, width, height])
    .style("font", "10px sans-serif");

  // Create the treemap cells
  const cell = svg.selectAll("rect")
    .data(root.leaves())
    .join("rect")
    .attr("x", d => d.x0)
    .attr("y", d => d.y0)
    .attr("width", d => d.x1 - d.x0)
    .attr("height", d => d.y1 - d.y0)
    .attr("fill", d => `hsl(${Math.random() * 360}, 70%, 80%)`); // Placeholder color

  // Create the text labels
  cell.append("title")
    .text(d => `${d.ancestors().reverse().map(d => d.data.name).join("/")}\n${d.value}`);

  // Create the zoom behavior
  const zoom = d3.zoom()
    .scaleExtent([1, 8])
    .on("zoom", zoomed);

  // Apply the zoom behavior to the SVG container
  svg.call(zoom);

  function zoomed({transform}) {
    cell.attr("transform", transform);
  }
});

#####d3/treemap_semantic_panzoom.js:#####
d3.json('flare.json').then(data => {
  // Specify the chart's dimensions
  const width = 954;
  const height = 600;

  // Create the treemap layout
  const treemap = d3.treemap()
    .size([width, height])
    .padding(1)
    .round(true);

  // Compute the treemap layout
  const root = d3.hierarchy(data)
    .sum(d => d.value)
    .sort((a, b) => b.value - a.value);

  // Create the treemap using the computed layout
  treemap(root);

  // Create the SVG container
  const svg = d3.create("svg")
    .attr("viewBox", [0, 0, width, height])
    .style("font", "10px sans-serif");

  // Create the treemap cells
  const cell = svg.selectAll("rect")
    .data(root.leaves())
    .join("rect")
    .attr("x", d => d.x0)
    .attr("y", d => d.y0)
    .attr("width", d => d.x1 - d.x0)
    .attr("height", d => d.y1 - d.y0)
    .attr("fill", d => `hsl(${Math.random() * 360}, 70%, 80%)`); // Placeholder color

  // Create the text labels
  cell.append("title")
    .text(d => `${d.ancestors().reverse().map(d => d.data.name).join("/")}\n${d.value}`);

  // Create the semantic zoom behavior
  const zoom = d3.zoom()
    .scaleExtent([1, 8])
    .on("zoom", zoomed);

  function zoomed({transform, source}) {
    // If the event source is not the zoom behavior, reset the zoom transform
    if (!source) {
      zoom.transform(svg, d3.zoomIdentity);
      return;
    }

    // Otherwise, apply the zoom transform
    cell.attr("transform", transform);
  }

  // Apply the semantic zoom behavior to the SVG container
  svg.call(zoom)
    .on("dblclick.zoom", null); // Disable double-click to zoom

  // Handle single clicks to zoom into the clicked cell
  cell.on("click", clicked);

  function clicked(event, d) {
    const [x0, y0, x1, y1] = [d.x0, d.y0, d.x1, d.y1];
    const scale = Math.min(width / (x1 - x0), height / (y1 - y0)) * 0.9;
    const translate = [(width - scale * (x1 + x0)) / 2, (height - scale * (y1 + y0)) / 2];

    svg.transition()
      .duration(750)
      .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
  }
});

#####d3/zoomable_circle_packing.js:#####
d3.json('flare-2.json').then(data => {
  // Specify the charts dimensions.
  const width = 928;
  const height = width;

  // Create the color scale.
  const color = d3.scaleLinear()
    .domain([0, 5])
    .range(["hsl(152,80%,80%)", "hsl(228,30%,40%)"])
    .interpolate(d3.interpolateHcl);

  // Compute the layout.
  const pack = data => d3.pack()
    .size([width, height])
    .padding(3)
    (d3.hierarchy(data)
      .sum(d => d.value)
      .sort((a, b) => b.value - a.value));
  const root = pack(data);

  // Create the SVG container.
  const svg = d3.create("svg")
    .attr("viewBox", `-${width / 2} -${height / 2} ${width} ${height}`)
    .attr("width", width)
    .attr("height", height)
    .attr("style", `max-width: 100%; height: auto; display: block; margin: 0 -14px; background: ${color(0)}; cursor: pointer;`);

  // Append the nodes.
  const node = svg.append("g")
    .selectAll("circle")
    .data(root.descendants().slice(1))
    .join("circle")
    .attr("fill", d => d.children ? color(d.depth) : "white")
    .attr("pointer-events", d => !d.children ? "none" : null)
    .on("mouseover", function () { d3.select(this).attr("stroke", "#000"); })
    .on("mouseout", function () { d3.select(this).attr("stroke", null); })
    .on("click", (event, d) => focus !== d && (zoom(event, d), event.stopPropagation()));

  // Append the text labels.
  const label = svg.append("g")
    .style("font", "10px sans-serif")
    .attr("pointer-events", "none")
    .attr("text-anchor", "middle")
    .selectAll("text")
    .data(root.descendants())
    .join("text")
    .style("fill-opacity", d => d.parent === root ? 1 : 0)
    .style("display", d => d.parent === root ? "inline" : "none")
    .text(d => d.data.name);

  // Create the zoom behavior and zoom immediately in to the initial focus node.
  svg.on("click", (event) => zoom(event, root));
  let focus = root;
  let view;
  zoomTo([focus.x, focus.y, focus.r * 2]);

  function zoomTo(v) {
    const k = width / v[2];

    view = v;

    label.attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`);
    node.attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`);
    node.attr("r", d => d.r * k);
  }

  function zoom(event, d) {
    const focus0 = focus;

    focus = d;

    const transition = svg.transition()
      .duration(event.altKey ? 7500 : 750)
      .tween("zoom", d => {
        const i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2]);
        return t => zoomTo(i(t));
      });

    label
      .filter(function (d) { return d.parent === focus || this.style.display === "inline"; })
      .transition(transition)
      .style("fill-opacity", d => d.parent === focus ? 1 : 0)
      .on("start", function (d) { if (d.parent === focus) this.style.display = "inline"; })
      .on("end", function (d) { if (d.parent !== focus) this.style.display = "none"; });
  }
})

#####libra_d3/bar_brush.js:#####
// global constants
globalThis.MARGIN = { top: 20, right: 0, bottom: 30, left: 40 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  const alphabet = {
    A: 0.08167,
    B: 0.01492,
    C: 0.02782,
    D: 0.04253,
    E: 0.12702,
    F: 0.02288,
    G: 0.02015,
    H: 0.06094,
    I: 0.06966,
    J: 0.00153,
    K: 0.00772,
    L: 0.04025,
    M: 0.02406,
    N: 0.06749,
    O: 0.07507,
    P: 0.01929,
    Q: 0.00095,
    R: 0.05987,
    S: 0.06327,
    T: 0.09056,
    U: 0.02758,
    V: 0.00978,
    W: 0.0236,
    X: 0.0015,
    Y: 0.01974,
    Z: 0.00074,
  };

  globalThis.data = [];
  Object.keys(alphabet).forEach((key) => {
    globalThis.data.push({
      name: key,
      value: alphabet[key],
    });
  });
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  // Add X axis
  globalThis.x = d3
    .scaleBand()
    .domain(globalThis.data.map((d) => d.name))
    .range([0, globalThis.WIDTH])
    .padding(0.1);
  svg
    .append("g")
    .attr("transform", "translate(0," + globalThis.HEIGHT + ")")
    .call(d3.axisBottom(globalThis.x).tickSizeOuter(0))
    .call((g) =>
      g
        .selectAll(".tick line")
        .clone()
        .attr("stroke-opacity", 0.1)
        .attr("y2", -globalThis.HEIGHT)
    );

  // Add Y axis
  globalThis.y = d3
    .scaleLinear()
    .domain([0, d3.max(globalThis.data, (d) => d.value)])
    .nice()
    .range([globalThis.HEIGHT, 0]);
  svg
    .append("g")
    .call(d3.axisLeft(globalThis.y))
    .call((g) =>
      g
        .selectAll(".tick line")
        .clone()
        .attr("stroke-opacity", 0.1)
        .attr("x2", globalThis.WIDTH)
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  // create layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  g = d3.select(mainLayer.getGraphic());

  // Draw the bars
  g.selectAll(".bar")
    .data(globalThis.data)
    .join("rect")
    .attr("class", "bar")
    .attr("opacity", "1")
    .attr("fill", "steelblue")
    .attr("stroke", "#fff")
    .attr("x", (d) => globalThis.x(d.name))
    .attr("y", (d) => globalThis.y(d.value))
    .attr("height", (d) => {
      return globalThis.y(0) - globalThis.y(d.value);
    })
    .attr("width", globalThis.x.bandwidth());

  return mainLayer;
}

function mountInteraction(layer) {
  Libra.Interaction.build({
    inherit: "BrushInstrument",
    layers: [layer],
    sharedVar: {
      highlightColor: "red",
    },
  });
}

main();


#####libra_d3/bar_click.js:#####
// global constants
globalThis.MARGIN = { top: 20, right: 0, bottom: 30, left: 40 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  const alphabet = {
    A: 0.08167,
    B: 0.01492,
    C: 0.02782,
    D: 0.04253,
    E: 0.12702,
    F: 0.02288,
    G: 0.02015,
    H: 0.06094,
    I: 0.06966,
    J: 0.00153,
    K: 0.00772,
    L: 0.04025,
    M: 0.02406,
    N: 0.06749,
    O: 0.07507,
    P: 0.01929,
    Q: 0.00095,
    R: 0.05987,
    S: 0.06327,
    T: 0.09056,
    U: 0.02758,
    V: 0.00978,
    W: 0.0236,
    X: 0.0015,
    Y: 0.01974,
    Z: 0.00074,
  };

  globalThis.data = [];
  Object.keys(alphabet).forEach((key) => {
    globalThis.data.push({
      name: key,
      value: alphabet[key],
    });
  });
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  // Add X axis
  globalThis.x = d3
    .scaleBand()
    .domain(globalThis.data.map((d) => d.name))
    .range([0, globalThis.WIDTH])
    .padding(0.1);
  svg
    .append("g")
    .attr("transform", "translate(0," + globalThis.HEIGHT + ")")
    .call(d3.axisBottom(globalThis.x).tickSizeOuter(0))
    .call((g) =>
      g
        .selectAll(".tick line")
        .clone()
        .attr("stroke-opacity", 0.1)
        .attr("y2", -globalThis.HEIGHT)
    );

  // Add Y axis
  globalThis.y = d3
    .scaleLinear()
    .domain([0, d3.max(globalThis.data, (d) => d.value)])
    .nice()
    .range([globalThis.HEIGHT, 0]);
  svg
    .append("g")
    .call(d3.axisLeft(globalThis.y))
    .call((g) =>
      g
        .selectAll(".tick line")
        .clone()
        .attr("stroke-opacity", 0.1)
        .attr("x2", globalThis.WIDTH)
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  // create layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  g = d3.select(mainLayer.getGraphic());

  // Draw the bars
  g.selectAll(".bar")
    .data(globalThis.data)
    .join("rect")
    .attr("class", "bar")
    .attr("opacity", "1")
    .attr("fill", "steelblue")
    .attr("stroke", "#fff")
    .attr("x", (d) => globalThis.x(d.name))
    .attr("y", (d) => globalThis.y(d.value))
    .attr("height", (d) => {
      return globalThis.y(0) - globalThis.y(d.value);
    })
    .attr("width", globalThis.x.bandwidth());

  return mainLayer;
}

function mountInteraction(layer) {
  Libra.Interaction.build({
    inherit: "ClickInstrument",
    layers: [layer],
    sharedVar: {
      highlightColor: "red",
    },
  });
}

main();


#####libra_d3/bar_hover.js:#####
// global constants
globalThis.MARGIN = { top: 20, right: 0, bottom: 30, left: 40 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  const alphabet = {
    A: 0.08167,
    B: 0.01492,
    C: 0.02782,
    D: 0.04253,
    E: 0.12702,
    F: 0.02288,
    G: 0.02015,
    H: 0.06094,
    I: 0.06966,
    J: 0.00153,
    K: 0.00772,
    L: 0.04025,
    M: 0.02406,
    N: 0.06749,
    O: 0.07507,
    P: 0.01929,
    Q: 0.00095,
    R: 0.05987,
    S: 0.06327,
    T: 0.09056,
    U: 0.02758,
    V: 0.00978,
    W: 0.0236,
    X: 0.0015,
    Y: 0.01974,
    Z: 0.00074,
  };

  globalThis.data = [];
  Object.keys(alphabet).forEach((key) => {
    globalThis.data.push({
      name: key,
      value: alphabet[key],
    });
  });
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  // Add X axis
  globalThis.x = d3
    .scaleBand()
    .domain(globalThis.data.map((d) => d.name))
    .range([0, globalThis.WIDTH])
    .padding(0.1);
  svg
    .append("g")
    .attr("transform", "translate(0," + globalThis.HEIGHT + ")")
    .call(d3.axisBottom(globalThis.x).tickSizeOuter(0))
    .call((g) =>
      g
        .selectAll(".tick line")
        .clone()
        .attr("stroke-opacity", 0.1)
        .attr("y2", -globalThis.HEIGHT)
    );

  // Add Y axis
  globalThis.y = d3
    .scaleLinear()
    .domain([0, d3.max(globalThis.data, (d) => d.value)])
    .nice()
    .range([globalThis.HEIGHT, 0]);
  svg
    .append("g")
    .call(d3.axisLeft(globalThis.y))
    .call((g) =>
      g
        .selectAll(".tick line")
        .clone()
        .attr("stroke-opacity", 0.1)
        .attr("x2", globalThis.WIDTH)
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  // create layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  g = d3.select(mainLayer.getGraphic());

  // Draw the bars
  g.selectAll(".bar")
    .data(globalThis.data)
    .join("rect")
    .attr("class", "bar")
    .attr("opacity", "1")
    .attr("fill", "steelblue")
    .attr("stroke", "#fff")
    .attr("x", (d) => globalThis.x(d.name))
    .attr("y", (d) => globalThis.y(d.value))
    .attr("height", (d) => {
      return globalThis.y(0) - globalThis.y(d.value);
    })
    .attr("width", globalThis.x.bandwidth());

  return mainLayer;
}

function mountInteraction(layer) {
  Libra.Interaction.build({
    inherit: "HoverInstrument",
    layers: [layer],
    sharedVar: {
      highlightColor: "red",
    },
  });
}

main();


#####libra_d3/bar_panzoom.js:#####
// global constants
globalThis.MARGIN = { top: 20, right: 0, bottom: 30, left: 40 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  const alphabet = {
    A: 0.08167,
    B: 0.01492,
    C: 0.02782,
    D: 0.04253,
    E: 0.12702,
    F: 0.02288,
    G: 0.02015,
    H: 0.06094,
    I: 0.06966,
    J: 0.00153,
    K: 0.00772,
    L: 0.04025,
    M: 0.02406,
    N: 0.06749,
    O: 0.07507,
    P: 0.01929,
    Q: 0.00095,
    R: 0.05987,
    S: 0.06327,
    T: 0.09056,
    U: 0.02758,
    V: 0.00978,
    W: 0.0236,
    X: 0.0015,
    Y: 0.01974,
    Z: 0.00074,
  };

  globalThis.data = [];
  Object.keys(alphabet).forEach((key) => {
    globalThis.data.push({
      name: key,
      value: alphabet[key],
    });
  });
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  // Add clip
  svg
    .append("clipPath")
    .attr("id", "clipMainLayer-brush")
    .append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", globalThis.WIDTH)
    .attr("height", globalThis.HEIGHT);

  // Add X axis
  globalThis.x = d3
    .scaleBand()
    .domain(globalThis.data.map((d) => d.name))
    .range([0, globalThis.WIDTH])
    .padding(0.1);


  // Add Y axis
  globalThis.y = d3
    .scaleLinear()
    .domain([0, d3.max(globalThis.data, (d) => d.value)])
    .nice()
    .range([globalThis.HEIGHT, 0]);
  svg
    .append("g")
    .call(d3.axisLeft(globalThis.y))
    .call((g) =>
      g
        .selectAll(".tick line")
        .clone()
        .attr("stroke-opacity", 0.1)
        .attr("x2", globalThis.WIDTH)
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const [mainLayer, transformer] = renderMainVisualization();
  mountInteraction(mainLayer, transformer);
}

function renderMainVisualization(scaleX = globalThis.x) {
  // Find SVG
  const svg = d3.select("#LibraPlayground svg");

  let g = svg.select(".main");
  let returnVal = null;
  if (g.empty()) {
    // create layer if not exists
    const mainLayer = Libra.Layer.initialize("D3Layer", {
      name: "mainLayer",
      width: globalThis.WIDTH,
      height: globalThis.HEIGHT,
      offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
      container: svg.node(),
    });
    g = d3.select(mainLayer.getGraphic());
    g.attr("class", "main");

    Libra.GraphicalTransformer.register("DrawAxesAndMarks", {
      sharedVar: {
        scaleX: globalThis.x,
      },
      redraw({ transformer }) {
        const scaleX = transformer.getSharedVar("scaleX");
        renderMainVisualization(scaleX);
      },
    });

    const transformer = Libra.GraphicalTransformer.initialize(
      "DrawAxesAndMarks",
      {
        layer: mainLayer,
      }
    );

    returnVal = [mainLayer, transformer];
  }

  // Clear the layer
  g.selectChildren().remove();

  // Add X axis
  g.append("g")
    .attr("transform", "translate(0," + globalThis.HEIGHT + ")")
    .call(d3.axisBottom(scaleX).tickSizeOuter(0))
    .call((g) =>
      g
        .selectAll(".tick line")
        .clone()
        .attr("stroke-opacity", 0.1)
        .attr("y2", -globalThis.HEIGHT)
    );

  // Draw bars code from the input static visualization
  g.append("g")
    .attr("clip-path", `url(#clipMainLayer-brush)`)
    .selectAll(".bar")
    .data(globalThis.data)
    .join("rect")
    .attr("class", "bar")
    .attr("opacity", "1")
    .attr("fill", "steelblue")
    .attr("stroke", "#fff")
    .attr("x", (d) => scaleX(d.name))
    .attr("y", (d) => globalThis.y(d.value))
    .attr("height", (d) => {
      return globalThis.y(0) - globalThis.y(d.value);
    })
    .attr("width", scaleX.bandwidth());

  return returnVal;
}

function mountInteraction(layer, transformer) {
  Libra.Interaction.build({
    inherit: "PanInstrument",
    layers: [layer],
    sharedVar: {
      scaleX: globalThis.x,
    },
  });

  Libra.Interaction.build({
    inherit: "GeometricZoomInstrument",
    layers: [layer],
    sharedVar: {
      scaleX: globalThis.x,
    },
  });
}

main();


#####libra_d3/dimpvis.js:#####
// global constants
globalThis.START_YEAR = 1980;
globalThis.MARGIN = { top: 2.5, right: 168, bottom: 39.5, left: 36 };
globalThis.WIDTH = 800;
globalThis.HEIGHT = 600;

// global variables
globalThis.data = [];
globalThis.year = globalThis.START_YEAR;
globalThis.interpolatedData = [];

// shared scales
globalThis.x = null;
globalThis.y = null;
globalThis.color = null;

async function loadData() {
  //Read the data
  globalThis.data = await d3.json("./data/gapminder.json");
  globalThis.interpolatedData = globalThis.data.filter(
    (x) => x.year === globalThis.year
  );
}

async function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  // Add X axis
  globalThis.x = d3
    .scaleLinear()
    .domain(
      d3.extent(globalThis.data, function (d) {
        return d.fertility;
      })
    )
    .range([0, globalThis.WIDTH])
    .nice();
  svg
    .append("g")
    .attr("transform", "translate(0," + globalThis.HEIGHT + ")")
    .call(d3.axisBottom(globalThis.x).ticks(5))
    .call((g) => {
      g.selectAll("g.tick")
        .append("line")
        .attr("y1", 0)
        .attr("y2", -globalThis.HEIGHT)
        .attr("stroke", "currentColor")
        .attr("stroke-opacity", 0.1);
    })
    .call((g) =>
      g
        .append("text")
        .text("Fertility")
        .attr("font-family", "sans-serif")
        .attr("font-size", "12px")
        .attr("font-weight", "bold")
        .attr("fill", "currentColor")
        .attr("text-anchor", "middle")
        .attr("transform", `translate(${globalThis.WIDTH / 2}, 30)`)
    );

  // Add Y axis
  globalThis.y = d3
    .scaleLinear()
    .domain(
      d3.extent(globalThis.data, function (d) {
        return d.life_expect;
      })
    )
    .range([globalThis.HEIGHT, 0])
    .nice();
  svg
    .append("g")
    .call(d3.axisLeft(globalThis.y).ticks(5))
    .call((g) => {
      g.selectAll("g.tick")
        .append("line")
        .attr("x1", 0)
        .attr("x2", globalThis.WIDTH)
        .attr("stroke", "currentColor")
        .attr("stroke-opacity", 0.1);
    })
    .call((g) =>
      g
        .append("text")
        .text("Life Expectancy")
        .attr("font-family", "sans-serif")
        .attr("font-size", "12px")
        .attr("font-weight", "bold")
        .attr("fill", "currentColor")
        .attr("text-anchor", "middle")
        .attr(
          "transform",
          `translate(-25, ${globalThis.HEIGHT / 2}) rotate(-90)`
        )
    );

  // Color palette
  const clusterDomain = [0, 1, 2, 3, 4, 5];
  globalThis.color = d3
    .scaleOrdinal()
    .domain(clusterDomain)
    .range(['#4c78a8', '#72b7b2', '#eeca3b', '#f58518', '#e45756', '#54a24b']);
  const colorName = d3
    .scaleOrdinal()
    .domain(clusterDomain)
    .range([
      "South Asia",
      "Europe & Central Asia",
      "Sub-saharan Africa",
      "America",
      "East Asia & Pacific",
      "Middle East & North Africa",
    ]);

  // Draw the year
  svg
    .append("g")
    .attr("class", "year")
    .append("text")
    .attr("x", 300)
    .attr("y", 300)
    .attr("font-family", "sans-serif")
    .attr("font-size", 100)
    .attr("fill", "grey")
    .attr("opacity", 0.25)
    .attr("text-align", "center")
    .text(globalThis.year);

  // Draw the legend
  svg
    .append("g")
    .attr("class", "legend")
    .attr(
      "transform",
      `translate(${globalThis.WIDTH + 10}, ${globalThis.MARGIN.top + 10})`
    )
    .call((g) => {
      g.append("text")
        .attr("x", -5)
        .attr("y", 0)
        .attr("font-family", "sans-serif")
        .attr("font-size", 11)
        .attr("font-weight", "bold")
        .attr("alignment-baseline", "middle")
        .text("Region");
    })
    .selectAll("g")
    .data([0, 3, 4, 1, 5, 2])
    .enter()
    .append("g")
    .attr("transform", (d, i) => `translate(0, ${i * 13 + 16})`)
    .call((g) => {
      g.append("circle")
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("r", 5)
        .attr("fill", (d, i) => globalThis.color(d))
        .attr("fill-opacity", 0.5);
    })
    .call((g) => {
      g.append("text")
        .attr("x", 10)
        .attr("y", 0)
        .attr("font-family", "sans-serif")
        .attr("font-size", 10)
        .attr("alignment-baseline", "middle")
        .text((d, i) => colorName(d));
    });
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = await renderMainVisualization();
  await mountInteraction(mainLayer);
}

async function renderMainVisualization(
  interpolatedData = globalThis.interpolatedData
) {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  let g = svg.select(".mark");
  let returnVal = null;
  if (g.empty()) {
    // create layer if not exists
    const mainLayer = Libra.Layer.initialize("D3Layer", {
      name: "mainLayer",
      width: globalThis.WIDTH,
      height: globalThis.HEIGHT,
      offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
      container: svg.node(),
    });
    g = d3.select(mainLayer.getGraphic());
    g.attr("class", "mark");

    returnVal = mainLayer;
  }

  // Draw the scatters
  g.selectAll("circle")
    .data(interpolatedData)
    .join("circle")
    .attr("fill", (d) => globalThis.color(d.cluster))
    .attr("cx", (d) => globalThis.x(d.fertility))
    .attr("cy", (d) => globalThis.y(d.life_expect))
    .attr("fill-opacity", 0.5)
    .attr("r", 6);

  // Update the year
  svg.select(".year text").text(interpolatedData[0].year);

  return returnVal;
}

async function mountInteraction(layer) {
  // Register TraceTransformer
  Libra.GraphicalTransformer.register("TraceTransformer", {
    redraw: function ({ layer }) {
      const data = this.getSharedVar("result");
      if (data) {
        // Draw the trace
        const transientLayer = layer.getLayerFromQueue("transientLayer");
        d3.select(transientLayer.getGraphic()).selectAll("*").remove();
        d3.select(transientLayer.getGraphic())
          .append("g")
          .attr("class", "trace")
          .call((g) => {
            g.append("path")
              .attr(
                "d",
                d3.line(
                  (d) => globalThis.x(d.fertility),
                  (d) => globalThis.y(d.life_expect)
                )(data)
              )
              .attr("fill", "none")
              .attr("stroke", "#bbb")
              .attr("stroke-width", 3)
              .attr("stroke-opacity", 0.5);
          })
          .call((g) => {
            g.selectAll("text")
              .data(data)
              .enter()
              .append("text")
              .attr("fill", "#555")
              .attr("fill-opacity", 0.6)
              .attr("font-size", 12)
              .attr("x", (d) => globalThis.x(d.fertility))
              .attr("y", (d) => globalThis.y(d.life_expect))
              .text((d) => d.year);
          });
      }
    },
  });

  Libra.GraphicalTransformer.register("MainTransformer", {
    redraw({ transformer }) {
      const result = transformer.getSharedVar("result");
      if (result) {
        globalThis.interpolatedData = result;
        renderMainVisualization(result);
      }
    },
  });

  const useTraceTransformerFlow = {
    find: "SelectionService",
    flow: [
      {
        comp: "FilterService",
        sharedVar: {
          data: globalThis.data,
          fields: ["country"],
        },
      },
      {
        comp: "TraceTransformer",
      },
    ],
  };

  const useCountryFlow = {
    find: "SelectionService",
    flow: [
      {
        comp: "TextTransformer",
        layer: layer.getLayerFromQueue("countryLayer"),
        sharedVar: {
          field: "country",
          position: (d) =>
            globalThis.interpolatedData
              .filter((dd) => dd.country == d.country)
              .map((d) => ({
                x: globalThis.x(d.fertility),
                y: globalThis.y(d.life_expect),
              }))[0],
        },
      },
    ],
  };

  Libra.Interaction.build({
    inherit: "HoverInstrument",
    layers: [layer],
    remove: [{ find: "SelectionTransformer" }],
    insert: [useTraceTransformerFlow, useCountryFlow],
  });

  Libra.Interaction.build({
    inherit: "DragInstrument",
    layers: [layer],
    remove: [{ find: "SelectionTransformer" }],
    insert: [
      useTraceTransformerFlow,
      useCountryFlow,
      {
        find: "SelectionService",
        flow: [
          {
            comp: "NearestPointService",
            sharedVar: { layer: layer.getLayerFromQueue("transientLayer") },
            evaluate(options) {
              const { layer, offsetx, offsety } = options;
              const point = [offsetx, offsety];
              if (layer && offsetx && offsety) {
                const year = d3
                  .select(layer.getGraphic())
                  .select(".trace")
                  .selectAll("text")
                  .data();
                const trace = d3
                  .select(layer.getGraphic())
                  .select("path")
                  .attr("d");
                const poly = trace
                  .slice(1)
                  .split("L")
                  .map((pStr) => pStr.split(",").map((num) => parseFloat(num)));
                return {
                  data: year,
                  interpolatedNum: interpolateNNPointFromPoly(
                    [point[0] - layer._offset.x, point[1] - layer._offset.y],
                    poly
                  ),
                };
              }
              return null;
            },
          },
          {
            comp: "InterpolationService",
            sharedVar: {
              data: globalThis.data,
              field: "year",
              formula: {
                year: (d) => Math.floor(d.year / 5) * 5, // Year divisible by 5
              },
            },
          },
          {
            comp: "MainTransformer",
          },
        ],
      },
    ],
  });
}

function interpolateNNPointFromPoly(point, polyline) {
  // Find the squared distance between two points
  function distanceSquared(p1, p2) {
    let dx = p1[0] - p2[0];
    let dy = p1[1] - p2[1];
    return dx * dx + dy * dy;
  }

  // Find the closest point on a polyline from a given point
  let minDistance = Number.MAX_VALUE;
  let interpolationFactor = 0;
  for (let i = 0; i < polyline.length - 1; i++) {
    let lineStart = polyline[i];
    let lineEnd = polyline[i + 1];
    let lineLengthSquared = distanceSquared(lineStart, lineEnd);
    let u =
      ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +
        (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /
      lineLengthSquared;
    let closest = null;
    if (u < 0) {
      closest = lineStart;
    } else if (u > 1) {
      closest = lineEnd;
    } else {
      closest = [
        lineStart[0] + u * (lineEnd[0] - lineStart[0]),
        lineStart[1] + u * (lineEnd[1] - lineStart[1]),
      ];
    }
    let distance = distanceSquared(point, closest);
    if (distance < minDistance) {
      minDistance = distance;
      if (u < 0) {
        interpolationFactor = i;
      } else if (u > 1) {
        interpolationFactor = i + 1;
      } else {
        interpolationFactor = i + u;
      }
    }
  }
  return interpolationFactor;
}

main();


#####libra_d3/dust_magnet.js:#####
// global constants
globalThis.MARGIN = { top: 0, right: 0, bottom: 0, left: 0 };
globalThis.WIDTH = 800 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 600 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  globalThis.data = await d3.json("./data/cars.json");
  globalThis.magnet = [];

  const datum = globalThis.data[0];
  globalThis.properties = [];
  for (const property in datum) {
    const value = datum[property];
    if (typeof value === "number") {
      globalThis.properties.push(property);
      // initialize 3 magnets
      if (globalThis.magnet.length < 3) {
        globalThis.magnet.push({
          x:
            globalThis.WIDTH / 2 -
            Math.pow(-1, globalThis.magnet.length) *
              (globalThis.WIDTH / 2 - 100),
          y:
            globalThis.HEIGHT / 2 -
            Math.pow(-1, Math.floor(globalThis.magnet.length / 2)) *
              (globalThis.HEIGHT / 2 - 100),
          property,
        });
      }
    }
  }

  globalThis.data = globalThis.data.slice(0, 50).map((d) => ({
    ...d,
    x: globalThis.WIDTH / 2,
    y: globalThis.HEIGHT / 2,
  }));
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const [bgLayer, dustLayer, magnetLayer] = renderMainVisualization();
  mountInteraction(bgLayer, dustLayer, magnetLayer);
}

function renderMainVisualization() {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  // create layer
  const dustLayer = Libra.Layer.initialize("D3Layer", {
    name: "dustLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  const magnetLayer = dustLayer.getLayerFromQueue("magnetLayer");
  const backgroundLayer = dustLayer.getLayerFromQueue("backgroundLayer");
  d3.select(dustLayer.getGraphic()).attr("class", "dust");
  d3.select(magnetLayer.getGraphic()).attr("class", "magnet");

  dustLayer.setLayersOrder({
    backgroundLayer: 0,
    dustLayer: 1,
    magnetLayer: 2,
  });

  d3.select(backgroundLayer.getGraphic())
    .select("rect")
    .attr("stroke", "#000")
    .attr("fill", "none")
    .attr("opacity", 1);

  renderDust();
  renderMagnet();

  return [backgroundLayer, dustLayer, magnetLayer];
}

function renderDust(data = globalThis.data) {
  d3.select("#LibraPlayground svg .dust")
    .selectAll("circle")
    .data(data)
    .join("circle")
    .attr("cx", (d) => d.x)
    .attr("cy", (d) => d.y)
    .attr("stroke", "#000")
    .attr("fill", "#B9B9B9")
    .attr("r", 10);
}

function renderMagnet(data = globalThis.magnet) {
  d3.select("#LibraPlayground svg .magnet")
    .call((g) => g.selectChildren().remove())
    .selectAll("g")
    .data(data)
    .enter()
    .append("g")
    .call((g) =>
      g
        .append("rect")
        .attr("x", (d) => d.x)
        .attr("y", (d) => d.y)
        .attr("width", 50)
        .attr("height", 50)
        .attr("fill", "orange")
    )
    .call((g) =>
      g
        .append("text")
        .attr("x", (d) => d.x + 50 / 2)
        .attr("y", (d) => d.y + 50 / 2)
        .attr("text-anchor", "middle")
        .text((d) => d.property)
    );
}

function mountInteraction(bgLayer, dustLayer, magnetLayer) {
  const dustTransformer = Libra.GraphicalTransformer.initialize(
    "DustTransformer",
    {
      layer: dustLayer,
      sharedVar: { result: globalThis.data },
      redraw({ transformer }) {
        const dusts = transformer.getSharedVar("result");
        renderDust(dusts);
      },
    }
  );

  const magnetTransformer = Libra.GraphicalTransformer.initialize(
    "MagnetTransformer",
    {
      layer: magnetLayer,
      sharedVar: { result: globalThis.magnet },
      redraw({ transformer }) {
        const magnets = transformer.getSharedVar("result");
        renderMagnet(magnets);
      },
    }
  );

  const commonInsertFlows = [
    {
      find: "SelectionService",
      flow: [
        {
          comp: "MagnetPositionService",
          name: "MagnetPositionService",
          sharedVar: {
            magnets: globalThis.magnet,
          },
          evaluate({ magnets, offsetx, offsety, result }) {
            if (result && result.length) {
              const datum = d3.select(result[0]).datum();
              datum.x = offsetx - 25;
              datum.y = offsety - 25;
            } else if (offsetx && offsety) {
              magnets.push({
                x: offsetx - 25,
                y: offsety - 25,
                property:
                  globalThis.properties[
                    magnets.length % globalThis.properties.length
                  ],
              });
            }
            return magnets;
          },
        },
        magnetTransformer,
      ],
    },
    {
      find: "MagnetPositionService",
      flow: [
        {
          comp: "DustLayoutService",
          name: "DustLayoutService",
          sharedVar: { result: globalThis.magnet, dusts: globalThis.data },
          evaluate({ result: magnets, dusts, self }) {
            cancelAnimationFrame(globalThis.tickUpdate);

            const copyDusts = JSON.parse(JSON.stringify(dusts));

            for (const magnet of magnets) {
              const extent = d3.extent(
                copyDusts.map((datum) => datum[magnet.property])
              );
              for (const dust of copyDusts) {
                let x = dust.x;
                let y = dust.y;
                let dx = magnet.x;
                let dy = magnet.y;
                x += ((dx - x) * dust[magnet.property]) / 100 / extent[1];
                y += ((dy - y) * dust[magnet.property]) / 100 / extent[1];

                dust.x = x;
                dust.y = y;
              }
            }

            globalThis.tickUpdate = requestAnimationFrame(() =>
              self.setSharedVar("dusts", copyDusts)
            );
            return copyDusts;
          },
        },
        dustTransformer,
      ],
    },
  ];

  Libra.Interaction.build({
    inherit: "DragInstrument",
    layers: [
      { layer: magnetLayer, options: { pointerEvents: "visiblePainted" } }, // Block the underlying layer events
    ],
    remove: [
      {
        find: "SelectionTransformer", // Don't render the selected mark
      },
    ],
    insert: commonInsertFlows,
  });

  Libra.Interaction.build({
    inherit: "ClickInstrument",
    layers: [bgLayer],
    insert: commonInsertFlows,
  });

  Libra.Interaction.build({
    inherit: "HoverInstrument",
    layers: [dustLayer],
    sharedVar: {
      highlightColor: "greenyellow",
    },
  });
}

main();


#####libra_d3/edge_bundling.js:#####


#####libra_d3/force_directed_layout.js:#####


#####libra_d3/helper_line.js:#####
// global constants
globalThis.MARGIN = { top: 20, right: 0, bottom: 30, left: 40 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

function loadData() {
  const alphabet = {
    A: 0.08167,
    B: 0.01492,
    C: 0.02782,
    D: 0.04253,
    E: 0.12702,
    F: 0.02288,
    G: 0.02015,
    H: 0.06094,
    I: 0.06966,
    J: 0.00153,
    K: 0.00772,
    L: 0.04025,
    M: 0.02406,
    N: 0.06749,
    O: 0.07507,
    P: 0.01929,
    Q: 0.00095,
    R: 0.05987,
    S: 0.06327,
    T: 0.09056,
    U: 0.02758,
    V: 0.00978,
    W: 0.0236,
    X: 0.0015,
    Y: 0.01974,
    Z: 0.00074,
  };

  globalThis.data = [];
  Object.keys(alphabet).forEach((key) => {
    globalThis.data.push({
      name: key,
      value: alphabet[key],
    });
  });
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr(
      "viewbox",
      `0 0 ${
        globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
      } ${globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom}`
    )
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  // Add X axis
  globalThis.x = d3
    .scaleBand()
    .domain(globalThis.data.map((d) => d.name))
    .range([0, globalThis.WIDTH])
    .padding(0.1);
  svg
    .append("g")
    .attr("transform", "translate(0," + globalThis.HEIGHT + ")")
    .call(d3.axisBottom(globalThis.x).tickSizeOuter(0))
    .call((g) =>
      g
        .selectAll(".tick line")
        .clone()
        .attr("stroke-opacity", 0.1)
        .attr("y2", -globalThis.HEIGHT)
    );

  // Add Y axis
  globalThis.y = d3
    .scaleLinear()
    .domain([0, d3.max(globalThis.data, (d) => d.value)])
    .nice()
    .range([globalThis.HEIGHT, 0]);
  svg
    .append("g")
    .call(d3.axisLeft(globalThis.y))
    .call((g) =>
      g
        .selectAll(".tick line")
        .clone()
        .attr("stroke-opacity", 0.1)
        .attr("x2", globalThis.WIDTH)
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // Find the SVG element on page
  const svg = d3.select("#LibraPlayground svg");

  // Create the main layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  g = d3.select(mainLayer.getGraphic());

  // Draw bars code from the input static visualization
  g.selectAll(".bar")
    .data(globalThis.data)
    .join("rect")
    .attr("class", "bar")
    .attr("opacity", "1")
    .attr("fill", "steelblue")
    .attr("stroke", "#fff")
    .attr("x", (d) => globalThis.x(d.name))
    .attr("y", (d) => globalThis.y(d.value))
    .attr("height", (d) => {
      return globalThis.y(0) - globalThis.y(d.value);
    })
    .attr("width", globalThis.x.bandwidth());

  return mainLayer;
}

function mountInteraction(layer) {
  // Attach HelperLineInstrument to the main layer
  Libra.Instrument.initialize("HelperLineInstrument", {
    layers: [layer],
    sharedVar: {
      style: { "stroke-dasharray": "10,10" },
      tooltip: true,
      scaleY: globalThis.y,
    },
  });
}

main();


#####libra_d3/index_chart.js:#####
// global constants
globalThis.MARGIN = { top: 20, right: 70, bottom: 50, left: 50 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;
globalThis.IBMURL = "./data/stocks/IBM.csv";
globalThis.GOOGURL = "./data/stocks/GOOG.csv";
globalThis.MSFTURL = "./data/stocks/MSFT.csv";
globalThis.AAPLURL = "./data/stocks/AAPL.csv";
globalThis.AMZNURL = "./data/stocks/AMZN.csv";
globalThis.STOCKSURL = "./data/stocks/stocks.csv";

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;
globalThis.color = null;

async function loadData() {
  const data = await d3.csv(globalThis.STOCKSURL, (d) => ({
    name: d.symbol,
    date: new Date(d.date),
    value: +d.price,
  }));

  globalThis.data = d3.groups(data, (d) => d.name);

  const date = data[0].date;

  globalThis.data.forEach(([_, items]) => {
    if (items.length > 0) {
      let leftItemIndex = 0;
      let rightItemIndex = 0;
      for (let i = 1; i < items.length; ++i) {
        const item = items[i];
        if (date <= item.date) {
          leftItemIndex = i - 1;
          rightItemIndex = i;
          break;
        }
      }
      const leftItem = items[leftItemIndex];
      const rightItem = items[rightItemIndex];
      const a =
        leftItem.date === rightItem.date
          ? 1
          : (date - leftItem.date) / (rightItem.date - leftItem.date);
      let baseValue = leftItem.value * a + rightItem.value * (1 - a);
      items.forEach(({ value }, i) => {
        items[i].k = value / baseValue;
      });
    }
  });
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr(
      "viewbox",
      `0 0 ${globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
      } ${globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom}`
    )
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  // Add X axis
  globalThis.x = d3
    .scaleUtc()
    .domain(
      d3.extent(
        globalThis.data.flatMap((d) => d[1]),
        (d) => d.date
      )
    )
    .range([0, globalThis.WIDTH]);
  svg
    .append("g")
    .attr("transform", "translate(0," + globalThis.HEIGHT + ")")
    .call(d3.axisBottom(globalThis.x).tickSizeOuter(0))
    .call((g) =>
      g
        .selectAll(".tick line")
        .clone()
        .attr("stroke-opacity", 0.1)
        .attr("y2", -globalThis.HEIGHT)
    );

  // Add Y axis
  globalThis.y = d3
    .scaleLinear()
    .domain(
      d3.extent(
        globalThis.data.flatMap((d) => d[1]),
        (d) => d.k
      )
    )
    .range([globalThis.HEIGHT, 0]);

  // Add color scale
  globalThis.color = d3
    .scaleOrdinal(d3.schemeCategory10)
    .domain(globalThis.data.map((d) => d.name));

  svg
    .append("g")
    .call((g) =>
      g
        .append("text")
        .text('symbol')
        .attr("fill", "black")
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("font-weight", "bold")
        .attr("x", globalThis.WIDTH + globalThis.MARGIN.right / 2)
        .attr("y", -globalThis.MARGIN.top / 2)
    )
    .call((g) =>
      g
        .append("g")
        .selectAll("g")
        .data(
          ['MSFT', 'AMZN', 'IBM', 'GOOG', 'AAPL']
        )
        .join("g")
        .call((g) => {
          g.append("line")
            .attr("fill-opacity", "0")
            .attr("stroke-width", 2)
            .attr("stroke", (d) => globalThis.color(d))
            .attr("x1", globalThis.WIDTH + 5)
            .attr("x2", globalThis.WIDTH + 15)
            .attr("y1", (_, i) => i * 20)
            .attr("y2", (_, i) => i * 20);
        })
        .call((g) => {
          g.append("text")
            .text((d) => d)
            .attr("font-size", "12px")
            .attr("x", globalThis.WIDTH + 20)
            .attr("y", (_, i) => i * 20 + 5);
        })
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization(
  scaleY = globalThis.y,
  data = globalThis.data
) {
  // Find the SVG element on page
  const svg = d3.select("#LibraPlayground svg");

  // Create the main layer
  let returnVal = null;
  let g = svg.select(".main");
  if (g.empty()) {
    const mainLayer = Libra.Layer.initialize("D3Layer", {
      name: "mainLayer",
      width: globalThis.WIDTH,
      height: globalThis.HEIGHT,
      offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
      container: svg.node(),
    });
    g = d3.select(mainLayer.getGraphic()).attr("class", "main");

    returnVal = mainLayer;
  }
  g.selectChildren().remove();

  const line = d3
    .line()
    .x((d) => globalThis.x(d.date))
    .y((d) => scaleY(d.k));

  g.append("g")
    .call(d3.axisLeft(scaleY).tickFormat(d3.format(".0%")))
    .call((g) =>
      g
        .selectAll(".tick line")
        .clone()
        .attr("stroke-opacity", 0.1)
        .attr("x2", globalThis.WIDTH)
    );

  g.append("g")
    .style("font", "bold 10px sans-serif")
    .selectAll("g")
    .data(data)
    .join("g")
    .attr("stroke", (d) => globalThis.color(d[0]))
    .datum((d) => d[1])
    .append("path")
    .attr("fill", "none")
    .attr("stroke-width", 1.5)
    .attr("stroke-linejoin", "round")
    .attr("stroke-linecap", "round")
    .attr("d", (d) => line(d));

  return returnVal;
}

function mountInteraction(layer) {
  // Initialize Main Transformer
  const mainTransformer = Libra.GraphicalTransformer.initialize(
    "MainTransformer",
    {
      layer,
      sharedVar: {
        result: { scaleY: globalThis.y, data: globalThis.data },
      },
      redraw({ transformer }) {
        const { scaleY, data } = transformer.getSharedVar("result");
        renderMainVisualization(scaleY, data);
      },
    }
  );

  // Initialize Service
  const normalizationService = Libra.Service.initialize(
    "NormalizationService",
    {
      constructor: Libra.Service.AnalysisService,
      transformers: [mainTransformer],
      sharedVar: { point: 0 },
      evaluate({ point }) {
        const date = globalThis.x.invert(point);
        const data = JSON.parse(JSON.stringify(globalThis.data));
        data.forEach(([_, items]) => {
          if (items.length > 0) {
            items.forEach(({ date }, i) => {
              items[i].date = new Date(date);
            });
            let leftItemIndex = 0;
            let rightItemIndex = 0;
            for (let i = 1; i < items.length; ++i) {
              const item = items[i];
              if (date <= item.date) {
                leftItemIndex = i - 1;
                rightItemIndex = i;
                break;
              }
            }
            const leftItem = items[leftItemIndex];
            const rightItem = items[rightItemIndex];
            const a =
              leftItem.date === rightItem.date
                ? 1
                : (date - leftItem.date) / (rightItem.date - leftItem.date);
            let baseValue = leftItem.value * a + rightItem.value * (1 - a);
            items.forEach(({ value }, i) => {
              items[i].k = value / baseValue;
            });
          }
        });

        const scaleY = globalThis.y.copy();
        scaleY.domain(
          d3.extent(
            data.flatMap((d) => d[1]),
            (d) => d.k
          )
        );

        return { scaleY, data };
      },
    }
  );

  // Attach HelperLineInstrument to the main layer
  const helperLineInstrument = Libra.Instrument.initialize(
    "HelperLineInstrument",
    {
      layers: [layer],
      services: [normalizationService],
      sharedVar: {
        orientation: ["vertical"],
        style: {
          stroke: "black",
        },
      },
    }
  );

  helperLineInstrument.on("hover", function ({ instrument }) {
    const barX = instrument.getSharedVar("x") - globalThis.MARGIN.left;
    instrument.services.setSharedVar("point", barX);
  });
}

main();


#####libra_d3/map_brush.js:#####
// global constants
globalThis.MARGIN = { top: 0, right: 0, bottom: 0, left: 0 };
globalThis.WIDTH = 1000 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 400 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  const nc = await d3.json("./data/ncmap_pop_density_topojson.json");
  globalThis.data = topojson.feature(nc, nc.objects.ncmap).features;
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  // create layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  g = d3.select(mainLayer.getGraphic());

  // Draw the map
  const path = d3.geoPath();

  g.selectAll(".counties")
    .data(globalThis.data)
    .join("g")
    .attr("class", "counties")
    .attr("transform", `translate(${0}, ${0}) scale(${1 - 0})`)
    .call((g) =>
      g
        .append("path")
        .attr("d", path)
        .attr("fill", "#b7dbff")
        .append("title")
        .text("counties")
    )
    .call((g) =>
      g
        .append("text")
        .text((d) => d.properties.county)
        .attr("transform", function (d) {
          const centroid = path.centroid(d);
          return `translate(${centroid[0]},${centroid[1]})`;
        })
        .style("pointer-events", "none")
        .attr("font-size", 8)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("class", "county-names")
    );

  return mainLayer;
}

function mountInteraction(layer) {
  Libra.Interaction.build({
    inherit: "BrushInstrument",
    layers: [layer],
    sharedVar: {
      highlightColor: "red",
      deepClone: true,
    },
  });
}

main();


#####libra_d3/map_click.js:#####
// global constants
globalThis.MARGIN = { top: 0, right: 0, bottom: 0, left: 0 };
globalThis.WIDTH = 1000 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 400 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  const nc = await d3.json("./data/ncmap_pop_density_topojson.json");
  globalThis.data = topojson.feature(nc, nc.objects.ncmap).features;
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  // create layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  g = d3.select(mainLayer.getGraphic());

  // Draw the map
  const path = d3.geoPath();

  g.selectAll(".counties")
    .data(globalThis.data)
    .join("g")
    .attr("class", "counties")
    .attr("transform", `translate(${0}, ${0}) scale(${1 - 0})`)
    .call((g) =>
      g
        .append("path")
        .attr("d", path)
        .attr("fill", "#b7dbff")
        .append("title")
        .text("counties")
    )
    .call((g) =>
      g
        .append("text")
        .text((d) => d.properties.county)
        .attr("transform", function (d) {
          const centroid = path.centroid(d);
          return `translate(${centroid[0]},${centroid[1]})`;
        })
        .style("pointer-events", "none")
        .attr("font-size", 8)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("class", "county-names")
    );

  return mainLayer;
}

function mountInteraction(layer) {
  Libra.Interaction.build({
    inherit: "ClickInstrument",
    layers: [layer],
    sharedVar: {
      highlightColor: "red",
      deepClone: true,
    },
  });
}

main();


#####libra_d3/map_hover.js:#####
// global constants
globalThis.MARGIN = { top: 0, right: 0, bottom: 0, left: 0 };
globalThis.WIDTH = 1000 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 400 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  const nc = await d3.json("./data/ncmap_pop_density_topojson.json");
  globalThis.data = topojson.feature(nc, nc.objects.ncmap).features;
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  // create layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  g = d3.select(mainLayer.getGraphic());

  // Draw the map
  const path = d3.geoPath();

  g.selectAll(".counties")
    .data(globalThis.data)
    .join("g")
    .attr("class", "counties")
    .attr("transform", `translate(${0}, ${0}) scale(${1 - 0})`)
    .call((g) =>
      g
        .append("path")
        .attr("d", path)
        .attr("fill", "#b7dbff")
        .append("title")
        .text("counties")
    )
    .call((g) =>
      g
        .append("text")
        .text((d) => d.properties.county)
        .attr("transform", function (d) {
          const centroid = path.centroid(d);
          return `translate(${centroid[0]},${centroid[1]})`;
        })
        .style("pointer-events", "none")
        .attr("font-size", 8)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("class", "county-names")
    );

  return mainLayer;
}

function mountInteraction(layer) {
  Libra.Interaction.build({
    inherit: "HoverInstrument",
    layers: [layer],
    sharedVar: {
      highlightColor: "red",
      deepClone: true,
    },
  });
}

main();


#####libra_d3/map_panzoom.js:#####
// global constants
globalThis.MARGIN = { top: 0, right: 0, bottom: 0, left: 0 };
globalThis.WIDTH = 1000 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 400 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  const nc = await d3.json("./data/ncmap_pop_density_topojson.json");
  globalThis.data = topojson.feature(nc, nc.objects.ncmap).features;
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  // Add x axis
  globalThis.x = d3.scaleLinear().domain([0, 1]).range([0, 1]);

  // Add y axis
  globalThis.y = d3.scaleLinear().domain([0, 1]).range([0, 1]);
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const [mainLayer, transformer] = renderMainVisualization();
  mountInteraction(mainLayer, transformer);
}

function renderMainVisualization(scaleX = globalThis.x, scaleY = globalThis.y) {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  let g = svg.select(".main");
  let returnVal = null;
  if (g.empty()) {
    // create layer if not exists
    const mainLayer = Libra.Layer.initialize("D3Layer", {
      name: "mainLayer",
      width: globalThis.WIDTH,
      height: globalThis.HEIGHT,
      offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
      container: svg.node(),
    });
    g = d3.select(mainLayer.getGraphic());
    g.attr("class", "main");

    Libra.GraphicalTransformer.register("DrawAxesAndMarks", {
      sharedVar: {
        scaleX: globalThis.x,
        scaleY: globalThis.y,
      },
      redraw({ transformer }) {
        const scaleX = transformer.getSharedVar("scaleX");
        const scaleY = transformer.getSharedVar("scaleY");
        renderMainVisualization(scaleX, scaleY);
      },
    });

    const transformer = Libra.GraphicalTransformer.initialize(
      "DrawAxesAndMarks",
      {
        layer: mainLayer,
      }
    );

    returnVal = [mainLayer, transformer];
  }

  // Clear the layer
  g.selectChildren().remove();

  // Draw the map
  const path = d3.geoPath();

  g.selectAll(".counties")
    .data(globalThis.data)
    .join("g")
    .attr("class", "counties")
    .attr(
      "transform",
      `translate(${scaleX(0)}, ${scaleY(0)}) scale(${scaleX(1) - scaleX(0)})`
    )
    .call((g) =>
      g
        .append("path")
        .attr("d", path)
        .attr("fill", "#b7dbff")
        .append("title")
        .text("counties")
    )
    .call((g) =>
      g
        .append("text")
        .text((d) => d.properties.county)
        .attr("transform", function (d) {
          const centroid = path.centroid(d);
          return `translate(${centroid[0]},${centroid[1]})`;
        })
        .style("pointer-events", "none")
        .attr("font-size", 8)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("class", "county-names")
    );

  return returnVal;
}

function mountInteraction(layer, transformer) {
  Libra.Interaction.build({
    inherit: "PanInstrument",
    layers: [layer],
    sharedVar: {
      fixRange: true,
      scaleX: globalThis.x,
      scaleY: globalThis.y,
    },
  });

  Libra.Interaction.build({
    inherit: "GeometricZoomInstrument",
    layers: [layer],
    sharedVar: {
      fixRange: true,
      scaleX: globalThis.x,
      scaleY: globalThis.y,
    },
  });
}

main();


#####libra_d3/scatter_brush.js:#####
// global constants
globalThis.MARGIN = { top: 30, right: 70, bottom: 40, left: 60 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;
globalThis.FIELD_X = "x";
globalThis.FIELD_Y = "y";
globalThis.FIELD_COLOR = "Origin";

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;
globalThis.color = null;

const loadName = window.location.search.split('file=')[1].split('&')[0];

async function loadData() {
  globalThis.data = (await d3.json("./data/" + loadName)).filter(
    (d) => !!(d["x"] && d["y"])
  );
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  const extentX = [0, d3.max(globalThis.data, (d) => d[globalThis.FIELD_X])];
  const extentY = [0, d3.max(globalThis.data, (d) => d[globalThis.FIELD_Y])];

  // Add X axis
  globalThis.x = d3
    .scaleLinear()
    .domain(extentX)
    .range([0, globalThis.WIDTH])
    .nice()
    .clamp(true);
  svg
    .append("g")
    .attr("transform", "translate(0," + globalThis.HEIGHT + ")")
    .call(d3.axisBottom(globalThis.x))
    .append("text")
    .text(globalThis.FIELD_X)
    .attr("fill", "black")
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("x", globalThis.WIDTH / 2)
    .attr("y", 30);

  // Add Y axis
  globalThis.y = d3
    .scaleLinear()
    .domain(extentY)
    .nice()
    .range([globalThis.HEIGHT, 0])
    .clamp(true);
  svg
    .append("g")
    .call(d3.axisLeft(globalThis.y))
    .append("text")
    .text(globalThis.FIELD_Y)
    .attr("fill", "black")
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("writing-mode", "tb")
    .style(
      "transform",
      `translate(${-globalThis.MARGIN.left / 2}px,${globalThis.HEIGHT / 2
      }px) rotate(180deg)`
    );

  // Add Legend
  globalThis.color = d3
    .scaleOrdinal()
    .domain(
      new Set(globalThis.data.map((d) => d[globalThis.FIELD_COLOR])).values()
    )
    .range(d3.schemeTableau10);
  svg
    .append("g")
    .call((g) =>
      g
        .append("text")
        .text(globalThis.FIELD_COLOR)
        .attr("fill", "black")
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("font-weight", "bold")
        .attr("x", globalThis.WIDTH + globalThis.MARGIN.right / 2)
        .attr("y", -globalThis.MARGIN.top / 2)
    )
    .call((g) =>
      g
        .append("g")
        .selectAll("g")
        .data(
          new Set(
            globalThis.data.map((d) => d[globalThis.FIELD_COLOR])
          ).values()
        )
        .join("g")
        .call((g) => {
          g.append("circle")
            .attr("fill-opacity", "0")
            .attr("stroke-width", 2)
            .attr("stroke", (d) => globalThis.color(d))
            .attr("cx", globalThis.WIDTH + 10)
            .attr("cy", (_, i) => i * 20)
            .attr("r", 5);
        })
        .call((g) => {
          g.append("text")
            .text((d) => d)
            .attr("font-size", "12px")
            .attr("x", globalThis.WIDTH + 20)
            .attr("y", (_, i) => i * 20 + 5);
        })
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};


// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // Find the SVG element on page
  const svg = d3.select("#LibraPlayground svg");

  // Create the main layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  const g = d3.select(mainLayer.getGraphic());

  // Draw points code from the input static visualization
  // g.selectAll("circle")
  //   .data(globalThis.data)
  //   .join("circle")
  //   .attr("class", "mark")
  //   .attr("fill", "white")
  //   .attr("stroke-width", 1)
  //   .attr("stroke", "gray")
  //   .attr("cx", (d) => globalThis.x(d[globalThis.FIELD_X]))
  //   .attr("cy", (d) => globalThis.y(d[globalThis.FIELD_Y]))
  //   .attr("r", 5);

  g.selectAll("path")
    .data(globalThis.data)
    .join("circle")
    .attr("class", "mark")
    .attr("fill", "white")
    .attr("stroke-width", 1)
    .attr("stroke", "gray")
    .attr("cx", (d) => globalThis.x(d[globalThis.FIELD_X]))
    .attr("cy", (d) => globalThis.y(d[globalThis.FIELD_Y]))
    .attr("r", 5);

  return mainLayer;
}

function mountInteraction(layer) {
  // Attach BrushInstrument to the main layer
  Libra.Interaction.build({
    inherit: "BrushInstrument",
    layers: [layer],
    sharedVar: {
      highlightColor: (d) => globalThis.color(d[globalThis.FIELD_COLOR]),
    },
  });
}

main();


#####libra_d3/scatter_click.js:#####
// global constants
globalThis.MARGIN = { top: 30, right: 70, bottom: 40, left: 60 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;
globalThis.FIELD_X = "Horsepower";
globalThis.FIELD_Y = "Miles_per_Gallon";
globalThis.FIELD_COLOR = "Origin";

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;
globalThis.color = null;

async function loadData() {
  globalThis.data = (await d3.json("./data/cars.json")).filter(
    (d) => !!(d["Horsepower"] && d["Miles_per_Gallon"])
  );
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  const extentX = [0, d3.max(globalThis.data, (d) => d[globalThis.FIELD_X])];
  const extentY = [0, d3.max(globalThis.data, (d) => d[globalThis.FIELD_Y])];

  // Add X axis
  globalThis.x = d3
    .scaleLinear()
    .domain(extentX)
    .range([0, globalThis.WIDTH])
    .nice()
    .clamp(true);
  svg
    .append("g")
    .attr("transform", "translate(0," + globalThis.HEIGHT + ")")
    .call(d3.axisBottom(globalThis.x))
    .append("text")
    .text(globalThis.FIELD_X)
    .attr("fill", "black")
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("x", globalThis.WIDTH / 2)
    .attr("y", 30);

  // Add Y axis
  globalThis.y = d3
    .scaleLinear()
    .domain(extentY)
    .nice()
    .range([globalThis.HEIGHT, 0])
    .clamp(true);
  svg
    .append("g")
    .call(d3.axisLeft(globalThis.y))
    .append("text")
    .text(globalThis.FIELD_Y)
    .attr("fill", "black")
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("writing-mode", "tb")
    .style(
      "transform",
      `translate(${-globalThis.MARGIN.left / 2}px,${
        globalThis.HEIGHT / 2
      }px) rotate(180deg)`
    );

  // Add Legend
  globalThis.color = d3
    .scaleOrdinal()
    .domain(
      new Set(globalThis.data.map((d) => d[globalThis.FIELD_COLOR])).values()
    )
    .range(d3.schemeTableau10);
  svg
    .append("g")
    .call((g) =>
      g
        .append("text")
        .text(globalThis.FIELD_COLOR)
        .attr("fill", "black")
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("font-weight", "bold")
        .attr("x", globalThis.WIDTH + globalThis.MARGIN.right / 2)
        .attr("y", -globalThis.MARGIN.top / 2)
    )
    .call((g) =>
      g
        .append("g")
        .selectAll("g")
        .data(
          new Set(
            globalThis.data.map((d) => d[globalThis.FIELD_COLOR])
          ).values()
        )
        .join("g")
        .call((g) => {
          g.append("circle")
            .attr("fill-opacity", "0")
            .attr("stroke-width", 2)
            .attr("stroke", (d) => globalThis.color(d))
            .attr("cx", globalThis.WIDTH + 10)
            .attr("cy", (_, i) => i * 20)
            .attr("r", 5);
        })
        .call((g) => {
          g.append("text")
            .text((d) => d)
            .attr("font-size", "12px")
            .attr("x", globalThis.WIDTH + 20)
            .attr("y", (_, i) => i * 20 + 5);
        })
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // Find the SVG element on page
  const svg = d3.select("#LibraPlayground svg");

  // Create the main layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  const g = d3.select(mainLayer.getGraphic());

  // Draw points code from the input static visualization
  g.selectAll("circle")
    .data(globalThis.data)
    .join("circle")
    .attr("class", "mark")
    .attr("fill", "white")
    .attr("stroke-width", 1)
    .attr("stroke", "gray")
    .attr("cx", (d) => globalThis.x(d[globalThis.FIELD_X]))
    .attr("cy", (d) => globalThis.y(d[globalThis.FIELD_Y]))
    .attr("r", 5);

  return mainLayer;
}

function mountInteraction(layer) {
  // Attach ClickInstrument to the main layer
  Libra.Interaction.build({
    inherit: "ClickInstrument",
    layers: [layer],
    sharedVar: {
      highlightColor: (d) => globalThis.color(d[globalThis.FIELD_COLOR]),
    },
  });
}

main();


#####libra_d3/scatter_excentric_labeling.js:#####
// global constants
globalThis.MARGIN = { top: 30, right: 70, bottom: 40, left: 60 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;
globalThis.FIELD_X = "Horsepower";
globalThis.FIELD_Y = "Miles_per_Gallon";
globalThis.FIELD_COLOR = "Origin";

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;
globalThis.color = null;

async function loadData() {
  globalThis.data = (await d3.json("./data/cars.json")).filter(
    (d) => !!(d["Horsepower"] && d["Miles_per_Gallon"])
  );
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  const extentX = [0, d3.max(globalThis.data, (d) => d[globalThis.FIELD_X])];
  const extentY = [0, d3.max(globalThis.data, (d) => d[globalThis.FIELD_Y])];

  // Add X axis
  globalThis.x = d3
    .scaleLinear()
    .domain(extentX)
    .range([0, globalThis.WIDTH])
    .nice()
    .clamp(true);
  svg
    .append("g")
    .attr("transform", "translate(0," + globalThis.HEIGHT + ")")
    .call(d3.axisBottom(globalThis.x))
    .append("text")
    .text(globalThis.FIELD_X)
    .attr("fill", "black")
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("x", globalThis.WIDTH / 2)
    .attr("y", 30);

  // Add Y axis
  globalThis.y = d3
    .scaleLinear()
    .domain(extentY)
    .nice()
    .range([globalThis.HEIGHT, 0])
    .clamp(true);
  svg
    .append("g")
    .call(d3.axisLeft(globalThis.y))
    .append("text")
    .text(globalThis.FIELD_Y)
    .attr("fill", "black")
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("writing-mode", "tb")
    .style(
      "transform",
      `translate(${-globalThis.MARGIN.left / 2}px,${
        globalThis.HEIGHT / 2
      }px) rotate(180deg)`
    );

  // Add Legend
  globalThis.color = d3
    .scaleOrdinal()
    .domain(
      new Set(globalThis.data.map((d) => d[globalThis.FIELD_COLOR])).values()
    )
    .range(d3.schemeTableau10);
  svg
    .append("g")
    .call((g) =>
      g
        .append("text")
        .text(globalThis.FIELD_COLOR)
        .attr("fill", "black")
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("font-weight", "bold")
        .attr("x", globalThis.WIDTH + globalThis.MARGIN.right / 2)
        .attr("y", -globalThis.MARGIN.top / 2)
    )
    .call((g) =>
      g
        .append("g")
        .selectAll("g")
        .data(
          new Set(
            globalThis.data.map((d) => d[globalThis.FIELD_COLOR])
          ).values()
        )
        .join("g")
        .call((g) => {
          g.append("circle")
            .attr("fill-opacity", "0")
            .attr("stroke-width", 2)
            .attr("stroke", (d) => globalThis.color(d))
            .attr("cx", globalThis.WIDTH + 10)
            .attr("cy", (_, i) => i * 20)
            .attr("r", 5);
        })
        .call((g) => {
          g.append("text")
            .text((d) => d)
            .attr("font-size", "12px")
            .attr("x", globalThis.WIDTH + 20)
            .attr("y", (_, i) => i * 20 + 5);
        })
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

Libra.Interaction.build({
  inherit: "HoverInstrument",
  name: "ExcentricLabelingInstrument",
  sharedVar: {
    r: 20,
    stroke: "green",
    strokeWidth: 2,
    countLabelDistance: 20,
    fontSize: 12,
    countLabelWidth: 40,
    maxLabelsNum: 10,
    labelAccessor: (circleElem) => d3.select(circleElem).datum()["label"],
    colorAccessor: (circleElem) => d3.select(circleElem).datum()["color"],
  },
  override: [
    {
      find: "SelectionService",
      comp: "CircleSelectionService",
    },
  ],
  insert: [
    {
      find: "CircleSelectionService",
      flow: [
        {
          comp: "ExcentricLabelingLayoutService",
          resultAlias: "result",
          evaluate({
            labelAccessor,
            colorAccessor,
            r,
            maxLabelsNum,
            event,
            layer,
            result: circles,
          }) {
            if (!event) return [];
            const [layerX, layerY] = d3.pointer(event, layer.getGraphic());
            const rootBBox = layer
              .getContainerGraphic()
              .getBoundingClientRect();
            const layerBBox = layer.getGraphic().transform.baseVal.consolidate()
              ?.matrix ?? { a: 0, b: 0, c: 0, d: 0, e: 0, f: 0 };

            function getRawInfos(objs, labelAccessor, colorAccessor) {
              const rawInfos = objs.map((obj) => {
                const bbox = obj.__libra__screenElement.getBoundingClientRect();
                const x = bbox.x + (bbox.width >> 1) - rootBBox.x - layerBBox.e;
                const y =
                  bbox.y + (bbox.height >> 1) - rootBBox.y - layerBBox.f;
                const labelName = labelAccessor(obj); //d3.select(obj).datum()[labelField];
                const color = colorAccessor(obj); //colorScale(d3.select(obj).datum()[colorField]);
                return {
                  x,
                  y,
                  labelWidth: 0,
                  labelHeight: 0,
                  color,
                  labelName,
                };
              });
              return rawInfos;
            }

            function computeSizeOfLabels(rawInfos, root) {
              const tempInfoAttr = "labelText";
              const tempClass = "temp" + String(new Date().getMilliseconds());
              //const tempMountPoint = d3.create("svg:g").attr("class", tempClass);
              const tempMountPoint = root
                .append("svg:g")
                .attr("class", tempClass);
              rawInfos.forEach(
                (rawInfo) =>
                  (rawInfo[tempInfoAttr] = tempMountPoint
                    .append("text")
                    .attr("opacity", "0")
                    .attr("x", -Number.MAX_SAFE_INTEGER)
                    .attr("y", -Number.MAX_SAFE_INTEGER)
                    .text(rawInfo.labelName)
                    .node())
              );
              root.node().appendChild(tempMountPoint.node());
              rawInfos.forEach((rawInfo) => {
                const labelBBox = rawInfo[tempInfoAttr].getBBox();
                rawInfo.labelWidth = labelBBox.width;
                rawInfo.labelHeight = 21;
              });
              root.select("." + tempClass).remove();
              rawInfos.forEach((rawInfo) => delete rawInfo[tempInfoAttr]);
            }

            const rawInfos = getRawInfos(circles, labelAccessor, colorAccessor);
            computeSizeOfLabels(rawInfos, d3.select(layer.getGraphic()));
            const compute = excentricLabeling()
              .radius(r)
              .horizontallyCoherent(true)
              .maxLabelsNum(maxLabelsNum);
            const result = compute(rawInfos, layerX, layerY);
            return result;
          },
        },
        (layer) => ({
          comp: "DrawLabelTransformer",
          layer: layer.getLayerFromQueue("LabelLayer"),
          sharedVar: {
            result: [],
          },
          redraw({ layer, transformer }) {
            function renderLines(root, result) {
              const lineGroup = root
                .append("g")
                .attr("class", "exentric-labeling-line");
              const lineGenerator = d3
                .line()
                .x((d) => d.x)
                .y((d) => d.y);
              lineGroup
                .selectAll("path")
                .data(result)
                .join("path")
                .attr("fill", "none")
                .attr("stroke", (layoutInfo) => layoutInfo.rawInfo.color)
                .attr("d", (layoutInfo) =>
                  lineGenerator(layoutInfo.controlPoints)
                );
            }

            function renderBBoxs(root, result) {
              const bboxGroup = root
                .append("g")
                .attr("class", "exentric-labeling-bbox");
              bboxGroup
                .selectAll("rect")
                .data(result)
                .join("rect")
                .attr("class", "labelBBox")
                .attr("fill", "none")
                .attr("stroke", (layoutInfo) => layoutInfo.rawInfo.color)
                .attr("x", (layoutInfo) => layoutInfo.labelBBox.x)
                .attr("y", (layoutInfo) => layoutInfo.labelBBox.y)
                .attr("width", (layoutInfo) => layoutInfo.labelBBox.width)
                .attr("height", (layoutInfo) => layoutInfo.labelBBox.height);
            }

            function renderTexts(root, result) {
              const textGroup = root
                .append("g")
                .attr("class", "exentric-labeling-text");
              textGroup
                .selectAll("text")
                .data(result)
                .join("text")
                .attr("stroke", (layoutInfo) => layoutInfo.rawInfo.color)
                .attr("x", (layoutInfo) => layoutInfo.labelBBox.x)
                .attr("y", (layoutInfo) => layoutInfo.labelBBox.y)
                .attr("dominant-baseline", "hanging")
                .text((layoutInfo) => layoutInfo.rawInfo.labelName);
            }

            layer.setLayersOrder({ selectionLayer: -1 });

            const result = transformer.getSharedVar("result");
            const root = d3.select(layer.getGraphic());
            root.selectAll("*").remove();
            renderLines(root, result);
            renderBBoxs(root, result);
            renderTexts(root, result);
          },
        }),
      ],
    },
    {
      find: "CircleSelectionService",
      flow: [
        {
          comp: "AggregateService",
          resultAlias: "count",
          sharedVar: {
            ops: ["count"],
          },
        },
        (layer) => ({
          comp: "DrawTextTransformer",
          layer: layer.getLayerFromQueue("LensLayer"),
          sharedVar: {
            x: 0,
            y: 0,
            count: 0,
          },
          redraw({ layer, transformer }) {
            const cx =
              transformer.getSharedVar("x") -
              layer
                .getLayerFromQueue("mainLayer")
                .getGraphic()
                .getBoundingClientRect().left;
            const cy =
              transformer.getSharedVar("y") -
              layer
                .getLayerFromQueue("mainLayer")
                .getGraphic()
                .getBoundingClientRect().top;
            const opacity = 1;
            const lensRadius = transformer.getSharedVar("r");
            const stroke = transformer.getSharedVar("stroke");
            const strokeWidth = transformer.getSharedVar("strokeWidth");
            const count = transformer.getSharedVar("count");
            const countLabelDistance =
              transformer.getSharedVar("countLabelDistance");
            const fontSize = transformer.getSharedVar("fontSize");
            const countLabelWidth = transformer.getSharedVar("countLabelWidth");

            const root = d3.select(layer.getGraphic());
            root.selectAll("*").remove();

            const group = root
              .append("g")
              .attr("opacity", opacity)
              .attr("transform", `translate(${cx}, ${cy})`);

            group
              .append("circle")
              .attr("class", "lensCircle")
              .attr("cx", 0)
              .attr("r", lensRadius)
              .attr("fill", "none")
              .attr("stroke", stroke)
              .attr("stroke-width", strokeWidth);
            const countLabel = group
              .append("text")
              .attr("y", -(countLabelDistance + lensRadius))
              .attr("font-size", fontSize)
              .attr("text-anchor", "middle")
              .attr("fill", stroke)
              .text(count);
            const countLabelBBox = countLabel.node().getBBox();
            group
              .append("rect")
              .attr("class", "lensLabelBorder")
              .attr("stroke", stroke)
              .attr("stroke-width", strokeWidth)
              .attr("fill", "none")
              .attr("x", -countLabelWidth >> 1)
              .attr("y", countLabelBBox.y)
              .attr("width", countLabelWidth)
              .attr("height", countLabelBBox.height);
            group
              .append("line")
              .attr("stroke", stroke)
              .attr("stroke-width", strokeWidth)
              .attr("y1", -lensRadius)
              .attr("y2", countLabelBBox.y + countLabelBBox.height);
          },
        }),
      ],
    },
  ],
});

// import static visualization and global variables
const VIS = require("./staticVisualization");
// register excentricLabelingInstrument
require("./excentricLabelingInstrument");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // Find the SVG element on page
  const svg = d3.select("#LibraPlayground svg");

  // Create the main layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  const g = d3.select(mainLayer.getGraphic());

  // Draw points code from the input static visualization
  g.selectAll("circle")
    .data(globalThis.data)
    .join("circle")
    .attr("class", "mark")
    .attr("fill", "none")
    .attr("stroke-width", 1)
    .attr("stroke", (d) => globalThis.color(d[globalThis.FIELD_COLOR]))
    .attr("cx", (d) => globalThis.x(d[globalThis.FIELD_X]))
    .attr("cy", (d) => globalThis.y(d[globalThis.FIELD_Y]))
    .attr("r", 5);

  return mainLayer;
}

function mountInteraction(layer) {
  Libra.Interaction.build({
    inherit: "ExcentricLabelingInstrument",
    layers: [layer],
    sharedVar: {
      labelAccessor: (circleElem) => d3.select(circleElem).datum()["Name"],
      colorAccessor: (circleElem) =>
        globalThis.color(d3.select(circleElem).datum()[globalThis.FIELD_COLOR]),
    },
  });
}

main();


#####libra_d3/scatter_hover.js:#####
// global constants
globalThis.MARGIN = { top: 30, right: 70, bottom: 40, left: 60 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;
globalThis.FIELD_X = "x";
globalThis.FIELD_Y = "y";
globalThis.FIELD_COLOR = "Origin";

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;
globalThis.color = null;

const loadName = window.location.search.split('file=')[1].split('&')[0];

async function loadData() {
  globalThis.data = (await d3.json("./data/" + loadName)).filter(
    (d) => !!(d["x"] && d["y"])
  );
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  const extentX = [0, d3.max(globalThis.data, (d) => d[globalThis.FIELD_X])];
  const extentY = [0, d3.max(globalThis.data, (d) => d[globalThis.FIELD_Y])];

  // Add X axis
  globalThis.x = d3
    .scaleLinear()
    .domain(extentX)
    .range([0, globalThis.WIDTH])
    .nice()
    .clamp(true);
  svg
    .append("g")
    .attr("transform", "translate(0," + globalThis.HEIGHT + ")")
    .call(d3.axisBottom(globalThis.x))
    .append("text")
    .text(globalThis.FIELD_X)
    .attr("fill", "black")
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("x", globalThis.WIDTH / 2)
    .attr("y", 30);

  // Add Y axis
  globalThis.y = d3
    .scaleLinear()
    .domain(extentY)
    .nice()
    .range([globalThis.HEIGHT, 0])
    .clamp(true);
  svg
    .append("g")
    .call(d3.axisLeft(globalThis.y))
    .append("text")
    .text(globalThis.FIELD_Y)
    .attr("fill", "black")
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("writing-mode", "tb")
    .style(
      "transform",
      `translate(${-globalThis.MARGIN.left / 2}px,${globalThis.HEIGHT / 2
      }px) rotate(180deg)`
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};


// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // Find the SVG element on page
  const svg = d3.select("#LibraPlayground svg");

  // Create the main layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  const g = d3.select(mainLayer.getGraphic());

  // Draw points code from the input static visualization
  g.selectAll("circle")
    .data(globalThis.data)
    .join("circle")
    .attr("class", "mark")
    .attr("fill", "white")
    .attr("stroke-width", 1)
    .attr("stroke", "gray")
    .attr("cx", (d) => globalThis.x(d[globalThis.FIELD_X]))
    .attr("cy", (d) => globalThis.y(d[globalThis.FIELD_Y]))
    .attr("r", 5);

  return mainLayer;
}

function mountInteraction(layer) {
  // Attach HoverInstrument to the main layer
  Libra.Interaction.build({
    inherit: "HoverInstrument",
    layers: [layer],
    sharedVar: {
      highlightColor: (d) => 'red',
    },
  });
}

main();


#####libra_d3/scatter_panzoom.js:#####
// global constants
globalThis.MARGIN = { top: 30, right: 70, bottom: 40, left: 60 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;
globalThis.FIELD_X = "x";
globalThis.FIELD_Y = "y";
globalThis.FIELD_COLOR = "Origin";

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;
globalThis.color = null;

const loadName = window.location.search.split('file=')[1].split('&')[0];

async function loadData() {
  globalThis.data = (await d3.json("./data/" + loadName)).filter(
    (d) => !!(d["x"] && d["y"])
  );
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  const extentX = [0, d3.max(globalThis.data, (d) => d[globalThis.FIELD_X])];
  const extentY = [0, d3.max(globalThis.data, (d) => d[globalThis.FIELD_Y])];

  // Add clip
  svg
    .append("clipPath")
    .attr("id", "clipMainLayer")
    .append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", globalThis.WIDTH)
    .attr("height", globalThis.HEIGHT);

  // Add X scale
  globalThis.x = d3
    .scaleLinear()
    .domain(extentX)
    .range([0, globalThis.WIDTH])
    .nice()
    .clamp(false);

  // Add Y scale
  globalThis.y = d3
    .scaleLinear()
    .domain(extentY)
    .nice()
    .range([globalThis.HEIGHT, 0])
    .clamp(false);

  // Add Legend
  globalThis.color = d3
    .scaleOrdinal()
    .domain(
      new Set(globalThis.data.map((d) => d[globalThis.FIELD_COLOR])).values()
    )
    .range(d3.schemeTableau10);
  svg
    .append("g")
    .call((g) =>
      g
        .append("text")
        .text(globalThis.FIELD_COLOR)
        .attr("fill", "black")
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("font-weight", "bold")
        .attr("x", globalThis.WIDTH + globalThis.MARGIN.right / 2)
        .attr("y", -globalThis.MARGIN.top / 2)
    )
    .call((g) =>
      g
        .append("g")
        .selectAll("g")
        .data(
          new Set(
            globalThis.data.map((d) => d[globalThis.FIELD_COLOR])
          ).values()
        )
        .join("g")
        .call((g) => {
          g.append("circle")
            .attr("fill-opacity", "0")
            .attr("stroke-width", 2)
            .attr("stroke", (d) => globalThis.color(d))
            .attr("cx", globalThis.WIDTH + 10)
            .attr("cy", (_, i) => i * 20)
            .attr("r", 5);
        })
        .call((g) => {
          g.append("text")
            .text((d) => d)
            .attr("font-size", "12px")
            .attr("x", globalThis.WIDTH + 20)
            .attr("y", (_, i) => i * 20 + 5);
        })
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};


// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const [mainLayer, transformer] = renderMainVisualization();
  mountInteraction(mainLayer, transformer);
}

function renderMainVisualization(scaleX = globalThis.x, scaleY = globalThis.y) {
  // Find SVG
  const svg = d3.select("#LibraPlayground svg");

  let g = svg.select(".main");
  let returnVal = null;
  if (g.empty()) {
    // create layer if not exists
    const mainLayer = Libra.Layer.initialize("D3Layer", {
      name: "mainLayer",
      width: globalThis.WIDTH,
      height: globalThis.HEIGHT,
      offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
      container: svg.node(),
    });
    g = d3.select(mainLayer.getGraphic());
    g.attr("class", "main");

    Libra.GraphicalTransformer.register("DrawAxesAndMarks", {
      sharedVar: {
        scaleX: globalThis.x,
        scaleY: globalThis.y,
      },
      redraw({ transformer }) {
        const scaleX = transformer.getSharedVar("scaleX");
        const scaleY = transformer.getSharedVar("scaleY");
        renderMainVisualization(scaleX, scaleY);
      },
    });

    const transformer = Libra.GraphicalTransformer.initialize(
      "DrawAxesAndMarks",
      {
        layer: mainLayer,
      }
    );

    returnVal = [mainLayer, transformer];
  }

  // Clear the layer
  g.selectChildren().remove();

  // Add X axis
  g.append("g")
    .attr("transform", "translate(0," + globalThis.HEIGHT + ")")
    .call(d3.axisBottom(scaleX))
    .append("text")
    .text(globalThis.FIELD_X)
    .attr("fill", "black")
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("x", globalThis.WIDTH / 2)
    .attr("y", 30);

  // Add Y axis
  g.append("g")
    .call(d3.axisLeft(scaleY))
    .append("text")
    .text(globalThis.FIELD_Y)
    .attr("fill", "black")
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("writing-mode", "tb")
    .style(
      "transform",
      `translate(${-globalThis.MARGIN.left / 2}px,${globalThis.HEIGHT / 2
      }px) rotate(180deg)`
    );

  // Draw points code from the input static visualization
  g.append("g")
    .attr("clip-path", `url(#clipMainLayer)`)
    .selectAll("circle")
    .data(globalThis.data)
    .join("circle")
    .attr("class", "mark")
    .attr("fill", "white")
    .attr("stroke-width", 1)
    .attr("stroke", (d) => globalThis.color(d[globalThis.FIELD_COLOR]))
    .attr("cx", (d) => scaleX(d[globalThis.FIELD_X]))
    .attr("cy", (d) => scaleY(d[globalThis.FIELD_Y]))
    .attr("r", 5);

  return returnVal;
}

function mountInteraction(layer, transformer) {
  Libra.Interaction.build({
    inherit: "PanInstrument",
    layers: [layer],
    sharedVar: {
      fixRange: true,
      scaleX: globalThis.x,
      scaleY: globalThis.y,
    },
  });

  Libra.Interaction.build({
    inherit: "GeometricZoomInstrument",
    layers: [layer],
    sharedVar: {
      fixRange: true,
      scaleX: globalThis.x,
      scaleY: globalThis.y,
    },
  });
}

main();


#####libra_d3/scatter_semantic_panzoom.js:#####
// global constants
globalThis.MARGIN = { top: 30, right: 70, bottom: 40, left: 60 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;
globalThis.FIELD_X = "Horsepower";
globalThis.FIELD_Y = "Miles_per_Gallon";
globalThis.FIELD_COLOR = "Origin";

// global variables
globalThis.data = [];
globalThis.data_detail_level2 = [];
globalThis.data_detail_level1 = [];
globalThis.data_detail_level0 = [];

// shared scales
globalThis.x = null;
globalThis.y = null;
globalThis.color = null;

async function loadData() {
  const binX = (i) =>
    d3
      .bin()
      .value((d) => d[globalThis.FIELD_X])
      .thresholds(i);
  const binY = (i) =>
    d3
      .bin()
      .value((d) => d[globalThis.FIELD_Y])
      .thresholds(i);

  const binXY = (data, i) => binX(i)(data).map(binY(i));
  const mergeXY = (xList) =>
    xList.flatMap((yList) =>
      yList.flatMap((xyList) => {
        const collection = {};
        xyList.forEach((datum) => {
          if (!collection[datum[globalThis.FIELD_COLOR]]) {
            collection[datum[globalThis.FIELD_COLOR]] = [];
          }
          collection[datum[globalThis.FIELD_COLOR]].push(datum);
        });
        return Object.values(collection).map((arr) =>
          arr.reduce(
            (p, c, _, a) => ({
              [globalThis.FIELD_X]:
                p[globalThis.FIELD_X] + c[globalThis.FIELD_X] / a.length,
              [globalThis.FIELD_Y]:
                p[globalThis.FIELD_Y] + c[globalThis.FIELD_Y] / a.length,
              [globalThis.FIELD_COLOR]: c[globalThis.FIELD_COLOR],
              count: p.count + c.count,
            }),
            {
              [globalThis.FIELD_X]: 0,
              [globalThis.FIELD_Y]: 0,
              count: 0,
            }
          )
        );
      })
    );

  globalThis.data = (await d3.json("./data/cars.json")).filter(
    (d) => !!(d["Horsepower"] && d["Miles_per_Gallon"])
  );
  globalThis.data_detail_level0 = globalThis.data.map((x) => ({
    ...x,
    count: 1,
  }));
  globalThis.data_detail_level1 = mergeXY(
    binXY(globalThis.data_detail_level0, 10)
  );
  globalThis.data_detail_level2 = mergeXY(
    binXY(globalThis.data_detail_level1, 8)
  );
  globalThis.data_detail_level3 = mergeXY(
    binXY(globalThis.data_detail_level2, 6)
  );
  globalThis.data_detail_level4 = mergeXY(
    binXY(globalThis.data_detail_level3, 4)
  );
  globalThis.data_detail_level5 = mergeXY(
    binXY(globalThis.data_detail_level4, 2)
  );
  globalThis.data_detail_level6 = mergeXY(
    binXY(globalThis.data_detail_level5, 1)
  );
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  const extentX = [0, d3.max(globalThis.data, (d) => d[globalThis.FIELD_X])];
  const extentY = [0, d3.max(globalThis.data, (d) => d[globalThis.FIELD_Y])];

  // Add clip
  svg
    .append("clipPath")
    .attr("id", "clipMainLayer")
    .append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", globalThis.WIDTH)
    .attr("height", globalThis.HEIGHT);

  // Add X scale
  globalThis.x = d3
    .scaleLinear()
    .domain(extentX)
    .range([0, globalThis.WIDTH])
    .nice()
    .clamp(false);

  // Add Y scale
  globalThis.y = d3
    .scaleLinear()
    .domain(extentY)
    .nice()
    .range([globalThis.HEIGHT, 0])
    .clamp(false);

  // Add Legend
  globalThis.color = d3
    .scaleOrdinal()
    .domain(
      new Set(globalThis.data.map((d) => d[globalThis.FIELD_COLOR])).values()
    )
    .range(d3.schemeTableau10);
  svg
    .append("g")
    .call((g) =>
      g
        .append("text")
        .text(globalThis.FIELD_COLOR)
        .attr("fill", "black")
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("font-weight", "bold")
        .attr("x", globalThis.WIDTH + globalThis.MARGIN.right / 2)
        .attr("y", -globalThis.MARGIN.top / 2)
    )
    .call((g) =>
      g
        .append("g")
        .selectAll("g")
        .data(
          new Set(
            globalThis.data.map((d) => d[globalThis.FIELD_COLOR])
          ).values()
        )
        .join("g")
        .call((g) => {
          g.append("circle")
            .attr("fill-opacity", "0")
            .attr("stroke-width", 2)
            .attr("stroke", (d) => globalThis.color(d))
            .attr("cx", globalThis.WIDTH + 10)
            .attr("cy", (_, i) => i * 20)
            .attr("r", 5);
        })
        .call((g) => {
          g.append("text")
            .text((d) => d)
            .attr("font-size", "12px")
            .attr("x", globalThis.WIDTH + 20)
            .attr("y", (_, i) => i * 20 + 5);
        })
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const [mainLayer, transformer] = renderMainVisualization();
  mountInteraction(mainLayer, transformer);
}

function renderMainVisualization(
  scaleX = globalThis.x,
  scaleY = globalThis.y,
  data = globalThis.data_detail_level1
) {
  // Find SVG
  const svg = d3.select("#LibraPlayground svg");

  let g = svg.select(".main");
  let returnVal = null;
  if (g.empty()) {
    // create layer if not exists
    const mainLayer = Libra.Layer.initialize("D3Layer", {
      name: "mainLayer",
      width: globalThis.WIDTH,
      height: globalThis.HEIGHT,
      offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
      container: svg.node(),
    });
    g = d3.select(mainLayer.getGraphic());
    g.attr("class", "main");

    Libra.GraphicalTransformer.register("DrawAxesAndMarks", {
      sharedVar: {
        scaleX: globalThis.x,
        scaleY: globalThis.y,
      },
      redraw({ transformer }) {
        const scaleX = transformer.getSharedVar("scaleX");
        const scaleY = transformer.getSharedVar("scaleY");
        const data = transformer.getSharedVar("data");
        renderMainVisualization(scaleX, scaleY, data);
      },
    });

    const transformer = Libra.GraphicalTransformer.initialize(
      "DrawAxesAndMarks",
      {
        layer: mainLayer,
      }
    );

    returnVal = [mainLayer, transformer];
  }

  // Clear the layer
  g.selectChildren().remove();

  // Add X axis
  g.append("g")
    .attr("transform", "translate(0," + globalThis.HEIGHT + ")")
    .call(d3.axisBottom(scaleX))
    .append("text")
    .text(globalThis.FIELD_X)
    .attr("fill", "black")
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("x", globalThis.WIDTH / 2)
    .attr("y", 30);

  // Add Y axis
  g.append("g")
    .call(d3.axisLeft(scaleY))
    .append("text")
    .text(globalThis.FIELD_Y)
    .attr("fill", "black")
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .attr("writing-mode", "tb")
    .style(
      "transform",
      `translate(${-globalThis.MARGIN.left / 2}px,${
        globalThis.HEIGHT / 2
      }px) rotate(180deg)`
    );

  // Draw points code from the input static visualization
  g.append("g")
    .attr("clip-path", `url(#clipMainLayer)`)
    .selectAll("g")
    .data(data)
    .join("g")
    .attr("class", "mark")
    .call((g) =>
      g
        .append("circle")
        .attr("fill", "white")
        .attr("stroke-width", 1)
        .attr("stroke", (d) => globalThis.color(d[globalThis.FIELD_COLOR]))
        .attr("cx", (d) => scaleX(d[globalThis.FIELD_X]))
        .attr("cy", (d) => scaleY(d[globalThis.FIELD_Y]))
        .attr("r", (d) => (d.count ?? 0) + 5)
    )
    .call((g) =>
      g
        .append("text")
        .attr("fill", (d) => globalThis.color(d[globalThis.FIELD_COLOR]))
        .attr("x", (d) => scaleX(d[globalThis.FIELD_X]) - 6)
        .attr("y", (d) => scaleY(d[globalThis.FIELD_Y]) + 6)
        .text((d) => ((d.count ?? 1) > 1 ? d.count : ""))
    );

  return returnVal;
}

function mountInteraction(layer, transformer) {
  Libra.Interaction.build({
    inherit: "PanInstrument",
    layers: [layer],
    sharedVar: {
      fixRange: true,
      scaleX: globalThis.x,
      scaleY: globalThis.y,
    },
  });

  Libra.Interaction.build({
    inherit: "SemanticZoomInstrument",
    layers: [layer],
    sharedVar: {
      scaleLevels: {
        3: { data: globalThis.data_detail_level0 },
        0: { data: globalThis.data_detail_level1 },
        "-3": { data: globalThis.data_detail_level2 },
        "-6": { data: globalThis.data_detail_level3 },
        "-9": { data: globalThis.data_detail_level4 },
        "-12": { data: globalThis.data_detail_level5 },
        "-15": { data: globalThis.data_detail_level6 },
      },
      fixRange: true,
      scaleX: globalThis.x,
      scaleY: globalThis.y,
    },
  });
}

main();


#####libra_d3/splom_brush.js:#####


#####libra_d3/timeseries_overviewdetail.js:#####
// global constants
globalThis.MARGIN = { top: 30, right: 10, bottom: 50, left: 70 };
globalThis.WIDTH = 764 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 532 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  globalThis.data = (await d3.json("./data/stocks/stocks2.json")).map((d) => ({
    date: d3.timeParse("%b %d %Y")(d.date),
    price: +d.price,
  }));
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr(
      "viewbox",
      `0 0 ${globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
      } ${globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom}`
    )
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  // Add X axis
  globalThis.x = d3
    .scaleUtc()
    .domain(d3.extent(globalThis.data, (d) => d.date))
    .range([0, globalThis.WIDTH]);

  // Add Y axis
  globalThis.yOverview = d3
    .scaleLinear()
    .domain([0, d3.max(globalThis.data, (d) => d.price)])
    .range([globalThis.HEIGHT * 0.3, 0]);

  globalThis.yDetail = d3
    .scaleLinear()
    .domain([0, d3.max(globalThis.data, (d) => d.price)])
    .range([globalThis.HEIGHT * 0.6, 0]);
}

module.exports = {
  loadData,
  renderStaticVisualization,
};


// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const [overviewLayer, detailLayer] = renderMainVisualization();
  mountInteraction(overviewLayer, detailLayer);
}

function renderMainVisualization() {
  // Find the SVG element on page
  const svg = d3.select("#LibraPlayground svg");

  // Create the main layer
  const overviewLayer = Libra.Layer.initialize("D3Layer", {
    name: "overviewLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT * 0.3,
    offset: {
      x: globalThis.MARGIN.left,
      y: globalThis.MARGIN.top + globalThis.HEIGHT * 0.7,
    },
    container: svg.node(),
  });
  g = d3.select(overviewLayer.getGraphic()).attr("class", "overview");

  const detailLayer = Libra.Layer.initialize("D3Layer", {
    name: "detailLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT * 0.6,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  d3.select(detailLayer.getGraphic()).attr("class", "detail");

  g.append("g")
    .call(d3.axisBottom(globalThis.x))
    .attr("transform", "translate(0," + globalThis.HEIGHT * 0.3 + ")");
  g.append("g").call(d3.axisLeft(globalThis.yOverview));
  g.append("g")
    .append("path")
    .attr("fill", "steelblue")
    .attr(
      "d",
      d3
        .area()
        .x((d) => globalThis.x(d.date))
        .y0(globalThis.yOverview(0))
        .y1((d) => globalThis.yOverview(d.price))(globalThis.data)
    );

  renderDetailView();

  return [overviewLayer, detailLayer];
}

function renderDetailView(scaleX = globalThis.x) {
  const g = d3.select(".detail");
  g.selectChildren().remove();

  g.append("g")
    .call(d3.axisBottom(scaleX))
    .attr("transform", "translate(0," + globalThis.HEIGHT * 0.6 + ")");
  g.append("g").call(d3.axisLeft(globalThis.yDetail));
  g.append("g")
    .append("path")
    .attr("fill", "steelblue")
    .attr(
      "d",
      d3
        .area()
        .x((d) => scaleX(d.date))
        .y0(globalThis.yDetail(0))
        .y1((d) => globalThis.yDetail(d.price))(globalThis.data)
    );
}

function mountInteraction(overviewLayer, detailLayer) {
  // Initialize Detail Transformer
  const detailTransformer = Libra.GraphicalTransformer.initialize(
    "DetailTransformer",
    {
      layer: detailLayer,
      sharedVar: {
        result: globalThis.x,
      },
      redraw({ transformer }) {
        const scaleX = transformer.getSharedVar("result");
        renderDetailView(scaleX);
      },
    }
  );

  // Attach BrushInstrument to the overview layer
  Libra.Interaction.build({
    inherit: "BrushXInstrument",
    layers: [overviewLayer],
    insert: [
      {
        find: "SelectionService",
        flow: [{ comp: "ScaleService" }, detailTransformer],
      },
    ],
    sharedVar: { scaleX: globalThis.x },
  });
}

main();


#####libra_d3/treemap_brush.js:#####
// global constants
globalThis.MARGIN = { top: 0, right: 0, bottom: 0, left: 0 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  globalThis.data = await d3.json("./data/flare-2.json");

  globalThis.dataRoot = d3
    .hierarchy(globalThis.data)
    .sum(function (d) {
      return d.value;
    })
    .sort((a, b) => b.height - a.height || b.value - a.value);

  globalThis.dataRoot.children.map((node, index) => (node.groupId = index));

  d3.treemap().size([globalThis.WIDTH, globalThis.HEIGHT]).padding(0.5)(
    globalThis.dataRoot
  );

  globalThis.data_detail_level1 = [globalThis.dataRoot].flatMap(
    (node) => node.children || [node]
  );
  globalThis.data_detail_level2 = globalThis.data_detail_level1.flatMap(
    (node) => node.children || [node]
  );
  globalThis.data_detail_level3 = globalThis.data_detail_level2.flatMap(
    (node) => node.children || [node]
  );
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  // create layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  g = d3.select(mainLayer.getGraphic());

  // Draw the treemap
  g.selectAll(".block")
    .data(globalThis.data_detail_level1)
    .join("g")
    .attr("class", "block")
    .call((g) =>
      g
        .append("rect")
        .attr("fill", "blue")
        .attr("x", function (d) {
          return d.x0;
        })
        .attr("y", function (d) {
          return d.y0;
        })
        .attr("width", function (d) {
          return d.x1 - d.x0;
        })
        .attr("height", function (d) {
          return d.y1 - d.y0;
        })
    )
    .call((g) =>
      g
        .append("text")
        .attr("x", function (d) {
          return d.x0 + 5;
        }) // +10 to adjust position (more right)
        .attr("y", function (d) {
          return d.y0 + 20;
        }) // +20 to adjust position (lower)
        .text(function (d) {
          return d.data.name;
        })
        .attr("font-size", "15px")
        .attr("fill", "white")
    );

  return mainLayer;
}

function mountInteraction(layer) {
  Libra.Interaction.build({
    inherit: "BrushInstrument",
    layers: [layer],
    sharedVar: {
      highlightColor: "red",
      deepClone: true,
    },
  });
}

main();


#####libra_d3/treemap_click.js:#####
// global constants
globalThis.MARGIN = { top: 0, right: 0, bottom: 0, left: 0 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  globalThis.data = await d3.json("./data/flare-2.json");

  globalThis.dataRoot = d3
    .hierarchy(globalThis.data)
    .sum(function (d) {
      return d.value;
    })
    .sort((a, b) => b.height - a.height || b.value - a.value);

  globalThis.dataRoot.children.map((node, index) => (node.groupId = index));

  d3.treemap().size([globalThis.WIDTH, globalThis.HEIGHT]).padding(0.5)(
    globalThis.dataRoot
  );

  globalThis.data_detail_level1 = [globalThis.dataRoot].flatMap(
    (node) => node.children || [node]
  );
  globalThis.data_detail_level2 = globalThis.data_detail_level1.flatMap(
    (node) => node.children || [node]
  );
  globalThis.data_detail_level3 = globalThis.data_detail_level2.flatMap(
    (node) => node.children || [node]
  );
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  // create layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  g = d3.select(mainLayer.getGraphic());

  // Draw the treemap
  g.selectAll(".block")
    .data(globalThis.data_detail_level1)
    .join("g")
    .attr("class", "block")
    .call((g) =>
      g
        .append("rect")
        .attr("fill", "blue")
        .attr("x", function (d) {
          return d.x0;
        })
        .attr("y", function (d) {
          return d.y0;
        })
        .attr("width", function (d) {
          return d.x1 - d.x0;
        })
        .attr("height", function (d) {
          return d.y1 - d.y0;
        })
    )
    .call((g) =>
      g
        .append("text")
        .attr("x", function (d) {
          return d.x0 + 5;
        }) // +10 to adjust position (more right)
        .attr("y", function (d) {
          return d.y0 + 20;
        }) // +20 to adjust position (lower)
        .text(function (d) {
          return d.data.name;
        })
        .attr("font-size", "15px")
        .attr("fill", "white")
    );

  return mainLayer;
}

function mountInteraction(layer) {
  Libra.Interaction.build({
    inherit: "ClickInstrument",
    layers: [layer],
    sharedVar: {
      highlightColor: "red",
      deepClone: true,
    },
  });
}

main();


#####libra_d3/treemap_excentric_labeling.js:#####
// global constants
globalThis.MARGIN = { top: 0, right: 0, bottom: 0, left: 0 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  globalThis.data = await d3.json("./data/flare-2.json");

  globalThis.dataRoot = d3
    .hierarchy(globalThis.data)
    .sum(function (d) {
      return d.value;
    })
    .sort((a, b) => b.height - a.height || b.value - a.value);

  globalThis.dataRoot.children.map((node, index) => (node.groupId = index));

  d3.treemap().size([globalThis.WIDTH, globalThis.HEIGHT]).padding(0.5)(
    globalThis.dataRoot
  );

  globalThis.data_detail_level1 = [globalThis.dataRoot].flatMap(
    (node) => node.children || [node]
  );
  globalThis.data_detail_level2 = globalThis.data_detail_level1.flatMap(
    (node) =>
      node.children?.map((x) => ({ ...x, groupId: node.groupId })) ?? [node]
  );
  globalThis.data_detail_level3 = globalThis.data_detail_level2.flatMap(
    (node) =>
      node.children?.map((x) => ({ ...x, groupId: node.groupId })) ?? [node]
  );
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  globalThis.color = d3
    .scaleOrdinal()
    .domain(globalThis.dataRoot.children.map((node) => node.groupId))
    .range(d3.schemeTableau10);
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

Libra.Interaction.build({
  inherit: "HoverInstrument",
  name: "ExcentricLabelingInstrument",
  sharedVar: {
    r: 20,
    stroke: "green",
    strokeWidth: 2,
    countLabelDistance: 20,
    fontSize: 12,
    countLabelWidth: 40,
    maxLabelsNum: 10,
    labelAccessor: (circleElem) => d3.select(circleElem).datum()["label"],
    colorAccessor: (circleElem) => d3.select(circleElem).datum()["color"],
  },
  override: [
    {
      find: "SelectionService",
      comp: "CircleSelectionService",
    },
  ],
  insert: [
    {
      find: "CircleSelectionService",
      flow: [
        {
          comp: "ExcentricLabelingLayoutService",
          resultAlias: "result",
          evaluate({
            labelAccessor,
            colorAccessor,
            r,
            maxLabelsNum,
            event,
            layer,
            result: circles,
          }) {
            if (!event) return [];
            const [layerX, layerY] = d3.pointer(event, layer.getGraphic());
            const rootBBox = layer
              .getContainerGraphic()
              .getBoundingClientRect();
            const layerBBox = layer.getGraphic().transform.baseVal.consolidate()
              ?.matrix ?? { a: 0, b: 0, c: 0, d: 0, e: 0, f: 0 };

            function getRawInfos(objs, labelAccessor, colorAccessor) {
              const rawInfos = objs.map((obj) => {
                const bbox = obj.__libra__screenElement.getBoundingClientRect();
                const x = bbox.x + (bbox.width >> 1) - rootBBox.x - layerBBox.e;
                const y =
                  bbox.y + (bbox.height >> 1) - rootBBox.y - layerBBox.f;
                const labelName = labelAccessor(obj); //d3.select(obj).datum()[labelField];
                const color = colorAccessor(obj); //colorScale(d3.select(obj).datum()[colorField]);
                return {
                  x,
                  y,
                  labelWidth: 0,
                  labelHeight: 0,
                  color,
                  labelName,
                };
              });
              return rawInfos;
            }

            function computeSizeOfLabels(rawInfos, root) {
              const tempInfoAttr = "labelText";
              const tempClass = "temp" + String(new Date().getMilliseconds());
              //const tempMountPoint = d3.create("svg:g").attr("class", tempClass);
              const tempMountPoint = root
                .append("svg:g")
                .attr("class", tempClass);
              rawInfos.forEach(
                (rawInfo) =>
                (rawInfo[tempInfoAttr] = tempMountPoint
                  .append("text")
                  .attr("opacity", "0")
                  .attr("x", -Number.MAX_SAFE_INTEGER)
                  .attr("y", -Number.MAX_SAFE_INTEGER)
                  .text(rawInfo.labelName)
                  .node())
              );
              root.node().appendChild(tempMountPoint.node());
              rawInfos.forEach((rawInfo) => {
                const labelBBox = rawInfo[tempInfoAttr].getBBox();
                rawInfo.labelWidth = labelBBox.width;
                rawInfo.labelHeight = 21;
              });
              root.select("." + tempClass).remove();
              rawInfos.forEach((rawInfo) => delete rawInfo[tempInfoAttr]);
            }

            const rawInfos = getRawInfos(circles, labelAccessor, colorAccessor);
            computeSizeOfLabels(rawInfos, d3.select(layer.getGraphic()));
            const compute = excentricLabeling()
              .radius(r)
              .horizontallyCoherent(true)
              .maxLabelsNum(maxLabelsNum);
            const result = compute(rawInfos, layerX, layerY);
            return result;
          },
        },
        (layer) => ({
          comp: "DrawLabelTransformer",
          layer: layer.getLayerFromQueue("LabelLayer"),
          sharedVar: {
            result: [],
          },
          redraw({ layer, transformer }) {
            function renderLines(root, result) {
              const lineGroup = root
                .append("g")
                .attr("class", "exentric-labeling-line");
              const lineGenerator = d3
                .line()
                .x((d) => d.x)
                .y((d) => d.y);
              lineGroup
                .selectAll("path")
                .data(result)
                .join("path")
                .attr("fill", "none")
                .attr("stroke", (layoutInfo) => layoutInfo.rawInfo.color)
                .attr("d", (layoutInfo) =>
                  lineGenerator(layoutInfo.controlPoints)
                );
            }

            function renderBBoxs(root, result) {
              const bboxGroup = root
                .append("g")
                .attr("class", "exentric-labeling-bbox");
              bboxGroup
                .selectAll("rect")
                .data(result)
                .join("rect")
                .attr("class", "labelBBox")
                .attr("fill", "none")
                .attr("stroke", (layoutInfo) => layoutInfo.rawInfo.color)
                .attr("x", (layoutInfo) => layoutInfo.labelBBox.x)
                .attr("y", (layoutInfo) => layoutInfo.labelBBox.y)
                .attr("width", (layoutInfo) => layoutInfo.labelBBox.width)
                .attr("height", (layoutInfo) => layoutInfo.labelBBox.height);
            }

            function renderTexts(root, result) {
              const textGroup = root
                .append("g")
                .attr("class", "exentric-labeling-text");
              textGroup
                .selectAll("text")
                .data(result)
                .join("text")
                .attr("stroke", (layoutInfo) => layoutInfo.rawInfo.color)
                .attr("x", (layoutInfo) => layoutInfo.labelBBox.x)
                .attr("y", (layoutInfo) => layoutInfo.labelBBox.y)
                .attr("dominant-baseline", "hanging")
                .text((layoutInfo) => layoutInfo.rawInfo.labelName);
            }

            layer.setLayersOrder({ selectionLayer: -1 });

            const result = transformer.getSharedVar("result");
            const root = d3.select(layer.getGraphic());
            root.selectAll("*").remove();
            renderLines(root, result);
            renderBBoxs(root, result);
            renderTexts(root, result);
          },
        }),
      ],
    },
    {
      find: "CircleSelectionService",
      flow: [
        {
          comp: "AggregateService",
          resultAlias: "count",
          sharedVar: {
            ops: ["count"],
          },
        },
        (layer) => ({
          comp: "DrawTextTransformer",
          layer: layer.getLayerFromQueue("LensLayer"),
          sharedVar: {
            x: 0,
            y: 0,
            count: 0,
          },
          redraw({ layer, transformer }) {
            const cx =
              transformer.getSharedVar("x") -
              layer
                .getLayerFromQueue("mainLayer")
                .getGraphic()
                .getBoundingClientRect().left;
            const cy =
              transformer.getSharedVar("y") -
              layer
                .getLayerFromQueue("mainLayer")
                .getGraphic()
                .getBoundingClientRect().top;
            const opacity = 1;
            const lensRadius = transformer.getSharedVar("r");
            const stroke = transformer.getSharedVar("stroke");
            const strokeWidth = transformer.getSharedVar("strokeWidth");
            const count = transformer.getSharedVar("count");
            const countLabelDistance =
              transformer.getSharedVar("countLabelDistance");
            const fontSize = transformer.getSharedVar("fontSize");
            const countLabelWidth = transformer.getSharedVar("countLabelWidth");

            const root = d3.select(layer.getGraphic());
            root.selectAll("*").remove();

            const group = root
              .append("g")
              .attr("opacity", opacity)
              .attr("transform", `translate(${cx}, ${cy})`);

            group
              .append("circle")
              .attr("class", "lensCircle")
              .attr("cx", 0)
              .attr("r", lensRadius)
              .attr("fill", "none")
              .attr("stroke", stroke)
              .attr("stroke-width", strokeWidth);
            const countLabel = group
              .append("text")
              .attr("y", -(countLabelDistance + lensRadius))
              .attr("font-size", fontSize)
              .attr("text-anchor", "middle")
              .attr("fill", stroke)
              .text(count);
            const countLabelBBox = countLabel.node().getBBox();
            group
              .append("rect")
              .attr("class", "lensLabelBorder")
              .attr("stroke", stroke)
              .attr("stroke-width", strokeWidth)
              .attr("fill", "none")
              .attr("x", -countLabelWidth >> 1)
              .attr("y", countLabelBBox.y)
              .attr("width", countLabelWidth)
              .attr("height", countLabelBBox.height);
            group
              .append("line")
              .attr("stroke", stroke)
              .attr("stroke-width", strokeWidth)
              .attr("y1", -lensRadius)
              .attr("y2", countLabelBBox.y + countLabelBBox.height);
          },
        }),
      ],
    },
  ],
});

// import static visualization and global variables
const VIS = require("./staticVisualization");
// register excentricLabelingInstrument
require("./excentricLabelingInstrument");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // Find the SVG element on page
  const svg = d3.select("#LibraPlayground svg");

  // Create the main layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  g = d3.select(mainLayer.getGraphic());

  // Draw the treemap
  g.selectAll(".block")
    .data(globalThis.data_detail_level3)
    .join("g")
    .attr("class", "block")
    .append("rect")
    .attr("fill", (d) => globalThis.color(d.groupId))
    .attr("x", function (d) {
      return d.x0;
    })
    .attr("y", function (d) {
      return d.y0;
    })
    .attr("width", function (d) {
      return d.x1 - d.x0;
    })
    .attr("height", function (d) {
      return d.y1 - d.y0;
    });

  return mainLayer;
}

function mountInteraction(layer) {
  Libra.Interaction.build({
    inherit: "ExcentricLabelingInstrument",
    layers: [layer],
    sharedVar: {
      stroke: "black",
      labelAccessor: (elem) => d3.select(elem).datum().data.name,
      colorAccessor: () => "black",
    },
  });
}

main();


#####libra_d3/treemap_hover.js:#####
// global constants
globalThis.MARGIN = { top: 0, right: 0, bottom: 0, left: 0 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  globalThis.data = await d3.json("./data/flare-2.json");

  globalThis.dataRoot = d3
    .hierarchy(globalThis.data)
    .sum(function (d) {
      return d.value;
    })
    .sort((a, b) => b.height - a.height || b.value - a.value);

  globalThis.dataRoot.children.map((node, index) => (node.groupId = index));

  d3.treemap().size([globalThis.WIDTH, globalThis.HEIGHT]).padding(0.5)(
    globalThis.dataRoot
  );

  globalThis.data_detail_level1 = [globalThis.dataRoot].flatMap(
    (node) => node.children || [node]
  );
  globalThis.data_detail_level2 = globalThis.data_detail_level1.flatMap(
    (node) => node.children || [node]
  );
  globalThis.data_detail_level3 = globalThis.data_detail_level2.flatMap(
    (node) => node.children || [node]
  );
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  // create layer
  const mainLayer = Libra.Layer.initialize("D3Layer", {
    name: "mainLayer",
    width: globalThis.WIDTH,
    height: globalThis.HEIGHT,
    offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
    container: svg.node(),
  });
  g = d3.select(mainLayer.getGraphic());

  // Draw the treemap
  g.selectAll(".block")
    .data(globalThis.data_detail_level1)
    .join("g")
    .attr("class", "block")
    .call((g) =>
      g
        .append("rect")
        .attr("fill", "blue")
        .attr("x", function (d) {
          return d.x0;
        })
        .attr("y", function (d) {
          return d.y0;
        })
        .attr("width", function (d) {
          return d.x1 - d.x0;
        })
        .attr("height", function (d) {
          return d.y1 - d.y0;
        })
    )
    .call((g) =>
      g
        .append("text")
        .attr("x", function (d) {
          return d.x0 + 5;
        }) // +10 to adjust position (more right)
        .attr("y", function (d) {
          return d.y0 + 20;
        }) // +20 to adjust position (lower)
        .text(function (d) {
          return d.data.name;
        })
        .attr("font-size", "15px")
        .attr("fill", "white")
    );

  return mainLayer;
}

function mountInteraction(layer) {
  Libra.Interaction.build({
    inherit: "HoverInstrument",
    layers: [layer],
    sharedVar: {
      highlightColor: "red",
      deepClone: true,
    },
  });
}

main();


#####libra_d3/treemap_panzoom.js:#####
// global constants
globalThis.MARGIN = { top: 0, right: 0, bottom: 0, left: 0 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  globalThis.data = await d3.json("./data/flare-2.json");

  globalThis.dataRoot = d3
    .hierarchy(globalThis.data)
    .sum(function (d) {
      return d.value;
    })
    .sort((a, b) => b.height - a.height || b.value - a.value);

  globalThis.dataRoot.children.map((node, index) => (node.groupId = index));

  d3.treemap().size([globalThis.WIDTH, globalThis.HEIGHT]).padding(0.5)(
    globalThis.dataRoot
  );

  globalThis.data_detail_level1 = [globalThis.dataRoot].flatMap(
    (node) => node.children || [node]
  );
  globalThis.data_detail_level2 = globalThis.data_detail_level1.flatMap(
    (node) => node.children || [node]
  );
  globalThis.data_detail_level3 = globalThis.data_detail_level2.flatMap(
    (node) => node.children || [node]
  );
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  // Add x axis
  globalThis.x = d3.scaleLinear().domain([0, 1]).range([0, 1]);

  // Add y axis
  globalThis.y = d3.scaleLinear().domain([0, 1]).range([0, 1]);
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const [layer, transformer] = renderMainVisualization();
  mountInteraction(layer, transformer);
}

function renderMainVisualization(scaleX = globalThis.x, scaleY = globalThis.y) {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  let g = svg.select(".main");
  let returnVal = null;
  if (g.empty()) {
    // create layer if not exists
    const mainLayer = Libra.Layer.initialize("D3Layer", {
      name: "mainLayer",
      width: globalThis.WIDTH,
      height: globalThis.HEIGHT,
      offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
      container: svg.node(),
    });
    g = d3.select(mainLayer.getGraphic());
    g.attr("class", "main");

    Libra.GraphicalTransformer.register("DrawAxesAndMarks", {
      sharedVar: {
        scaleX: globalThis.x,
        scaleY: globalThis.y,
      },
      redraw({ transformer }) {
        const scaleX = transformer.getSharedVar("scaleX");
        const scaleY = transformer.getSharedVar("scaleY");
        renderMainVisualization(scaleX, scaleY);
      },
    });

    const transformer = Libra.GraphicalTransformer.initialize(
      "DrawAxesAndMarks",
      {
        layer: mainLayer,
      }
    );

    returnVal = [mainLayer, transformer];
  }

  // Clear the layer
  g.selectChildren().remove();

  // Draw the treemap
  g.selectAll(".block")
    .data(globalThis.data_detail_level1)
    .join("g")
    .attr("class", "block")
    .call((g) =>
      g
        .append("rect")
        .attr("fill", "blue")
        .attr("x", function (d) {
          return scaleX(d.x0);
        })
        .attr("y", function (d) {
          return scaleY(d.y0);
        })
        .attr("width", function (d) {
          return scaleX(d.x1) - scaleX(d.x0);
        })
        .attr("height", function (d) {
          return scaleY(d.y1) - scaleY(d.y0);
        })
    )
    .call((g) =>
      g
        .append("text")
        .attr("x", function (d) {
          return scaleX(d.x0) + 5;
        }) // +10 to adjust position (more right)
        .attr("y", function (d) {
          return scaleY(d.y0) + 20;
        }) // +20 to adjust position (lower)
        .text(function (d) {
          return d.data.name;
        })
        .attr("font-size", "15px")
        .attr("fill", "white")
    );

  return returnVal;
}

function mountInteraction(layer, transformer) {
  Libra.Interaction.build({
    inherit: "PanInstrument",
    layers: [layer],
    sharedVar: {
      fixRange: true,
      scaleX: globalThis.x,
      scaleY: globalThis.y,
    },
  });

  Libra.Interaction.build({
    inherit: "GeometricZoomInstrument",
    layers: [layer],
    sharedVar: {
      fixRange: true,
      scaleX: globalThis.x,
      scaleY: globalThis.y,
    },
  });
}

main();


#####libra_d3/treemap_semantic_panzoom.js:#####
// global constants
globalThis.MARGIN = { top: 0, right: 0, bottom: 0, left: 0 };
globalThis.WIDTH = 500 - globalThis.MARGIN.left - globalThis.MARGIN.right;
globalThis.HEIGHT = 380 - globalThis.MARGIN.top - globalThis.MARGIN.bottom;

// global variables
globalThis.data = [];

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  globalThis.data = await d3.json("./data/flare-2.json");

  globalThis.dataRoot = d3
    .hierarchy(globalThis.data)
    .sum(function (d) {
      return d.value;
    })
    .sort((a, b) => b.height - a.height || b.value - a.value);

  globalThis.dataRoot.children.map((node, index) => (node.groupId = index));

  d3.treemap().size([globalThis.WIDTH, globalThis.HEIGHT]).padding(0.5)(
    globalThis.dataRoot
  );

  globalThis.data_detail_level1 = [globalThis.dataRoot].flatMap(
    (node) => node.children || [node]
  );
  globalThis.data_detail_level2 = globalThis.data_detail_level1.flatMap(
    (node) => node.children || [node]
  );
  globalThis.data_detail_level3 = globalThis.data_detail_level2.flatMap(
    (node) => node.children || [node]
  );
}

function renderStaticVisualization() {
  // append the svg object to the body of the page
  const svg = d3
    .select("#LibraPlayground")
    .append("svg")
    .attr(
      "width",
      globalThis.WIDTH + globalThis.MARGIN.left + globalThis.MARGIN.right
    )
    .attr(
      "height",
      globalThis.HEIGHT + globalThis.MARGIN.top + globalThis.MARGIN.bottom
    )
    .attr("viewbox", `0 0 ${globalThis.WIDTH} ${globalThis.HEIGHT}`)
    .append("g")
    .attr(
      "transform",
      "translate(" + globalThis.MARGIN.left + "," + globalThis.MARGIN.top + ")"
    );

  // Add x axis
  globalThis.x = d3.scaleLinear().domain([0, 1]).range([0, 1]);

  // Add y axis
  globalThis.y = d3.scaleLinear().domain([0, 1]).range([0, 1]);
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  VIS.renderStaticVisualization();
  const [layer, transformer] = renderMainVisualization();
  mountInteraction(layer, transformer);
}

function renderMainVisualization(
  scaleX = globalThis.x,
  scaleY = globalThis.y,
  data = globalThis.data_detail_level1
) {
  // append the svg object to the body of the page
  const svg = d3.select("#LibraPlayground svg");

  let g = svg.select(".main");
  let returnVal = null;
  if (g.empty()) {
    // create layer if not exists
    const mainLayer = Libra.Layer.initialize("D3Layer", {
      name: "mainLayer",
      width: globalThis.WIDTH,
      height: globalThis.HEIGHT,
      offset: { x: globalThis.MARGIN.left, y: globalThis.MARGIN.top },
      container: svg.node(),
    });
    g = d3.select(mainLayer.getGraphic());
    g.attr("class", "main");

    Libra.GraphicalTransformer.register("DrawAxesAndMarks", {
      sharedVar: {
        scaleX: globalThis.x,
        scaleY: globalThis.y,
        data: globalThis.data_detail_level1,
      },
      redraw({ transformer }) {
        const scaleX = transformer.getSharedVar("scaleX");
        const scaleY = transformer.getSharedVar("scaleY");
        const data = transformer.getSharedVar("data");
        renderMainVisualization(scaleX, scaleY, data);
      },
    });

    const transformer = Libra.GraphicalTransformer.initialize(
      "DrawAxesAndMarks",
      {
        layer: mainLayer,
      }
    );

    returnVal = [mainLayer, transformer];
  }

  // Clear the layer
  g.selectChildren().remove();

  // Draw the treemap
  g.selectAll(".block")
    .data(data)
    .join("g")
    .attr("class", "block")
    .call((g) =>
      g
        .append("rect")
        .attr("fill", "blue")
        .attr("x", function (d) {
          return scaleX(d.x0);
        })
        .attr("y", function (d) {
          return scaleY(d.y0);
        })
        .attr("width", function (d) {
          return scaleX(d.x1) - scaleX(d.x0);
        })
        .attr("height", function (d) {
          return scaleY(d.y1) - scaleY(d.y0);
        })
    )
    .call((g) =>
      g
        .append("text")
        .attr("x", function (d) {
          return scaleX(d.x0) + 5;
        }) // +10 to adjust position (more right)
        .attr("y", function (d) {
          return scaleY(d.y0) + 20;
        }) // +20 to adjust position (lower)
        .text(function (d) {
          return d.data.name;
        })
        .attr("font-size", "15px")
        .attr("fill", "white")
    );

  return returnVal;
}

function mountInteraction(layer, transformer) {
  Libra.Interaction.build({
    inherit: "PanInstrument",
    layers: [layer],
    sharedVar: {
      fixRange: true,
      scaleX: globalThis.x,
      scaleY: globalThis.y,
    },
  });

  Libra.Interaction.build({
    inherit: "SemanticZoomInstrument",
    layers: [layer],
    sharedVar: {
      scaleLevels: {
        0: { data: globalThis.data_detail_level1 },
        3: { data: globalThis.data_detail_level2 },
        6: { data: globalThis.data_detail_level3 },
      },
      fixRange: true,
      scaleX: globalThis.x,
      scaleY: globalThis.y,
    },
  });
}

main();


#####libra_d3/zoomable_circle_packing.js:#####


#####libra_vega/bar_brush.js:#####


#####libra_vega/bar_click.js:#####


#####libra_vega/bar_hover.js:#####


#####libra_vega/bar_panzoom.js:#####


#####libra_vega/dimpvis.js:#####
// global constants
globalThis.START_YEAR = 1980;

// global variables
globalThis.data = [];
globalThis.year = globalThis.START_YEAR;
globalThis.vegaSpec = {};
globalThis.vegaView = null;

// shared scales
globalThis.x = null;
globalThis.y = null;

async function loadData() {
  //Read the data
  globalThis.data = await d3.json("./data/gapminder.json");
  globalThis.interpolatedData = globalThis.data.filter(
    (x) => x.year === globalThis.year
  );

  globalThis.vegaSpec = {
    $schema: "https://vega.github.io/schema/vega/v5.json",
    description:
      "An interactive scatter plot of global health statistics by country and year.",
    width: 800,
    height: 600,
    padding: 5,

    data: [
      {
        name: "gapminder",
        values: globalThis.data,
      },
      {
        name: "interpolatedData",
        values: globalThis.interpolatedData,
      },
      {
        name: "year",
        values: [globalThis.year],
      },
      {
        name: "clusters",
        values: [
          { id: 0, name: "South Asia" },
          { id: 1, name: "Europe & Central Asia" },
          { id: 2, name: "Sub-Saharan Africa" },
          { id: 3, name: "America" },
          { id: 4, name: "East Asia & Pacific" },
          { id: 5, name: "Middle East & North Africa" },
        ],
      },
    ],

    scales: [
      {
        name: "x",
        type: "linear",
        nice: true,
        domain: { data: "gapminder", field: "fertility" },
        range: "width",
      },
      {
        name: "y",
        type: "linear",
        nice: true,
        zero: false,
        domain: { data: "gapminder", field: "life_expect" },
        range: "height",
      },
      {
        name: "color",
        type: "ordinal",
        domain: { data: "gapminder", field: "cluster" },
        range: "category",
      },
      {
        name: "label",
        type: "ordinal",
        domain: { data: "clusters", field: "id" },
        range: { data: "clusters", field: "name" },
      },
    ],

    axes: [
      {
        title: "Fertility",
        orient: "bottom",
        scale: "x",
        grid: true,
        tickCount: 5,
      },
      {
        title: "Life Expectancy",
        orient: "left",
        scale: "y",
        grid: true,
        tickCount: 5,
      },
    ],

    legends: [
      {
        fill: "color",
        title: "Region",
        orient: "right",
        encode: {
          symbols: {
            enter: {
              fillOpacity: { value: 0.5 },
            },
          },
          labels: {
            update: {
              text: { scale: "label", field: "value" },
            },
          },
        },
      },
    ],

    marks: [
      {
        type: "text",
        encode: {
          update: {
            text: { signal: "data('year')[0].data" },
            x: { value: 300 },
            y: { value: 300 },
            fill: { value: "grey" },
            fillOpacity: { value: 0.25 },
            fontSize: { value: 100 },
          },
        },
      },
      {
        name: "point",
        type: "symbol",
        from: { data: "interpolatedData" },
        encode: {
          enter: {
            fill: { scale: "color", field: "cluster" },
            size: { value: 150 },
          },
          update: {
            x: { scale: "x", field: "fertility" },
            y: { scale: "y", field: "life_expect" },
            fillOpacity: { value: 0.5 },
          },
        },
      },
    ],
  };
}

async function renderStaticVisualization() {
  // render vega spec on screen
  const { view } = await vega(
    document.getElementById("LibraPlayground"),
    globalThis.vegaSpec
  );

  globalThis.vegaView = view;
  globalThis.x = view.scale("x");
  globalThis.y = view.scale("y");
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  await VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // Create the main layer
  const mainLayer = Libra.Layer.initialize("VegaLayer", {
    name: "mainLayer",
    group: "point",
    container: document.querySelector("#LibraPlayground svg"),
  });

  return mainLayer;
}

function mountInteraction(layer) {
  // Register TraceTransformer
  Libra.GraphicalTransformer.register("TraceTransformer", {
    redraw: function ({ layer }) {
      const data = this.getSharedVar("result");
      if (data) {
        // Draw the trace
        const transientLayer = layer.getLayerFromQueue("transientLayer");
        d3.select(transientLayer.getGraphic()).selectAll("*").remove();
        d3.select(transientLayer.getGraphic())
          .append("g")
          .attr("class", "trace")
          .attr(
            "transform",
            `translate(${layer._offset.x}, ${layer._offset.y})`
          )
          .call((g) => {
            g.append("path")
              .attr(
                "d",
                d3.line(
                  (d) => globalThis.x(d.fertility),
                  (d) => globalThis.y(d.life_expect)
                )(data)
              )
              .attr("fill", "none")
              .attr("stroke", "#bbb")
              .attr("stroke-width", 3)
              .attr("stroke-opacity", 0.5);
          })
          .call((g) => {
            g.selectAll("text")
              .data(data)
              .enter()
              .append("text")
              .attr("fill", "#555")
              .attr("fill-opacity", 0.6)
              .attr("font-size", 12)
              .attr("x", (d) => globalThis.x(d.fertility))
              .attr("y", (d) => globalThis.y(d.life_expect))
              .text((d) => d.year);
          });
      }
    },
  });

  Libra.GraphicalTransformer.register("MainTransformer", {
    async redraw({ transformer }) {
      const result = transformer.getSharedVar("result");
      if (result) {
        globalThis.interpolatedData = result;
        globalThis.vegaView.data("interpolatedData", result);
        globalThis.vegaView.data("year", result[0].year);
        await globalThis.vegaView.runAsync(); // Wait for rendering to avoid memory
      }
    },
  });

  const useTraceTransformerFlow = {
    find: "SelectionService",
    flow: [
      {
        comp: "FilterService",
        sharedVar: {
          data: globalThis.data,
          fields: ["country"],
        },
      },
      {
        comp: "TraceTransformer",
      },
    ],
  };

  const useCountryFlow = {
    find: "SelectionService",
    flow: [
      {
        comp: "TextTransformer",
        layer: layer.getLayerFromQueue("countryLayer"),
        sharedVar: {
          field: "country",
          position: (d) =>
            globalThis.interpolatedData
              .filter((dd) => dd.country == d.country)
              .map((d) => ({
                x: globalThis.x(d.fertility),
                y: globalThis.y(d.life_expect),
              }))[0],
        },
      },
    ],
  };

  Libra.Interaction.build({
    inherit: "HoverInstrument",
    layers: [layer],
    remove: [{ find: "SelectionTransformer" }],
    insert: [useTraceTransformerFlow, useCountryFlow],
  });

  Libra.Interaction.build({
    inherit: "DragInstrument",
    layers: [layer],
    remove: [{ find: "SelectionTransformer" }],
    insert: [
      useTraceTransformerFlow,
      useCountryFlow,
      {
        find: "SelectionService",
        flow: [
          {
            comp: "NearestPointService",
            sharedVar: { layer: layer.getLayerFromQueue("transientLayer") },
            evaluate(options) {
              const { layer, offsetx, offsety } = options;
              const point = [offsetx, offsety];
              if (layer && offsetx && offsety) {
                const year = d3
                  .select(layer.getGraphic())
                  .select(".trace")
                  .selectAll("text")
                  .data();
                const trace = d3
                  .select(layer.getGraphic())
                  .select("path")
                  .attr("d");
                const poly = trace
                  .slice(1)
                  .split("L")
                  .map((pStr) => pStr.split(",").map((num) => parseFloat(num)));
                return {
                  data: year,
                  interpolatedNum: interpolateNNPointFromPoly(
                    [point[0] - layer._offset.x, point[1] - layer._offset.y],
                    poly
                  ),
                };
              }
              return null;
            },
          },
          {
            comp: "InterpolationService",
            sharedVar: {
              data: globalThis.data,
              field: "year",
              formula: {
                year: (d) => Math.floor(d.year / 5) * 5, // Year divisible by 5
              },
            },
          },
          {
            comp: "MainTransformer",
          },
        ],
      },
    ],
  });
}

function interpolateNNPointFromPoly(point, polyline) {
  // Find the squared distance between two points
  function distanceSquared(p1, p2) {
    let dx = p1[0] - p2[0];
    let dy = p1[1] - p2[1];
    return dx * dx + dy * dy;
  }

  // Find the closest point on a polyline from a given point
  let minDistance = Number.MAX_VALUE;
  let interpolationFactor = 0;
  for (let i = 0; i < polyline.length - 1; i++) {
    let lineStart = polyline[i];
    let lineEnd = polyline[i + 1];
    let lineLengthSquared = distanceSquared(lineStart, lineEnd);
    let u =
      ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +
        (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /
      lineLengthSquared;
    let closest = null;
    if (u < 0) {
      closest = lineStart;
    } else if (u > 1) {
      closest = lineEnd;
    } else {
      closest = [
        lineStart[0] + u * (lineEnd[0] - lineStart[0]),
        lineStart[1] + u * (lineEnd[1] - lineStart[1]),
      ];
    }
    let distance = distanceSquared(point, closest);
    if (distance < minDistance) {
      minDistance = distance;
      if (u < 0) {
        interpolationFactor = i;
      } else if (u > 1) {
        interpolationFactor = i + 1;
      } else {
        interpolationFactor = i + u;
      }
    }
  }
  return interpolationFactor;
}

main();


#####libra_vega/dust_magnet.js:#####


#####libra_vega/edge_bundling.js:#####
// global variables
globalThis.vegaSpec = {};

async function loadData() {
  globalThis.vegaSpec = {
    "$schema": "https://vega.github.io/schema/vega/v5.json",
    "description": "A network diagram of software dependencies, with edges grouped via hierarchical edge bundling.",
    "padding": 5,
    "width": 720,
    "height": 720,
    "autosize": "none",
    "signals": [
      {
        "name": "tension",
        "value": 0.85,
        "bind": {"input": "range", "min": 0, "max": 1, "step": 0.01}
      },
      {
        "name": "radius",
        "value": 280,
        "bind": {"input": "range", "min": 20, "max": 400}
      },
      {
        "name": "extent",
        "value": 360,
        "bind": {"input": "range", "min": 0, "max": 360, "step": 1}
      },
      {
        "name": "rotate",
        "value": 0,
        "bind": {"input": "range", "min": 0, "max": 360, "step": 1}
      },
      {
        "name": "textSize",
        "value": 8,
        "bind": {"input": "range", "min": 2, "max": 20, "step": 1}
      },
      {
        "name": "textOffset",
        "value": 2,
        "bind": {"input": "range", "min": 0, "max": 10, "step": 1}
      },
      {
        "name": "layout",
        "value": "cluster",
        "bind": {"input": "radio", "options": ["tidy", "cluster"]}
      },
      {"name": "colorIn", "value": "firebrick"},
      {"name": "colorOut", "value": "forestgreen"},
      {"name": "originX", "update": "width / 2"},
      {"name": "originY", "update": "height / 2"},
      {
        "name": "active",
        "value": null,
        "on": [
          {"events": "text:mouseover", "update": "datum.id"},
          {"events": "mouseover[!event.item]", "update": "null"}
        ]
      }
    ],
    "data": [
      {
        "name": "tree",
        "url": "data/flare.json",
        "transform": [
          {"type": "stratify", "key": "id", "parentKey": "parent"},
          {
            "type": "tree",
            "method": {"signal": "layout"},
            "size": [1, 1],
            "as": ["alpha", "beta", "depth", "children"]
          },
          {
            "type": "formula",
            "expr": "(rotate + extent * datum.alpha + 270) % 360",
            "as": "angle"
          },
          {
            "type": "formula",
            "expr": "inrange(datum.angle, [90, 270])",
            "as": "leftside"
          },
          {
            "type": "formula",
            "expr": "originX + radius * datum.beta * cos(PI * datum.angle / 180)",
            "as": "x"
          },
          {
            "type": "formula",
            "expr": "originY + radius * datum.beta * sin(PI * datum.angle / 180)",
            "as": "y"
          }
        ]
      },
      {
        "name": "leaves",
        "source": "tree",
        "transform": [{"type": "filter", "expr": "!datum.children"}]
      },
      {
        "name": "dependencies",
        "url": "data/flare-dependencies.json",
        "transform": [
          {
            "type": "formula",
            "expr": "treePath('tree', datum.source, datum.target)",
            "as": "treepath",
            "initonly": true
          }
        ]
      },
      {
        "name": "selected",
        "source": "dependencies",
        "transform": [
          {
            "type": "filter",
            "expr": "datum.source === active || datum.target === active"
          }
        ]
      }
    ],
    "marks": [
      {
        name: "texts",
        "type": "text",
        "from": {"data": "leaves"},
        "encode": {
          "enter": {"text": {"field": "name"}, "baseline": {"value": "middle"}},
          "update": {
            "x": {"field": "x"},
            "y": {"field": "y"},
            "dx": {"signal": "textOffset * (datum.leftside ? -1 : 1)"},
            "angle": {
              "signal": "datum.leftside ? datum.angle - 180 : datum.angle"
            },
            "align": {"signal": "datum.leftside ? 'right' : 'left'"},
            "fontSize": {"signal": "textSize"},
            "fontWeight": [
              {"value": null}
            ]
          }
        }
      },
      {
        "type": "group",
        name:"curves",
        "from": {
          "facet": {"name": "path", "data": "dependencies", "field": "treepath"}
        },
        "marks": [
          {
            "type": "line",
            "interactive": false,
            "from": {"data": "path"},
            "encode": {
              "enter": {
                "interpolate": {"value": "bundle"},
                "strokeWidth": {"value": 1.5}
              },
              "update": {
                "stroke": [
                 
                  {"value": "steelblue"}
                ],
                "strokeOpacity": [
                 
                  {"value": 0.2}
                ],
                "tension": {"signal": "tension"},
                "x": {"field": "x"},
                "y": {"field": "y"}
              }
            }
          }
        ]
      }
    ],
    "scales": [
      {
        "name": "color",
        "type": "ordinal",
        "domain": ["depends on", "imported by"],
        "range": [{"signal": "colorIn"}, {"signal": "colorOut"}]
      }
    ],
    "legends": [
      {
        "stroke": "color",
        "orient": "bottom-right",
        "title": "Dependencies",
        "symbolType": "stroke"
      }
    ],
    "config": {}
  };
}

async function renderStaticVisualization() {
  // render vega spec on screen
  await vega(document.getElementById("LibraPlayground"), globalThis.vegaSpec);
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  await VIS.renderStaticVisualization();
  const [mainLayer, curveLayer] = renderMainVisualization();
  console.log(mainLayer);
  console.log(curveLayer);
  mountInteraction(mainLayer, curveLayer);
}

function renderMainVisualization() {
  // Create the main layer
  const mainLayer = Libra.Layer.initialize("VegaLayer", {
    name: "mainLayer",
    group: "texts",
    container: document.querySelector("#LibraPlayground svg"),
  });
  const curveLayer = Libra.Layer.initialize("VegaLayer", {
    name: "curveLayer",
    group: "curves",
    container: document.querySelector("#LibraPlayground svg"),
  });
  return [mainLayer, curveLayer];
}

function mountInteraction(textLayer, curveLayer) {

  Libra.GraphicalTransformer.register("renderTransformer", {
    layer: curveLayer,
    // transient: true,
    redraw: function ({ layer, transformer }) {
      const result = transformer.getSharedVar("result");
      console.log(result);
      if (result) {
        result.greenCurve.forEach(c => {
          c.children[1].firstChild.firstChild.setAttribute('stroke', 'green')
          c.children[1].firstChild.firstChild.setAttribute('stroke-opacity', '1')
        })
        result.redCurve.forEach(c => {
          c.children[1].firstChild.firstChild.setAttribute('stroke', 'red')
          c.children[1].firstChild.firstChild.setAttribute('stroke-opacity', '1')
        })
        result.greenText.forEach(c => {
          c.setAttribute('fill', 'green')
        })
        result.redText.forEach(c => {
          c.setAttribute('fill', 'red')
        })
      }

    },
  });


  // Attach BrushInstrument to the main layer
  Libra.Interaction.build({
    inherit: "HoverInstrument",
    layers: [textLayer],
    remove: [{ find: "SelectionTransformer" }],
    insert: [
      {
        find: "SelectionService",
        flow: [
          {
            comp: "hierarchyAnalyseService",
            evaluate({
              result,
            }) {
              if (result.length) {
                let analyseResult = {
                  greenText: [],
                  redText: [],
                  greenCurve: [],
                  redCurve: [],
                  onHover: result[0],
                }

                Array.from(curveLayer._graphic.children).forEach(d => {
                  if (d.__data__.datum.source == result[0].__data__.datum.id) {
                    analyseResult.greenCurve.push(d)
                    Array.from(textLayer._graphic.children).forEach(t => {
                      if (t.__data__.datum.id == d.__data__.datum.target) {
                        console.log(t.__data__.datum.id + "==" + d.__data__.datum.target);
                        analyseResult.greenText.push(t)
                      }
                    })
                  }
                  else if (d.__data__.datum.target == result[0].__data__.datum.id) {
                    analyseResult.redCurve.push(d)
                    Array.from(textLayer._graphic.children).forEach(t => {
                      if (t.__data__.datum.id == d.__data__.datum.source) {
                        console.log(t.__data__.datum.id + "==" + d.__data__.datum.source);
                        analyseResult.redText.push(t)
                      }
                    })
                  }
                })
                return analyseResult;
              }
            },
          },
          {
            comp: "renderTransformer"
          }
        ],
      }
    ],
  });
}

main();


#####libra_vega/force_directed_layout.js:#####
// global variables
globalThis.vegaSpec = {};

async function loadData() {
  globalThis.vegaSpec = {
    "$schema": "https://vega.github.io/schema/vega/v5.json",
    "description": "A node-link diagram with force-directed layout, depicting character co-occurrence in the novel Les Misrables.",
    "width": 600,
    "height": 600,
    "padding": 0,
    "autosize": "none",
    "signals": [
      { "name": "cx", "update": "width / 2" },
      { "name": "cy", "update": "height / 2" },
      {
        "name": "nodeRadius",
        "value": 8,
        "bind": { "input": "range", "min": 1, "max": 50, "step": 1 }
      },
      {
        "name": "nodeCharge",
        "value": -30,
        "bind": { "input": "range", "min": -100, "max": 10, "step": 1 }
      },
      {
        "name": "linkDistance",
        "value": 30,
        "bind": { "input": "range", "min": 5, "max": 100, "step": 1 }
      },

      {
        "description": "Graph node most recently interacted with.",
        "name": "node",
        "value": null
      }
    ],
    "data": [
      {
        "name": "node-data",
        "url": "data/miserables2.json",
        "format": { "type": "json", "property": "nodes" }
      },
      {
        "name": "link-data",
        "url": "data/miserables2.json",
        "format": { "type": "json", "property": "links" }
      }
    ],
    "scales": [
      {
        "name": "color",
        "type": "ordinal",
        "domain": { "data": "node-data", "field": "group" },
        "range": { "scheme": "category20c" }
      }
    ],
    "marks": [
      {
        "name": "nodes",
        "type": "symbol",
        "zindex": 1,
        "from": { "data": "node-data" },

        "encode": {
          "enter": {
            "x": { "value": 300 },
            "y": { "value": 300 },
            "fill": { "scale": "color", "field": "group" },
            "stroke": { "value": "white" }
          },
          "update": {
            "size": { "signal": "2 * nodeRadius * nodeRadius" },
            "cursor": { "value": "pointer" }
          }
        },

      },
      {
        "name": "links",
        "type": "path",
        "from": { "data": "link-data" },
        "interactive": false,
        "encode": {
          "update": { "stroke": { "value": "#ccc" }, "strokeWidth": { "value": 0.5 } },
        },


      }
    ],
    "config": {}
  };
}

async function renderStaticVisualization() {
  // render vega spec on screen
  await vega(document.getElementById("LibraPlayground"), globalThis.vegaSpec);
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  await VIS.renderStaticVisualization();
  const [nodeLayer, linkLayer] = renderMainVisualization();
  mountInteraction(nodeLayer, linkLayer);
}

function renderMainVisualization() {
  //   Create the main layer
  const nodeLayer = Libra.Layer.initialize("VegaLayer", {
    name: "nodeLayer",
    group: "nodes",
    container: document.querySelector("#LibraPlayground svg"),
  });
  Array.from(nodeLayer._graphic.children).forEach(n => {
    n.__data__.datum.forceX = 0;
    n.__data__.datum.forceY = 0;
    n.__data__.datum.velocityX = 0;
    n.__data__.datum.velocityY = 0;
  })

  const linkLayer = Libra.Layer.initialize("VegaLayer", {
    name: "linkLayer",
    group: "links",
    container: document.querySelector("#LibraPlayground svg"),
  });

  return [nodeLayer, linkLayer];
}

function mountInteraction(nodeLayer, linkLayer) {

  globalThis.simulationParam = {
    nodeMassive: 1,
    dampingCoefficient: 0.97,
    coulombConstant: 1000,
    nodeMinDis: 10,
    springConstant: 1000,
    restLength: 100,
    oneFrameDuration: 0.001,
    frameNum: 1000,
    frameRemain: this.frameNum,
  }

  Libra.GraphicalTransformer.register("nodeLinkTransformer", {
    layer: [nodeLayer, linkLayer],
    // transient: true,
    redraw: function ({ layer, transformer }) {
      cancelAnimationFrame(globalThis.tickUpdate);
      globalThis.simulationParam.frameRemain = globalThis.simulationParam.frameNum;
      function drawFrame() {

        drawNodes(nodeLayer);
        drawLinks(linkLayer, nodeLayer);
        Array.from(nodeLayer._graphic.children).forEach(n => {
          n.__data__.datum.forceX = 0;
          n.__data__.datum.forceY = 0;
        })
        repulsionSimulation(Array.from(nodeLayer._graphic.children));
        springSimulation(Array.from(linkLayer._graphic.children));
        updateLocationByForce(nodeLayer);
        drawNodes(nodeLayer);
        drawLinks(linkLayer, nodeLayer);

        if (globalThis.simulationParam.frameRemain > 0) {
          globalThis.tickUpdate = requestAnimationFrame(drawFrame)
          globalThis.simulationParam.frameRemain--;
        }
      }

      globalThis.tickUpdate = requestAnimationFrame(drawFrame)

    },
  });


  // Attach BrushInstrument to the main layer
  Libra.Interaction.build({
    inherit: "DragInstrument",
    layers: [nodeLayer],
    remove: [{ find: "SelectionTransformer" }],
    insert: [
      {
        find: "SelectionService",
        flow: [
          {
            comp: "nodeDragService",
            evaluate({
              result, offsetx, offsety
            }) {
              if (result.length) {
                console.log(offsetx);
                result[0].__data__.x = offsetx
                result[0].__data__.y = offsety
              }
            },
          },
          {
            comp: "nodeLinkTransformer"
          }
        ],
      }
    ],
  });
}

main();

function updateLocationByForce(layer, duration = globalThis.simulationParam.oneFrameDuration) {
  const massive = globalThis.simulationParam.nodeMassive;
  const damp = globalThis.simulationParam.dampingCoefficient;

  Array.from(layer._graphic.children).forEach(d => {
    //F=ma
    d.__data__.datum.accelerationX = d.__data__.datum.forceX / massive;
    d.__data__.datum.accelerationY = d.__data__.datum.forceY / massive;
    //damp velocity
    d.__data__.datum.velocityX *= damp;
    d.__data__.datum.velocityY *= damp;
    //v=v0+at
    d.__data__.datum.velocityX += d.__data__.datum.accelerationX * duration;
    d.__data__.datum.velocityY += d.__data__.datum.accelerationY * duration;
    //d=vt
    d.__data__.x += d.__data__.datum.velocityX * duration;
    d.__data__.y += d.__data__.datum.velocityY * duration;

  })
}

function drawNodes(layer) {
  Array.from(layer._graphic.children).forEach(n => {
    n.setAttribute("transform", `translate(${n.__data__.x},${n.__data__.y})`)
  })
}
function drawLinks(linkLayer, nodeLayer) {
  Array.from(linkLayer._graphic.children).forEach(l => {
    if (!l.getAttribute("d")) {
      const source = l.__data__.datum.source;
      const target = l.__data__.datum.target;
      Array.from(nodeLayer._graphic.children).forEach(n => {
        if (n.__data__.datum.index == source) {
          l.__data__.datum.sourceNode = n;
        } else if (n.__data__.datum.index == target) {
          l.__data__.datum.targetNode = n;
        }
      })
    }
    const source = l.__data__.datum.sourceNode;
    const target = l.__data__.datum.targetNode;
    l.setAttribute("d", `M${source.__data__.x} ${source.__data__.y} L${target.__data__.x} ${target.__data__.y}`)
  })
}

function repulsionSimulation(nodeList) {
  nodeList.forEach((node, nodeIndex) => {
    nodeList.forEach((otherNode, otherNodeIndex) => {
      if (otherNodeIndex > nodeIndex) {
        const force = calculateRepulsionForce(
          {
            x: node.__data__.x,
            y: node.__data__.y,
          },
          {
            x: otherNode.__data__.x,
            y: otherNode.__data__.y
          }
        );

        node.__data__.datum.forceX -= force.x;
        node.__data__.datum.forceY -= force.y;

        otherNode.__data__.datum.forceX += force.x;
        otherNode.__data__.datum.forceY += force.y;
      }
    })
  })
}

function springSimulation(linkList) {
  linkList.forEach(link => {
    const force = calculateSpringForce(
      {
        x: link.__data__.datum.sourceNode.__data__.x,
        y: link.__data__.datum.sourceNode.__data__.y,
      },
      {
        x: link.__data__.datum.targetNode.__data__.x,
        y: link.__data__.datum.targetNode.__data__.y,
      }
    )

    link.__data__.datum.sourceNode.__data__.datum.forceX -= force.x
    link.__data__.datum.sourceNode.__data__.datum.forceY -= force.y

    link.__data__.datum.targetNode.__data__.datum.forceX += force.x
    link.__data__.datum.targetNode.__data__.datum.forceY += force.y
  })
}

// console.log(calculateRepulsionForce({x:0,y:0},{x:1,y:1}));
function calculateRepulsionForce(node1, node2) {
  const k = globalThis.simulationParam.coulombConstant;
  const distanceX = node2.x - node1.x;
  const distanceY = node2.y - node1.y;
  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
  if (distance == 0) {
    return { x: Math.random(), y: Math.random() }
  }

  const minDistance = globalThis.simulationParam.nodeMinDis;

  if (distance < minDistance) {
    const overlap = minDistance - distance;
    const repulsionForce = k * Math.pow(overlap, 2);

    const forceX = repulsionForce * (distanceX / distance);
    const forceY = repulsionForce * (distanceY / distance);

    return { x: forceX, y: forceY };
  } else {
    const repulsionForce = k / Math.pow(distance, 2);

    const forceX = repulsionForce * (distanceX / distance);
    const forceY = repulsionForce * (distanceY / distance);

    return { x: forceX, y: forceY };
  }

}

// console.log(calculateSpringForce({x:0,y:0},{x:100,y:100}));
function calculateSpringForce(node1, node2) {
  const springConstant = globalThis.simulationParam.springConstant;
  const restLength = globalThis.simulationParam.restLength;
  const x1 = node1.x;
  const y1 = node1.y;
  const x2 = node2.x;
  const y2 = node2.y;

  const dx = x2 - x1;
  const dy = y2 - y1;

  const distance = Math.sqrt(dx * dx + dy * dy);
  if (distance == 0) {
    return { x: 0, y: 0 }
  }
  const force = -springConstant * (distance - restLength);
  const forceHorizontal = force * (dx / distance);
  const forceVertical = force * (dy / distance);

  return { x: forceHorizontal, y: forceVertical };
}

#####libra_vega/helper_line.js:#####


#####libra_vega/index_chart.js:#####


#####libra_vega/map_brush.js:#####


#####libra_vega/map_click.js:#####


#####libra_vega/map_hover.js:#####


#####libra_vega/map_panzoom.js:#####


#####libra_vega/scatter_brush.js:#####
// global variables
globalThis.vegaSpec = {};

async function loadData() {
  globalThis.vegaSpec = {
    $schema: "https://vega.github.io/schema/vega/v5.json",
    description:
      "A basic scatter plot example depicting automobile statistics.",
    width: 200,
    height: 200,
    padding: 5,

    data: [
      {
        name: "source",
        url: "data/cars.json",
        transform: [
          {
            type: "filter",
            expr: "datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null",
          },
        ],
      },
    ],

    scales: [
      {
        name: "x",
        type: "linear",
        round: true,
        nice: true,
        zero: true,
        domain: { data: "source", field: "Horsepower" },
        range: "width",
      },
      {
        name: "y",
        type: "linear",
        round: true,
        nice: true,
        zero: true,
        domain: { data: "source", field: "Miles_per_Gallon" },
        range: "height",
      },
      {
        name: "size",
        type: "linear",
        round: true,
        nice: false,
        zero: true,
        domain: { data: "source", field: "Acceleration" },
        range: [4, 361],
      },
    ],

    axes: [
      {
        scale: "x",
        grid: true,
        domain: false,
        orient: "bottom",
        tickCount: 5,
        title: "Horsepower",
      },
      {
        scale: "y",
        grid: true,
        domain: false,
        orient: "left",
        titlePadding: 5,
        title: "Miles_per_Gallon",
      },
    ],

    legends: [
      {
        size: "size",
        title: "Acceleration",
        format: "s",
        symbolStrokeColor: "#4682b4",
        symbolStrokeWidth: 2,
        symbolOpacity: 0.5,
        symbolType: "circle",
      },
    ],

    marks: [
      {
        name: "marks",
        type: "symbol",
        from: { data: "source" },
        encode: {
          update: {
            x: { scale: "x", field: "Horsepower" },
            y: { scale: "y", field: "Miles_per_Gallon" },
            size: { scale: "size", field: "Acceleration" },
            shape: { value: "circle" },
            strokeWidth: { value: 2 },
            opacity: { value: 0.5 },
            stroke: { value: "#4682b4" },
            fill: { value: "transparent" },
          },
        },
      },
    ],
  };
}

async function renderStaticVisualization() {
  // render vega spec on screen
  await vega(document.getElementById("LibraPlayground"), globalThis.vegaSpec);
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  await VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // Create the main layer
  const mainLayer = Libra.Layer.initialize("VegaLayer", {
    name: "mainLayer",
    group: "marks",
    container: document.querySelector("#LibraPlayground svg"),
  });

  return mainLayer;
}

function mountInteraction(layer) {
  // Attach BrushInstrument to the main layer
  Libra.Interaction.build({
    inherit: "BrushInstrument",
    layers: [layer],
    sharedVar: {
      highlightAttrValues: { stroke: "red" },
    },
  });
}

main();


#####libra_vega/scatter_click.js:#####
// global variables
globalThis.vegaSpec = {};

async function loadData() {
  globalThis.vegaSpec = {
    $schema: "https://vega.github.io/schema/vega/v5.json",
    description:
      "A basic scatter plot example depicting automobile statistics.",
    width: 200,
    height: 200,
    padding: 5,

    data: [
      {
        name: "source",
        url: "data/cars.json",
        transform: [
          {
            type: "filter",
            expr: "datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null",
          },
        ],
      },
    ],

    scales: [
      {
        name: "x",
        type: "linear",
        round: true,
        nice: true,
        zero: true,
        domain: { data: "source", field: "Horsepower" },
        range: "width",
      },
      {
        name: "y",
        type: "linear",
        round: true,
        nice: true,
        zero: true,
        domain: { data: "source", field: "Miles_per_Gallon" },
        range: "height",
      },
      {
        name: "size",
        type: "linear",
        round: true,
        nice: false,
        zero: true,
        domain: { data: "source", field: "Acceleration" },
        range: [4, 361],
      },
    ],

    axes: [
      {
        scale: "x",
        grid: true,
        domain: false,
        orient: "bottom",
        tickCount: 5,
        title: "Horsepower",
      },
      {
        scale: "y",
        grid: true,
        domain: false,
        orient: "left",
        titlePadding: 5,
        title: "Miles_per_Gallon",
      },
    ],

    legends: [
      {
        size: "size",
        title: "Acceleration",
        format: "s",
        symbolStrokeColor: "#4682b4",
        symbolStrokeWidth: 2,
        symbolOpacity: 0.5,
        symbolType: "circle",
      },
    ],

    marks: [
      {
        name: "marks",
        type: "symbol",
        from: { data: "source" },
        encode: {
          update: {
            x: { scale: "x", field: "Horsepower" },
            y: { scale: "y", field: "Miles_per_Gallon" },
            size: { scale: "size", field: "Acceleration" },
            shape: { value: "circle" },
            strokeWidth: { value: 2 },
            opacity: { value: 0.5 },
            stroke: { value: "#4682b4" },
            fill: { value: "transparent" },
          },
        },
      },
    ],
  };
}

async function renderStaticVisualization() {
  // render vega spec on screen
  await vega(document.getElementById("LibraPlayground"), globalThis.vegaSpec);
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  await VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // Create the main layer
  const mainLayer = Libra.Layer.initialize("VegaLayer", {
    name: "mainLayer",
    group: "marks",
    container: document.querySelector("#LibraPlayground svg"),
  });

  return mainLayer;
}

function mountInteraction(layer) {
  // Attach ClickInstrument to the main layer
  Libra.Interaction.build({
    inherit: "ClickInstrument",
    layers: [layer],
    sharedVar: {
      highlightAttrValues: { stroke: "red" },
    },
  });
}

main();


#####libra_vega/scatter_excentric_labeling.js:#####
// global variables
globalThis.vegaSpec = {};

async function loadData() {
  globalThis.vegaSpec = {
    $schema: "https://vega.github.io/schema/vega/v5.json",
    description:
      "A basic scatter plot example depicting automobile statistics.",
    width: 380,
    height: 380,
    padding: 5,

    data: [
      {
        name: "source",
        url: "data/cars.json",
        transform: [
          {
            type: "filter",
            expr: "datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null",
          },
        ],
      },
    ],

    scales: [
      {
        name: "x",
        type: "linear",
        round: true,
        nice: true,
        zero: true,
        domain: { data: "source", field: "Horsepower" },
        range: "width",
      },
      {
        name: "y",
        type: "linear",
        round: true,
        nice: true,
        zero: true,
        domain: { data: "source", field: "Miles_per_Gallon" },
        range: "height",
      },
      {
        name: "size",
        type: "linear",
        round: true,
        nice: false,
        zero: true,
        domain: { data: "source", field: "Acceleration" },
        range: [4, 361],
      },
    ],

    axes: [
      {
        scale: "x",
        grid: true,
        domain: false,
        orient: "bottom",
        tickCount: 5,
        title: "Horsepower",
      },
      {
        scale: "y",
        grid: true,
        domain: false,
        orient: "left",
        titlePadding: 5,
        title: "Miles_per_Gallon",
      },
    ],

    legends: [
      {
        size: "size",
        title: "Acceleration",
        format: "s",
        symbolStrokeColor: "#4682b4",
        symbolStrokeWidth: 2,
        symbolOpacity: 0.5,
        symbolType: "circle",
      },
    ],

    marks: [
      {
        name: "marks",
        type: "symbol",
        from: { data: "source" },
        encode: {
          update: {
            x: { scale: "x", field: "Horsepower" },
            y: { scale: "y", field: "Miles_per_Gallon" },
            size: { scale: "size", field: "Acceleration" },
            shape: { value: "circle" },
            strokeWidth: { value: 2 },
            opacity: { value: 0.5 },
            stroke: { value: "#4682b4" },
            fill: { value: "transparent" },
          },
        },
      },
    ],
  };
}

async function renderStaticVisualization() {
  // render vega spec on screen
  await vega(document.getElementById("LibraPlayground"), globalThis.vegaSpec);
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

Libra.Interaction.build({
  inherit: "HoverInstrument",
  name: "ExcentricLabelingInstrument",
  sharedVar: {
    r: 20,
    stroke: "green",
    strokeWidth: 2,
    countLabelDistance: 20,
    fontSize: 12,
    countLabelWidth: 40,
    maxLabelsNum: 10,
    labelAccessor: (circleElem) => d3.select(circleElem).datum()["label"],
    colorAccessor: (circleElem) => d3.select(circleElem).datum()["color"],
  },
  override: [
    {
      find: "SelectionService",
      comp: "CircleSelectionService",
    },
  ],
  insert: [
    {
      find: "CircleSelectionService",
      flow: [
        {
          comp: "ExcentricLabelingLayoutService",
          resultAlias: "result",
          evaluate({
            labelAccessor,
            colorAccessor,
            r,
            maxLabelsNum,
            event,
            layer,
            result: circles,
          }) {
            if (!event) return [];
            const [layerX, layerY] = d3.pointer(event, layer.getGraphic());
            const rootBBox = layer
              .getContainerGraphic()
              .getBoundingClientRect();
            const layerBBox = layer.getGraphic().transform.baseVal.consolidate()
              ?.matrix ?? { a: 0, b: 0, c: 0, d: 0, e: 0, f: 0 };

            function getRawInfos(objs, labelAccessor, colorAccessor) {
              const rawInfos = objs.map((obj) => {
                const bbox = obj.__libra__screenElement.getBoundingClientRect();
                const x = bbox.x + (bbox.width >> 1) - rootBBox.x - layerBBox.e;
                const y =
                  bbox.y + (bbox.height >> 1) - rootBBox.y - layerBBox.f;
                const labelName = labelAccessor(obj); //d3.select(obj).datum()[labelField];
                const color = colorAccessor(obj); //colorScale(d3.select(obj).datum()[colorField]);
                return {
                  x,
                  y,
                  labelWidth: 0,
                  labelHeight: 0,
                  color,
                  labelName,
                };
              });
              return rawInfos;
            }

            function computeSizeOfLabels(rawInfos, root) {
              const tempInfoAttr = "labelText";
              const tempClass = "temp" + String(new Date().getMilliseconds());
              //const tempMountPoint = d3.create("svg:g").attr("class", tempClass);
              const tempMountPoint = root
                .append("svg:g")
                .attr("class", tempClass);
              rawInfos.forEach(
                (rawInfo) =>
                (rawInfo[tempInfoAttr] = tempMountPoint
                  .append("text")
                  .attr("opacity", "0")
                  .attr("x", -Number.MAX_SAFE_INTEGER)
                  .attr("y", -Number.MAX_SAFE_INTEGER)
                  .text(rawInfo.labelName)
                  .node())
              );
              root.node().appendChild(tempMountPoint.node());
              rawInfos.forEach((rawInfo) => {
                const labelBBox = rawInfo[tempInfoAttr].getBBox();
                rawInfo.labelWidth = labelBBox.width;
                rawInfo.labelHeight = 21;
              });
              root.select("." + tempClass).remove();
              rawInfos.forEach((rawInfo) => delete rawInfo[tempInfoAttr]);
            }

            const rawInfos = getRawInfos(circles, labelAccessor, colorAccessor);
            computeSizeOfLabels(rawInfos, d3.select(layer.getGraphic()));
            const compute = excentricLabeling()
              .radius(r)
              .horizontallyCoherent(true)
              .maxLabelsNum(maxLabelsNum);
            const result = compute(rawInfos, layerX, layerY);
            return result;
          },
        },
        (layer) => ({
          comp: "DrawLabelTransformer",
          layer: layer.getLayerFromQueue("LabelLayer"),
          sharedVar: {
            result: [],
          },
          redraw({ layer, transformer }) {
            function renderLines(root, result) {
              const lineGroup = root
                .append("g")
                .attr("class", "exentric-labeling-line");
              const lineGenerator = d3
                .line()
                .x((d) => d.x)
                .y((d) => d.y);
              lineGroup
                .selectAll("path")
                .data(result)
                .join("path")
                .attr("fill", "none")
                .attr("stroke", (layoutInfo) => layoutInfo.rawInfo.color)
                .attr("d", (layoutInfo) =>
                  lineGenerator(layoutInfo.controlPoints)
                );
            }

            function renderBBoxs(root, result) {
              const bboxGroup = root
                .append("g")
                .attr("class", "exentric-labeling-bbox");
              bboxGroup
                .selectAll("rect")
                .data(result)
                .join("rect")
                .attr("class", "labelBBox")
                .attr("fill", "none")
                .attr("stroke", (layoutInfo) => layoutInfo.rawInfo.color)
                .attr("x", (layoutInfo) => layoutInfo.labelBBox.x)
                .attr("y", (layoutInfo) => layoutInfo.labelBBox.y)
                .attr("width", (layoutInfo) => layoutInfo.labelBBox.width)
                .attr("height", (layoutInfo) => layoutInfo.labelBBox.height);
            }

            function renderTexts(root, result) {
              const textGroup = root
                .append("g")
                .attr("class", "exentric-labeling-text");
              textGroup
                .selectAll("text")
                .data(result)
                .join("text")
                .attr("stroke", (layoutInfo) => layoutInfo.rawInfo.color)
                .attr("x", (layoutInfo) => layoutInfo.labelBBox.x)
                .attr("y", (layoutInfo) => layoutInfo.labelBBox.y)
                .attr("dominant-baseline", "hanging")
                .text((layoutInfo) => layoutInfo.rawInfo.labelName);
            }

            layer.setLayersOrder({ selectionLayer: -1 });

            const result = transformer.getSharedVar("result");
            const root = d3.select(layer.getGraphic());
            root.selectAll("*").remove();
            renderLines(root, result);
            renderBBoxs(root, result);
            renderTexts(root, result);
          },
        }),
      ],
    },
    {
      find: "CircleSelectionService",
      flow: [
        {
          comp: "AggregateService",
          resultAlias: "count",
          sharedVar: {
            ops: ["count"],
          },
        },
        (layer) => ({
          comp: "DrawTextTransformer",
          layer: layer.getLayerFromQueue("LensLayer"),
          sharedVar: {
            x: 0,
            y: 0,
            count: 0,
          },
          redraw({ layer, transformer }) {
            const cx =
              transformer.getSharedVar("x") -
              layer
                .getLayerFromQueue("mainLayer")
                .getGraphic()
                .getBoundingClientRect().left;
            const cy =
              transformer.getSharedVar("y") -
              layer
                .getLayerFromQueue("mainLayer")
                .getGraphic()
                .getBoundingClientRect().top;
            const opacity = 1;
            const lensRadius = transformer.getSharedVar("r");
            const stroke = transformer.getSharedVar("stroke");
            const strokeWidth = transformer.getSharedVar("strokeWidth");
            const count = transformer.getSharedVar("count");
            const countLabelDistance =
              transformer.getSharedVar("countLabelDistance");
            const fontSize = transformer.getSharedVar("fontSize");
            const countLabelWidth = transformer.getSharedVar("countLabelWidth");

            const root = d3.select(layer.getGraphic());
            root.selectAll("*").remove();

            const group = root
              .append("g")
              .attr("opacity", opacity)
              .attr("transform", `translate(${cx}, ${cy})`);

            group
              .append("circle")
              .attr("class", "lensCircle")
              .attr("cx", 0)
              .attr("r", lensRadius)
              .attr("fill", "none")
              .attr("stroke", stroke)
              .attr("stroke-width", strokeWidth);
            const countLabel = group
              .append("text")
              .attr("y", -(countLabelDistance + lensRadius))
              .attr("font-size", fontSize)
              .attr("text-anchor", "middle")
              .attr("fill", stroke)
              .text(count);
            const countLabelBBox = countLabel.node().getBBox();
            group
              .append("rect")
              .attr("class", "lensLabelBorder")
              .attr("stroke", stroke)
              .attr("stroke-width", strokeWidth)
              .attr("fill", "none")
              .attr("x", -countLabelWidth >> 1)
              .attr("y", countLabelBBox.y)
              .attr("width", countLabelWidth)
              .attr("height", countLabelBBox.height);
            group
              .append("line")
              .attr("stroke", stroke)
              .attr("stroke-width", strokeWidth)
              .attr("y1", -lensRadius)
              .attr("y2", countLabelBBox.y + countLabelBBox.height);
          },
        }),
      ],
    },
  ],
});

// import static visualization and global variables
const VIS = require("./staticVisualization");
// register excentricLabelingInstrument
require("./excentricLabelingInstrument");

async function main() {
  await VIS.loadData();
  await VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // Create the main layer
  const mainLayer = Libra.Layer.initialize("VegaLayer", {
    name: "mainLayer",
    group: "marks",
    container: document.querySelector("#LibraPlayground svg"),
  });

  return mainLayer;
}

function mountInteraction(layer) {
  Libra.Interaction.build({
    inherit: "ExcentricLabelingInstrument",
    layers: [layer],
    sharedVar: {
      labelAccessor: (circleElem) => circleElem.__data__.datum.Name,
      colorAccessor: (circleElem) => circleElem.__data__.stroke,
    },
  });
}

main();


#####libra_vega/scatter_hover.js:#####
// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  await VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // Create the main layer
  const mainLayer = Libra.Layer.initialize("VegaLayer", {
    name: "mainLayer",
    group: "marks",
    container: document.querySelector("#LibraPlayground svg"),
  });

  return mainLayer;
}

function mountInteraction(layer) {
  // Attach BrushInstrument to the main layer
  Libra.Interaction.build({
    inherit: "HoverInstrument",
    layers: [layer],
    sharedVar: {
      highlightAttrValues: { stroke: "red" },
    },
  });
}

main();


#####libra_vega/scatter_panzoom.js:#####
// global variables
globalThis.vegaSpec = {};

async function loadData() {
  globalThis.vegaSpec = {
    $schema: "https://vega.github.io/schema/vega/v5.json",
    description:
      "A basic scatter plot example depicting automobile statistics.",
    width: 300,
    height: 300,
    padding: 5,

    data: [
      {
        name: "source",
        url: "data/cars.json",
        transform: [
          {
            type: "filter",
            expr: "datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null",
          },
        ],
      },
    ],

    signals: [
      {
        name: "xDom",
        init: "extent(pluck(data('source'), 'Horsepower'))",
      },
      {
        name: "yDom",
        init: "extent(pluck(data('source'), 'Miles_per_Gallon'))",
      },
    ],

    scales: [
      {
        name: "x",
        type: "linear",
        zero: false,
        domain: { signal: "xDom" },
        range: "width",
      },
      {
        name: "y",
        type: "linear",
        zero: false,
        domain: { signal: "yDom" },
        range: "height",
      },
      {
        name: "size",
        type: "linear",
        round: true,
        nice: false,
        zero: true,
        domain: { data: "source", field: "Acceleration" },
        range: [4, 361],
      },
    ],

    axes: [
      {
        scale: "x",
        grid: true,
        domain: false,
        orient: "bottom",
        tickCount: 5,
        title: "Horsepower",
      },
      {
        scale: "y",
        grid: true,
        domain: false,
        orient: "left",
        titlePadding: 5,
        title: "Miles_per_Gallon",
      },
    ],

    legends: [
      {
        size: "size",
        title: "Acceleration",
        format: "s",
        symbolStrokeColor: "#4682b4",
        symbolStrokeWidth: 2,
        symbolOpacity: 0.5,
        symbolType: "circle",
      },
    ],

    marks: [
      {
        name: "marks",
        type: "symbol",
        clip: true,
        from: { data: "source" },
        encode: {
          update: {
            x: { scale: "x", field: "Horsepower" },
            y: { scale: "y", field: "Miles_per_Gallon" },
            size: { scale: "size", field: "Acceleration" },
            shape: { value: "circle" },
            strokeWidth: { value: 2 },
            opacity: { value: 0.5 },
            stroke: { value: "#4682b4" },
            fill: { value: "transparent" },
          },
        },
      },
    ],
  };
}

async function renderStaticVisualization() {
  // render vega spec on screen
  const { view } = await vega(
    document.getElementById("LibraPlayground"),
    globalThis.vegaSpec
  );
  globalThis.vegaView = view;
  globalThis.x = view.scale("x");
  globalThis.y = view.scale("y");
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  await VIS.renderStaticVisualization();
  const [mainLayer, transformer] = renderMainVisualization();
  mountInteraction(mainLayer, transformer);
}

function renderMainVisualization() {
  // Create the main layer
  const mainLayer = Libra.Layer.initialize("VegaLayer", {
    name: "mainLayer",
    group: "marks",
    container: document.querySelector("#LibraPlayground svg"),
  });

  Libra.GraphicalTransformer.register("DrawAxesAndMarks", {
    sharedVar: {
      scaleX: globalThis.x,
      scaleY: globalThis.y,
    },
    async redraw({ transformer }) {
      const scaleX = transformer.getSharedVar("scaleX");
      const scaleY = transformer.getSharedVar("scaleY");
      globalThis.vegaView.signal("xDom", scaleX.domain());
      globalThis.vegaView.signal("yDom", scaleY.domain());
      await globalThis.vegaView.runAsync();
    },
  });

  const transformer = Libra.GraphicalTransformer.initialize(
    "DrawAxesAndMarks",
    {
      layer: mainLayer,
    }
  );

  return [mainLayer, transformer];
}

function mountInteraction(layer, transformer) {
  Libra.Interaction.build({
    inherit: "PanInstrument",
    layers: [layer],
    sharedVar: {
      fixRange: true,
      scaleX: globalThis.x,
      scaleY: globalThis.y,
    },
  });

  Libra.Interaction.build({
    inherit: "GeometricZoomInstrument",
    layers: [layer],
    sharedVar: {
      fixRange: true,
      scaleX: globalThis.x,
      scaleY: globalThis.y,
    },
  });
}

main();


#####libra_vega/scatter_semantic_panzoom.js:#####


#####libra_vega/splom_brush.js:#####


#####libra_vega/timeseries_overviewdetail.js:#####


#####libra_vega/treemap_brush.js:#####


#####libra_vega/treemap_click.js:#####


#####libra_vega/treemap_excentric_labeling.js:#####


#####libra_vega/treemap_hover.js:#####


#####libra_vega/treemap_panzoom.js:#####


#####libra_vega/treemap_semantic_panzoom.js:#####


#####libra_vega/zoomable_circle_packing.js:#####
// global variables
globalThis.vegaSpec = {};

async function loadData() {
  globalThis.vegaSpec = {
    "$schema": "https://vega.github.io/schema/vega/v5.json",
    "description": "An example of a zoomable circle packing layout for hierarchical data.",
    "width": 600,
    "height": 600,
    "padding": 0,
    "signals": [
      {
        "name": "duration",
        "init": "750",
        "description": "The duration for the zoom transitions. Fade-in transitions will be the same duration, but will be delayed per the amount set here.",
        "on": [
          {
            "events": { "type": "click", "marknames": ["circles", "background"] },
            "update": "(event.metaKey || event.ctrlKey ? 4 : 1) *750"
          }
        ]
      },
      {
        "name": "k",
        "value": 1,
        "description": "The scale used for zooming based on the focused node",
        "on": [
          {
            "events": [{ "signal": "focus" }],
            "update": "focus ? width/(focus.r*2) : 1"
          }
        ]
      },
      {
        "name": "root",
        "update": "{'id': data('tree')[0]['id'], 'x': data('tree')[0]['x'], 'y': data('tree')[0]['y'], 'r': data('tree')[0]['r'], 'k': 1, 'children': data('tree')[0]['children']}",
        "description": "The root node in the hierarchy"
      },
      {
        "name": "focus",
        "init": "root",
        "description": "The zoomed-in node in the hierarchy"
      },
      {
        "name": "focus0",
        "update": "data('focus0') && length(data('focus0'))>0 ? data('focus0')[0] : focus",
        "description": "The prior zoomed-in node in the hierarchy"
      },
      {
        "name": "timer",
        "description": "The timer to be used for transitions such as zoom, fade, etc.",
        "on": [{ "events": "timer", "update": "now()" }]
      },
      {
        "name": "interpolateTime",
        "description": "the start and end times in miliseconds for animation interpolations",
        "on": [
          {
            "events": {
              "type": "click",
              "marknames": ["circles", "background"]
            },
            "update": "{'start': timer, 'end': timer+duration}"
          }
        ]
      },
      {
        "name": "t",
        "description": "The normalized time for easing",
        "update": "interpolateTime ? clamp((timer-interpolateTime.start)/(interpolateTime.end-interpolateTime.start), 0, 1): null"
      },
      {
        "name": "tEase",
        "description": "The easing calculation. Currently set as easeInOutCubic",
        "update": "t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1"
      },
      {
        "name": "interpolateTimeDelayed",
        "description": "The delayed time for easing",
        "on": [
          {
            "events": { "signal": "interpolateTime" },
            "update": "{'start': interpolateTime['end'], 'end': interpolateTime['end']+duration}"
          }
        ]
      },
      {
        "name": "tDelayed",
        "description": "The delayed normalized time for easing",
        "update": "interpolateTimeDelayed ? clamp((timer-interpolateTimeDelayed.start)/(interpolateTimeDelayed.end-interpolateTimeDelayed.start), 0, 1): null"
      },
      {
        "name": "tEaseDelayed",
        "description": "The delayed easing calculation. Currently set as easeInOutCubic",
        "update": "tDelayed < 0.5 ? 4 * tDelayed * tDelayed * tDelayed : (tDelayed - 1) * (2 * tDelayed - 2) * (2 * tDelayed - 2) + 1"
      }
    ],
    "data": [
      {
        "name": "source",
        "url": "data/flare.json",
        "transform": [
          {
            "type": "formula",
            "expr": "isValid(datum['parent']) ? datum['parent'] : null",
            "as": "parent"
          },
          {
            "type": "formula",
            "expr": "isValid(datum['size']) ? datum['size'] : null",
            "as": "size"
          }
        ]
      },
      {
        "name": "tree",
        "source": "source",
        "transform": [
          { "type": "stratify", "key": "id", "parentKey": "parent" },
          {
            "type": "pack",
            "field": "size",
            "sort": { "field": "value" },
            "size": [{ "signal": "width" }, { "signal": "height" }]
          }
        ]
      },
      {
        "name": "focus0",
        "on": [{ "trigger": "focus", "insert": "focus" }],
        "transform": [
          { "type": "formula", "expr": "now()", "as": "now" },
          {
            "type": "window",
            "ops": ["row_number"],
            "as": ["row"],
            "sort": { "field": "now", "order": "descending" }
          },
          { "type": "filter", "expr": "datum['row'] ? datum['row'] == 2 : true " },
          { "type": "project", "fields": ["id", "x", "y", "r", "children"] },
          { "type": "formula", "expr": "width/(datum['r']*2)", "as": "k" }
        ]
      }
    ],
    "scales": [
      {
        "name": "color",
        "type": "ordinal",
        "domain": { "data": "tree", "field": "depth" },
        "range": { "scheme": "magma" }
      }
    ],
    "marks": [

      {
        "name": "circles",
        "description": "the zoomable packed circles",
        "type": "symbol",
        "from": { "data": "tree" },
        "encode": {
          "enter": {
            "shape": { "value": "circle" },
            "fill": { "scale": "color", "field": "depth" },
            "cursor": { "value": "pointer" }
          },
          "update": {
            "x": {
              "signal": "lerp([root['x']+ (datum['x'] - focus0['x']) * focus0['k'], root['x'] + (datum['x'] - focus['x']) * k], tEase)"
            },
            "y": {
              "signal": "lerp([ root['y'] + (datum['y'] - focus0['y']) * focus0['k'],  root['y'] + (datum['y'] - focus['y']) * k], tEase)"
            },
            "size": {
              "signal": "pow(2*(datum['r'] * lerp([focus0['k'], k],tEase)),2)"
            },
            "fill": {
              "signal": "scale('color',datum['depth'])"
            },

            "stroke": "black",
            "strokeWidth": 2,
            "strokeOpacity": 1
          }

        }
      }

    ]
  }
}

async function renderStaticVisualization() {
  // render vega spec on screen
  await vega(document.getElementById("LibraPlayground"), globalThis.vegaSpec);
}

module.exports = {
  loadData,
  renderStaticVisualization,
};

// import static visualization and global variables
const VIS = require("./staticVisualization");

async function main() {
  await VIS.loadData();
  await VIS.renderStaticVisualization();
  const mainLayer = renderMainVisualization();
  console.log(mainLayer);
  mountInteraction(mainLayer);
}

function renderMainVisualization() {
  // Create the main layer
  const mainLayer = Libra.Layer.initialize("VegaLayer", {
    name: "mainLayer",
    group: "circles",
    container: document.querySelector("#LibraPlayground svg"),
  });
  console.log(mainLayer);
  return mainLayer;
}

function mountInteraction(layer) {

  Libra.GraphicalTransformer.register("renderTransformer", {
    layer: layer,
    // transient: true,
    redraw: function ({ layer, transformer }) {
      const result = transformer.getSharedVar("result");

      if (result) {
        function animateViewBox(start, end, duration) {
          var startTime;
          function animate(time) {
            if (!startTime) startTime = time;

            var progress = (time - startTime) / duration;
            if (progress > 1) progress = 1;

            var currentViewBox = {
              x: start.x + (end.x - start.x) * progress,
              y: start.y + (end.y - start.y) * progress,
              width: start.width + (end.width - start.width) * progress,
              height: start.height + (end.height - start.height) * progress,
            };

            layer._container.setAttribute('viewBox', `${currentViewBox.x} ${currentViewBox.y} ${currentViewBox.width} ${currentViewBox.height}`);

            if (progress < 1) {
              requestAnimationFrame(animate);
            }
          }

          requestAnimationFrame(animate);
        }
        animateViewBox(layer._container.viewBox.baseVal, result, 500)
      }

    },
  });

  globalThis.originViewBox = {
    x: 0,
    y: 0,
    width: 600,
    height: 600,
  }
  globalThis.currentViewBox = {

  }
  globalThis.moveViewAs = {}
  // Attach BrushInstrument to the main layer
  Libra.Interaction.build({
    inherit: "ClickInstrument",
    layers: [layer],
    remove: [{ find: "SelectionTransformer" }],
    insert: [
      {
        find: "SelectionService",
        flow: [
          {
            comp: "getMoveService",
            evaluate({
              result,
            }) {
              if (result.length) {
                const clickBox = {
                  x: result[0].__data__.bounds.x1,
                  y: result[0].__data__.bounds.y1,
                  width: result[0].__data__.bounds.x2 - result[0].__data__.bounds.x1,
                  height: result[0].__data__.bounds.y2 - result[0].__data__.bounds.y1,
                }
                for (let key in clickBox) {
                  if (!globalThis.currentViewBox[key] || !(globalThis.currentViewBox[key] == clickBox[key])) {
                    globalThis.currentViewBox = clickBox;
                    return clickBox
                  }
                }
                globalThis.currentViewBox = globalThis.originViewBox
                return globalThis.originViewBox
              }
            },
          },
          {
            comp: "renderTransformer"
          }
        ],
      }
    ],
  });
}

main();





#####vega/bar_brush.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "width": 600,
  "height": 400,
  "padding": 5,
  "data": [
    {
      "name": "source",
      "values": [
        { "letter": "A", "value": 0.08167 },
        { "letter": "B", "value": 0.01492 },
        { "letter": "C", "value": 0.02782 },
        { "letter": "D", "value": 0.04253 },
        { "letter": "E", "value": 0.12702 },
        { "letter": "F", "value": 0.02288 },
        { "letter": "G", "value": 0.02015 },
        { "letter": "H", "value": 0.06094 },
        { "letter": "I", "value": 0.06966 },
        { "letter": "J", "value": 0.00153 },
        { "letter": "K", "value": 0.00772 },
        { "letter": "L", "value": 0.04025 },
        { "letter": "M", "value": 0.02406 },
        { "letter": "N", "value": 0.06749 },
        { "letter": "O", "value": 0.07507 },
        { "letter": "P", "value": 0.01929 },
        { "letter": "Q", "value": 0.00095 },
        { "letter": "R", "value": 0.05987 },
        { "letter": "S", "value": 0.06327 },
        { "letter": "T", "value": 0.09056 },
        { "letter": "U", "value": 0.02758 },
        { "letter": "V", "value": 0.00978 },
        { "letter": "W", "value": 0.0236 },
        { "letter": "X", "value": 0.0015 },
        { "letter": "Y", "value": 0.01974 },
        { "letter": "Z", "value": 0.00074 }
      ]
    },
    {
      "name": "selected",
      "source": "source",
      "transform": [
        {
          "type": "filter",
          "expr": "indexof(brush, datum.letter) !== -1"
        }
      ]
    }
  ],
  "signals": [
    {
      "name": "brush",
      "value": [],
      "on": [{ "events": "brush", "update": "brush" }]
    }
  ],
  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": { "data": "source", "field": "letter" },
      "range": "width"
    },
    {
      "name": "yscale",
      "domain": { "data": "source", "field": "value" },
      "nice": true,
      "range": "height"
    }
  ],
  "axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "left", "scale": "yscale" }
  ],
  "marks": [
    {
      "type": "rect",
      "from": { "data": "selected" },
      "encode": {
        "enter": {
          "x": { "scale": "xscale", "field": "letter" },
          "width": { "scale": "xscale", "band": 1, "offset": -1 },
          "y": { "scale": "yscale", "field": "value" },
          "y2": { "scale": "yscale", "value": 0 }
        },
        "update": { "fill": { "value": "transparent" } }
      }
    },
    {
      "type": "rect",
      "from": { "data": "source" },
      "encode": {
        "enter": {
          "x": { "scale": "xscale", "field": "letter" },
          "width": { "scale": "xscale", "band": 1, "offset": -1 },
          "y": { "scale": "yscale", "field": "value" },
          "y2": { "scale": "yscale", "value": 0 },
          "fill": { "value": "steelblue" }
        },
        "update": {
          "fill": [
            {
              "test": "!length(data('selected'))",
              "value": "steelblue"
            },
            {
              "test": "!inrange(data('selected'), datum.letter)",
              "value": "#ccc"
            },
            { "value": "steelblue" }
          ]
        }
      }
    }
  ]
}


#####vega/bar_click.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "width": 600,
  "height": 400,
  "padding": 5,
  "data": [
    {
      "name": "source",
      "values": [
        {"letter": "A", "value": 0.08167},
        {"letter": "B", "value": 0.01492},
        {"letter": "C", "value": 0.02782},
        {"letter": "D", "value": 0.04253},
        {"letter": "E", "value": 0.12702},
        {"letter": "F", "value": 0.02288},
        {"letter": "G", "value": 0.02015},
        {"letter": "H", "value": 0.06094},
        {"letter": "I", "value": 0.06966},
        {"letter": "J", "value": 0.00153},
        {"letter": "K", "value": 0.00772},
        {"letter": "L", "value": 0.04025},
        {"letter": "M", "value": 0.02406},
        {"letter": "N", "value": 0.06749},
        {"letter": "O", "value": 0.07507},
        {"letter": "P", "value": 0.01929},
        {"letter": "Q", "value": 0.00095},
        {"letter": "R", "value": 0.05987},
        {"letter": "S", "value": 0.06327},
        {"letter": "T", "value": 0.09056},
        {"letter": "U", "value": 0.02758},
        {"letter": "V", "value": 0.00978},
        {"letter": "W", "value": 0.0236},
        {"letter": "X", "value": 0.0015},
        {"letter": "Y", "value": 0.01974},
        {"letter": "Z", "value": 0.00074}
      ]
    }
  ],
  "signals": [
    {
      "name": "clicked",
      "value": null,
      "on": [
        {"events": "click", "update": "datum.letter"}
      ]
    }
  ],
  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "source", "field": "letter"},
      "range": "width"
    },
    {
      "name": "yscale",
      "domain": {"data": "source", "field": "value"},
      "nice": true,
      "range": "height"
    }
  ],
  "axes": [
    {"orient": "bottom", "scale": "xscale"},
    {"orient": "left", "scale": "yscale"}
  ],
  "marks": [
    {
      "type": "rect",
      "from": {"data": "source"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "letter"},
          "width": {"scale": "xscale", "band": 1, "offset": -1},
          "y": {"scale": "yscale", "field": "value"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"},
          "cursor": {"value": "pointer"}
        },
        "update": {
          "fill": [
            {
              "test": "datum.letter === clicked",
              "value": "firebrick"
            },
            {"value": "steelblue"}
          ]
        }
      }
    }
  ]
}

#####vega/bar_hover.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "width": 600,
  "height": 400,
  "padding": 5,
  "data": [
    {
      "name": "source",
      "values": [
        {"letter": "A", "value": 0.08167},
        {"letter": "B", "value": 0.01492},
        {"letter": "C", "value": 0.02782},
        {"letter": "D", "value": 0.04253},
        {"letter": "E", "value": 0.12702},
        {"letter": "F", "value": 0.02288},
        {"letter": "G", "value": 0.02015},
        {"letter": "H", "value": 0.06094},
        {"letter": "I", "value": 0.06966},
        {"letter": "J", "value": 0.00153},
        {"letter": "K", "value": 0.00772},
        {"letter": "L", "value": 0.04025},
        {"letter": "M", "value": 0.02406},
        {"letter": "N", "value": 0.06749},
        {"letter": "O", "value": 0.07507},
        {"letter": "P", "value": 0.01929},
        {"letter": "Q", "value": 0.00095},
        {"letter": "R", "value": 0.05987},
        {"letter": "S", "value": 0.06327},
        {"letter": "T", "value": 0.09056},
        {"letter": "U", "value": 0.02758},
        {"letter": "V", "value": 0.00978},
        {"letter": "W", "value": 0.0236},
        {"letter": "X", "value": 0.0015},
        {"letter": "Y", "value": 0.01974},
        {"letter": "Z", "value": 0.00074}
      ]
    }
  ],
  "signals": [
    {
      "name": "hover", "value": null,
      "on": [
        {"events": "mousemove", "update": "datum"},
        {"events": "mouseleave", "update": "null"}
      ]
    }
  ],
  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "source", "field": "letter"},
      "range": "width",
      "padding": 0.2
    },
    {
      "name": "yscale",
      "domain": {"data": "source", "field": "value"},
      "nice": true,
      "range": "height"
    }
  ],
  "axes": [
    {"orient": "bottom", "scale": "xscale"},
    {"orient": "left", "scale": "yscale"}
  ],
  "marks": [
    {
      "type": "rect",
      "from": {"data": "source"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "letter"},
          "width": {"scale": "xscale", "band": 1, "offset": -1},
          "y": {"scale": "yscale", "field": "value"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        },
        "update": {
          "fill": [
            {
              "test": "hover && hover.letter == datum.letter",
              "value": "firebrick"
            },
            {"value": "steelblue"}
          ]
        }
      }
    },
    {
      "type": "text",
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#333"}
        },
        "update": {
          "x": {"scale": "xscale", "signal": "hover.letter", "band": 0.5},
          "y": {"scale": "yscale", "signal": "hover.value", "offset": -2},
          "text": {"signal": "hover.value"},
          "fillOpacity": [
            {
              "test": "hover && hover.letter == datum.letter",
              "value": 1
            },
            {"value": 0}
          ]
        }
      }
    }
  ]
}

#####vega/bar_panzoom.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "width": 600,
  "height": 400,
  "padding": 5,
  "data": [
    {
      "name": "source",
      "values": [
        {"letter": "A", "value": 0.08167},
        {"letter": "B", "value": 0.01492},
        {"letter": "C", "value": 0.02782},
        {"letter": "D", "value": 0.04253},
        {"letter": "E", "value": 0.12702},
        {"letter": "F", "value": 0.02288},
        {"letter": "G", "value": 0.02015},
        {"letter": "H", "value": 0.06094},
        {"letter": "I", "value": 0.06966},
        {"letter": "J", "value": 0.00153},
        {"letter": "K", "value": 0.00772},
        {"letter": "L", "value": 0.04025},
        {"letter": "M", "value": 0.02406},
        {"letter": "N", "value": 0.06749},
        {"letter": "O", "value": 0.07507},
        {"letter": "P", "value": 0.01929},
        {"letter": "Q", "value": 0.00095},
        {"letter": "R", "value": 0.05987},
        {"letter": "S", "value": 0.06327},
        {"letter": "T", "value": 0.09056},
        {"letter": "U", "value": 0.02758},
        {"letter": "V", "value": 0.00978},
        {"letter": "W", "value": 0.0236},
        {"letter": "X", "value": 0.0015},
        {"letter": "Y", "value": 0.01974},
        {"letter": "Z", "value": 0.00074}
      ]
    }
  ],
  "signals": [
    {
      "name": "zoom", "value": 1,
      "on": [
        {"events": "wheel", "force": true, "update": "pow(1.005, event.deltaY * pow(16, event.deltaMode))"},
        {"events": "touchstart", "force": true, "update": "1"}
      ]
    },
    {
      "name": "cursor", "value": [0, 0],
      "on": [
        {"events": "mousedown", "update": "[x(), y()]"},
        {"events": "touchstart", "update": "[x(), y()]"}
      ]
    },
    {
      "name": "translate0", "value": [0, 0],
      "on": [
        {"events": "mousedown", "update": "[cursor[0], cursor[1]]"},
        {"events": "touchstart", "update": "[cursor[0], cursor[1]]"}
      ]
    },
    {
      "name": "translate",
      "value": [0, 0],
      "on": [
        {"events": "mousemove", "update": "[translate0[0] + x() - cursor[0], translate0[1] + y() - cursor[1]]"},
        {"events": "touchmove", "update": "[translate0[0] + x() - cursor[0], translate0[1] + y() - cursor[1]]"},
        {"events": "mouseup", "update": "[translate0[0] + x() - cursor[0], translate0[1] + y() - cursor[1]]"},
        {"events": "touchend", "update": "[translate0[0] + x() - cursor[0], translate0[1] + y() - cursor[1]]"}
      ]
    }
  ],
  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "source", "field": "letter"},
      "range": {"step": 20}
    },
    {
      "name": "yscale",
      "domain": {"data": "source", "field": "value"},
      "nice": true,
      "range": "height"
    }
  ],
  "axes": [
    {"orient": "bottom", "scale": "xscale"},
    {"orient": "left", "scale": "yscale"}
  ],
  "marks": [
    {
      "type": "rect",
      "from": {"data": "source"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "letter"},
          "width": {"scale": "xscale", "band": 1, "offset": -1},
          "y": {"scale": "yscale", "field": "value"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        }
      }
    }
  ]
}

#####vega/dimpvis.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "An interactive scatter plot of global health statistics by country and year.",
  "width": 800,
  "height": 600,
  "padding": 5,

  "data": [
    {
      "name": "gapminder",
      "url": "data/gapminder.json"
    },
    {
      "name": "clusters",
      "values": [
        { "id": 0, "name": "South Asia" },
        { "id": 1, "name": "Europe & Central Asia" },
        { "id": 2, "name": "Sub-Saharan Africa" },
        { "id": 3, "name": "America" },
        { "id": 4, "name": "East Asia & Pacific" },
        { "id": 5, "name": "Middle East & North Africa" }
      ]
    },
    {
      "name": "country_timeline",
      "source": "gapminder",
      "transform": [
        {
          "type": "filter",
          "expr": "timeline && datum.country == timeline.country"
        },
        { "type": "collect", "sort": { "field": "year" } }
      ]
    },
    {
      "name": "thisYear",
      "source": "gapminder",
      "transform": [{ "type": "filter", "expr": "datum.year == currentYear" }]
    },
    {
      "name": "prevYear",
      "source": "gapminder",
      "transform": [
        { "type": "filter", "expr": "datum.year == currentYear - stepYear" }
      ]
    },
    {
      "name": "nextYear",
      "source": "gapminder",
      "transform": [
        { "type": "filter", "expr": "datum.year == currentYear + stepYear" }
      ]
    },
    {
      "name": "countries",
      "source": "gapminder",
      "transform": [{ "type": "aggregate", "groupby": ["country"] }]
    },
    {
      "name": "interpolate",
      "source": "countries",
      "transform": [
        {
          "type": "lookup",
          "from": "thisYear",
          "key": "country",
          "fields": ["country"],
          "as": ["this"],
          "default": {}
        },
        {
          "type": "lookup",
          "from": "prevYear",
          "key": "country",
          "fields": ["country"],
          "as": ["prev"],
          "default": {}
        },
        {
          "type": "lookup",
          "from": "nextYear",
          "key": "country",
          "fields": ["country"],
          "as": ["next"],
          "default": {}
        },
        {
          "type": "formula",
          "as": "target_fertility",
          "expr": "interYear > currentYear ? datum.next.fertility : (datum.prev.fertility||datum.this.fertility)"
        },
        {
          "type": "formula",
          "as": "target_life_expect",
          "expr": "interYear > currentYear ? datum.next.life_expect : (datum.prev.life_expect||datum.this.life_expect)"
        },
        {
          "type": "formula",
          "as": "inter_fertility",
          "expr": "interYear==2000 ? datum.this.fertility : datum.this.fertility + (datum.target_fertility-datum.this.fertility) * abs(interYear-datum.this.year)/5"
        },
        {
          "type": "formula",
          "as": "inter_life_expect",
          "expr": "interYear==2000 ? datum.this.life_expect : datum.this.life_expect + (datum.target_life_expect-datum.this.life_expect) * abs(interYear-datum.this.year)/5"
        }
      ]
    },
    {
      "name": "trackCountries",
      "on": [{ "trigger": "active", "toggle": "{country: active.country}" }]
    }
  ],

  "signals": [
    { "name": "minYear", "value": 1955 },
    { "name": "maxYear", "value": 2005 },
    { "name": "stepYear", "value": 5 },
    {
      "name": "active",
      "value": {},
      "on": [
        {
          "events": "@point:pointerdown, @point:touchstart",
          "update": "datum"
        },
        { "events": "window:pointerup, window:touchend", "update": "{}" }
      ]
    },
    { "name": "isActive", "update": "active.country" },
    {
      "name": "timeline",
      "value": {},
      "on": [
        {
          "events": "@point:pointerover",
          "update": "isActive ? active : datum"
        },
        { "events": "@point:pointerout", "update": "active" },
        { "events": { "signal": "active" }, "update": "active" }
      ]
    },
    {
      "name": "tX",
      "on": [
        {
          "events": "pointermove!, touchmove!",
          "update": "isActive ? scale('x', active.this.fertility) : tX"
        }
      ]
    },
    {
      "name": "tY",
      "on": [
        {
          "events": "pointermove, touchmove",
          "update": "isActive ? scale('y', active.this.life_expect) : tY"
        }
      ]
    },
    {
      "name": "pX",
      "on": [
        {
          "events": "pointermove, touchmove",
          "update": "isActive ? scale('x', active.prev.fertility) : pX"
        }
      ]
    },
    {
      "name": "pY",
      "on": [
        {
          "events": "pointermove, touchmove",
          "update": "isActive ? scale('y', active.prev.life_expect) : pY"
        }
      ]
    },
    {
      "name": "nX",
      "on": [
        {
          "events": "pointermove, touchmove",
          "update": "isActive ? scale('x', active.next.fertility) : nX"
        }
      ]
    },
    {
      "name": "nY",
      "on": [
        {
          "events": "pointermove, touchmove",
          "update": "isActive ? scale('y', active.next.life_expect) : nY"
        }
      ]
    },
    {
      "name": "thisDist",
      "value": 0,
      "on": [
        {
          "events": "pointermove, touchmove",
          "update": "isActive ? hypot(x()-tX, y()-tY) : thisDist"
        }
      ]
    },
    {
      "name": "prevDist",
      "value": 0,
      "on": [
        {
          "events": "pointermove, touchmove",
          "update": "isActive ? hypot(x()-pX, y()-pY): prevDist"
        }
      ]
    },
    {
      "name": "nextDist",
      "value": 0,
      "on": [
        {
          "events": "pointermove, touchmove",
          "update": "isActive ? hypot(x()-nX, y()-nY) : nextDist"
        }
      ]
    },
    {
      "name": "prevScore",
      "value": 0,
      "on": [
        {
          "events": "pointermove, touchmove",
          "update": "isActive ? ((pX-tX) * (x()-tX) + (pY-tY) * (y()-tY))/prevDist || -999999 : prevScore"
        }
      ]
    },
    {
      "name": "nextScore",
      "value": 0,
      "on": [
        {
          "events": "pointermove, touchmove",
          "update": "isActive ? ((nX-tX) * (x()-tX) + (nY-tY) * (y()-tY))/nextDist || -999999 : nextScore"
        }
      ]
    },
    {
      "name": "interYear",
      "value": 1980,
      "on": [
        {
          "events": "pointermove, touchmove",
          "update": "isActive ? (min(maxYear, currentYear+5, max(minYear, currentYear-5, prevScore > nextScore ? (currentYear - 2.5*prevScore/hypot(pX-tX, pY-tY)) : (currentYear + 2.5*nextScore/hypot(nX-tX, nY-tY))))) : interYear"
        }
      ]
    },
    {
      "name": "currentYear",
      "value": 1980,
      "on": [
        {
          "events": "pointermove, touchmove",
          "update": "isActive ? (min(maxYear, max(minYear, prevScore > nextScore ? (thisDist < prevDist ? currentYear : currentYear-5) : (thisDist < nextDist ? currentYear : currentYear+5)))) : currentYear"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "nice": true,
      "domain": { "data": "gapminder", "field": "fertility" },
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "nice": true,
      "zero": false,
      "domain": { "data": "gapminder", "field": "life_expect" },
      "range": "height"
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": { "data": "gapminder", "field": "cluster" },
      "range": "category"
    },
    {
      "name": "label",
      "type": "ordinal",
      "domain": { "data": "clusters", "field": "id" },
      "range": { "data": "clusters", "field": "name" }
    }
  ],

  "axes": [
    {
      "title": "Fertility",
      "orient": "bottom",
      "scale": "x",
      "grid": true,
      "tickCount": 5
    },
    {
      "title": "Life Expectancy",
      "orient": "left",
      "scale": "y",
      "grid": true,
      "tickCount": 5
    }
  ],

  "legends": [
    {
      "fill": "color",
      "title": "Region",
      "orient": "right",
      "encode": {
        "symbols": {
          "enter": {
            "fillOpacity": { "value": 0.5 }
          }
        },
        "labels": {
          "update": {
            "text": { "scale": "label", "field": "value" }
          }
        }
      }
    }
  ],

  "marks": [
    {
      "type": "text",
      "encode": {
        "update": {
          "text": { "signal": "currentYear" },
          "x": { "value": 300 },
          "y": { "value": 300 },
          "fill": { "value": "grey" },
          "fillOpacity": { "value": 0.25 },
          "fontSize": { "value": 100 }
        }
      }
    },
    {
      "type": "text",
      "from": { "data": "country_timeline" },
      "interactive": false,
      "encode": {
        "enter": {
          "x": { "scale": "x", "field": "fertility", "offset": 5 },
          "y": { "scale": "y", "field": "life_expect" },
          "fill": { "value": "#555" },
          "fillOpacity": { "value": 0.6 },
          "text": { "field": "year" }
        }
      }
    },
    {
      "type": "line",
      "from": { "data": "country_timeline" },
      "encode": {
        "update": {
          "x": { "scale": "x", "field": "fertility" },
          "y": { "scale": "y", "field": "life_expect" },
          "stroke": { "value": "#bbb" },
          "strokeWidth": { "value": 5 },
          "strokeOpacity": { "value": 0.5 }
        }
      }
    },
    {
      "name": "point",
      "type": "symbol",
      "from": { "data": "interpolate" },
      "encode": {
        "enter": {
          "fill": { "scale": "color", "field": "this.cluster" },
          "size": { "value": 150 }
        },
        "update": {
          "x": { "scale": "x", "field": "inter_fertility" },
          "y": { "scale": "y", "field": "inter_life_expect" },
          "fillOpacity": [
            {
              "test": "datum.country==timeline.country || indata('trackCountries', 'country', datum.country)",
              "value": 1
            },
            { "value": 0.5 }
          ]
        }
      }
    },
    {
      "type": "text",
      "from": { "data": "interpolate" },
      "interactive": false,
      "encode": {
        "enter": {
          "fill": { "value": "#333" },
          "fontSize": { "value": 14 },
          "fontWeight": { "value": "bold" },
          "text": { "field": "country" },
          "align": { "value": "center" },
          "baseline": { "value": "bottom" }
        },
        "update": {
          "x": { "scale": "x", "field": "inter_fertility" },
          "y": { "scale": "y", "field": "inter_life_expect", "offset": -7 },
          "fillOpacity": [
            {
              "test": "datum.country==timeline.country || indata('trackCountries', 'country', datum.country)",
              "value": 0.8
            },
            { "value": 0 }
          ]
        }
      }
    }
  ]
}


#####vega/dust_magnet.json:#####


#####vega/edge_bundling.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A network diagram of software dependencies, with edges grouped via hierarchical edge bundling.",
  "padding": 5,
  "width": 720,
  "height": 720,
  "autosize": "none",

  "signals": [
    {
      "name": "tension",
      "value": 0.85,
      "bind": { "input": "range", "min": 0, "max": 1, "step": 0.01 }
    },
    {
      "name": "radius",
      "value": 280,
      "bind": { "input": "range", "min": 20, "max": 400 }
    },
    {
      "name": "extent",
      "value": 360,
      "bind": { "input": "range", "min": 0, "max": 360, "step": 1 }
    },
    {
      "name": "rotate",
      "value": 0,
      "bind": { "input": "range", "min": 0, "max": 360, "step": 1 }
    },
    {
      "name": "textSize",
      "value": 8,
      "bind": { "input": "range", "min": 2, "max": 20, "step": 1 }
    },
    {
      "name": "textOffset",
      "value": 2,
      "bind": { "input": "range", "min": 0, "max": 10, "step": 1 }
    },
    {
      "name": "layout",
      "value": "cluster",
      "bind": { "input": "radio", "options": ["tidy", "cluster"] }
    },
    { "name": "colorIn", "value": "firebrick" },
    { "name": "colorOut", "value": "forestgreen" },
    { "name": "originX", "update": "width / 2" },
    { "name": "originY", "update": "height / 2" },
    {
      "name": "active",
      "value": null,
      "on": [
        { "events": "text:pointerover", "update": "datum.id" },
        { "events": "pointerover[!event.item]", "update": "null" }
      ]
    }
  ],

  "data": [
    {
      "name": "tree",
      "url": "data/flare.json",
      "transform": [
        {
          "type": "stratify",
          "key": "id",
          "parentKey": "parent"
        },
        {
          "type": "tree",
          "method": { "signal": "layout" },
          "size": [1, 1],
          "as": ["alpha", "beta", "depth", "children"]
        },
        {
          "type": "formula",
          "expr": "(rotate + extent * datum.alpha + 270) % 360",
          "as": "angle"
        },
        {
          "type": "formula",
          "expr": "inrange(datum.angle, [90, 270])",
          "as": "leftside"
        },
        {
          "type": "formula",
          "expr": "originX + radius * datum.beta * cos(PI * datum.angle / 180)",
          "as": "x"
        },
        {
          "type": "formula",
          "expr": "originY + radius * datum.beta * sin(PI * datum.angle / 180)",
          "as": "y"
        }
      ]
    },
    {
      "name": "leaves",
      "source": "tree",
      "transform": [
        {
          "type": "filter",
          "expr": "!datum.children"
        }
      ]
    },
    {
      "name": "dependencies",
      "url": "data/flare-dependencies.json",
      "transform": [
        {
          "type": "formula",
          "expr": "treePath('tree', datum.source, datum.target)",
          "as": "treepath",
          "initonly": true
        }
      ]
    },
    {
      "name": "selected",
      "source": "dependencies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.source === active || datum.target === active"
        }
      ]
    }
  ],

  "marks": [
    {
      "type": "text",
      "from": { "data": "leaves" },
      "encode": {
        "enter": {
          "text": { "field": "name" },
          "baseline": { "value": "middle" }
        },
        "update": {
          "x": { "field": "x" },
          "y": { "field": "y" },
          "dx": { "signal": "textOffset * (datum.leftside ? -1 : 1)" },
          "angle": {
            "signal": "datum.leftside ? datum.angle - 180 : datum.angle"
          },
          "align": { "signal": "datum.leftside ? 'right' : 'left'" },
          "fontSize": { "signal": "textSize" },
          "fontWeight": [
            {
              "test": "indata('selected', 'source', datum.id)",
              "value": "bold"
            },
            {
              "test": "indata('selected', 'target', datum.id)",
              "value": "bold"
            },
            { "value": null }
          ],
          "fill": [
            { "test": "datum.id === active", "value": "black" },
            {
              "test": "indata('selected', 'source', datum.id)",
              "signal": "colorIn"
            },
            {
              "test": "indata('selected', 'target', datum.id)",
              "signal": "colorOut"
            },
            { "value": "black" }
          ]
        }
      }
    },
    {
      "type": "group",
      "from": {
        "facet": {
          "name": "path",
          "data": "dependencies",
          "field": "treepath"
        }
      },
      "marks": [
        {
          "type": "line",
          "interactive": false,
          "from": { "data": "path" },
          "encode": {
            "enter": {
              "interpolate": { "value": "bundle" },
              "strokeWidth": { "value": 1.5 }
            },
            "update": {
              "stroke": [
                { "test": "parent.source === active", "signal": "colorOut" },
                { "test": "parent.target === active", "signal": "colorIn" },
                { "value": "steelblue" }
              ],
              "strokeOpacity": [
                {
                  "test": "parent.source === active || parent.target === active",
                  "value": 1
                },
                { "value": 0.2 }
              ],
              "tension": { "signal": "tension" },
              "x": { "field": "x" },
              "y": { "field": "y" }
            }
          }
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": ["depends on", "imported by"],
      "range": [{ "signal": "colorIn" }, { "signal": "colorOut" }]
    }
  ],

  "legends": [
    {
      "stroke": "color",
      "orient": "bottom-right",
      "title": "Dependencies",
      "symbolType": "stroke"
    }
  ]
}


#####vega/force_directed_layout.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A node-link diagram with force-directed layout, depicting character co-occurrence in the novel Les Misrables.",
  "width": 700,
  "height": 500,
  "padding": 0,
  "autosize": "none",

  "signals": [
    { "name": "cx", "update": "width / 2" },
    { "name": "cy", "update": "height / 2" },
    {
      "name": "nodeRadius",
      "value": 8,
      "bind": { "input": "range", "min": 1, "max": 50, "step": 1 }
    },
    {
      "name": "nodeCharge",
      "value": -30,
      "bind": { "input": "range", "min": -100, "max": 10, "step": 1 }
    },
    {
      "name": "linkDistance",
      "value": 30,
      "bind": { "input": "range", "min": 5, "max": 100, "step": 1 }
    },
    { "name": "static", "value": true, "bind": { "input": "checkbox" } },
    {
      "description": "State variable for active node fix status.",
      "name": "fix",
      "value": false,
      "on": [
        {
          "events": "symbol:pointerout[!event.buttons], window:pointerup",
          "update": "false"
        },
        {
          "events": "symbol:pointerover",
          "update": "fix || true"
        },
        {
          "events": "[symbol:pointerdown, window:pointerup] > window:pointermove!",
          "update": "xy()",
          "force": true
        }
      ]
    },
    {
      "description": "Graph node most recently interacted with.",
      "name": "node",
      "value": null,
      "on": [
        {
          "events": "symbol:pointerover",
          "update": "fix === true ? item() : node"
        }
      ]
    },
    {
      "description": "Flag to restart Force simulation upon data changes.",
      "name": "restart",
      "value": false,
      "on": [{ "events": { "signal": "fix" }, "update": "fix && fix.length" }]
    }
  ],

  "data": [
    {
      "name": "node-data",
      "url": "data/miserables.json",
      "format": { "type": "json", "property": "nodes" }
    },
    {
      "name": "link-data",
      "url": "data/miserables.json",
      "format": { "type": "json", "property": "links" }
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": { "data": "node-data", "field": "group" },
      "range": { "scheme": "category20c" }
    }
  ],

  "marks": [
    {
      "name": "nodes",
      "type": "symbol",
      "zindex": 1,

      "from": { "data": "node-data" },
      "on": [
        {
          "trigger": "fix",
          "modify": "node",
          "values": "fix === true ? {fx: node.x, fy: node.y} : {fx: fix[0], fy: fix[1]}"
        },
        {
          "trigger": "!fix",
          "modify": "node",
          "values": "{fx: null, fy: null}"
        }
      ],

      "encode": {
        "enter": {
          "fill": { "scale": "color", "field": "group" },
          "stroke": { "value": "white" }
        },
        "update": {
          "size": { "signal": "2 * nodeRadius * nodeRadius" },
          "cursor": { "value": "pointer" }
        }
      },

      "transform": [
        {
          "type": "force",
          "iterations": 300,
          "restart": { "signal": "restart" },
          "static": { "signal": "static" },
          "signal": "force",
          "forces": [
            {
              "force": "center",
              "x": { "signal": "cx" },
              "y": { "signal": "cy" }
            },
            { "force": "collide", "radius": { "signal": "nodeRadius" } },
            { "force": "nbody", "strength": { "signal": "nodeCharge" } },
            {
              "force": "link",
              "links": "link-data",
              "distance": { "signal": "linkDistance" }
            }
          ]
        }
      ]
    },
    {
      "type": "path",
      "from": { "data": "link-data" },
      "interactive": false,
      "encode": {
        "update": {
          "stroke": { "value": "#ccc" },
          "strokeWidth": { "value": 0.5 }
        }
      },
      "transform": [
        {
          "type": "linkpath",
          "require": { "signal": "force" },
          "shape": "line",
          "sourceX": "datum.source.x",
          "sourceY": "datum.source.y",
          "targetX": "datum.target.x",
          "targetY": "datum.target.y"
        }
      ]
    }
  ]
}


#####vega/helper_line.json:#####


#####vega/index_chart.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "An interactive line chart of stock prices, with returns shown relative to a selected date.",
  "width": 650,
  "height": 300,
  "padding": 5,
  "autosize": { "type": "fit", "contains": "padding" },

  "signals": [
    {
      "name": "indexDate",
      "update": "time('Jan 1 2005')",
      "on": [
        {
          "events": "pointermove",
          "update": "invert('x', clamp(x(), 0, width))"
        }
      ]
    },
    {
      "name": "maxDate",
      "update": "time('Mar 1 2010')"
    }
  ],

  "data": [
    {
      "name": "stocks",
      "url": "data/stocks.csv",
      "format": {
        "type": "csv",
        "parse": { "price": "number", "date": "date" }
      }
    },
    {
      "name": "index",
      "source": "stocks",
      "transform": [
        {
          "type": "filter",
          "expr": "month(datum.date) == month(indexDate) && year(datum.date) == year(indexDate)"
        }
      ]
    },
    {
      "name": "indexed_stocks",
      "source": "stocks",
      "transform": [
        {
          "type": "lookup",
          "from": "index",
          "key": "symbol",
          "fields": ["symbol"],
          "as": ["index"],
          "default": { "price": 0 }
        },
        {
          "type": "formula",
          "as": "indexed_price",
          "expr": "datum.index.price > 0 ? (datum.price - datum.index.price)/datum.index.price : 0"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "time",
      "domain": { "data": "stocks", "field": "date" },
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "domain": { "data": "indexed_stocks", "field": "indexed_price" },
      "nice": true,
      "zero": true,
      "range": "height"
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": { "data": "stocks", "field": "symbol" }
    }
  ],

  "axes": [{ "orient": "left", "scale": "y", "grid": true, "format": "%" }],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "name": "series",
          "data": "indexed_stocks",
          "groupby": "symbol"
        }
      },
      "data": [
        {
          "name": "label",
          "source": "series",
          "transform": [{ "type": "filter", "expr": "datum.date == maxDate" }]
        }
      ],
      "marks": [
        {
          "type": "line",
          "from": { "data": "series" },
          "encode": {
            "update": {
              "x": { "scale": "x", "field": "date" },
              "y": { "scale": "y", "field": "indexed_price" },
              "stroke": { "scale": "color", "field": "symbol" },
              "strokeWidth": { "value": 2 }
            }
          }
        },
        {
          "type": "text",
          "from": { "data": "label" },
          "encode": {
            "update": {
              "x": { "scale": "x", "field": "date", "offset": 2 },
              "y": { "scale": "y", "field": "indexed_price" },
              "fill": { "scale": "color", "field": "symbol" },
              "text": { "field": "symbol" },
              "baseline": { "value": "middle" }
            }
          }
        }
      ]
    },
    {
      "type": "rule",
      "encode": {
        "update": {
          "x": { "field": { "group": "x" } },
          "x2": { "field": { "group": "width" } },
          "y": {
            "value": 0.5,
            "offset": { "scale": "y", "value": 0, "round": true }
          },
          "stroke": { "value": "black" },
          "strokeWidth": { "value": 1 }
        }
      }
    },
    {
      "type": "rule",
      "encode": {
        "update": {
          "x": { "scale": "x", "signal": "indexDate", "offset": 0.5 },
          "y": { "value": 0 },
          "y2": { "field": { "group": "height" } },
          "stroke": { "value": "firebrick" }
        }
      }
    },
    {
      "type": "text",
      "encode": {
        "update": {
          "x": { "scale": "x", "signal": "indexDate" },
          "y2": { "field": { "group": "height" }, "offset": 15 },
          "align": { "value": "center" },
          "text": { "signal": "timeFormat(indexDate, '%b %Y')" },
          "fill": { "value": "firebrick" }
        }
      }
    }
  ]
}


#####vega/map_brush.json:#####


#####vega/map_click.json:#####


#####vega/map_hover.json:#####


#####vega/map_panzoom.json:#####


#####vega/scatter_brush.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic scatter plot example depicting automobile statistics.",
  "width": 200,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "source",
      "url": "data/test100.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['x'] != null && datum['y'] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": { "data": "source", "field": "x" },
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": { "data": "source", "field": "y" },
      "range": "height"
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "x"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "y"
    }
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": { "data": "source" },
      "encode": {
        "enter": {
          "shape": { "value": "circle" },
          "strokeWidth": { "value": 2 },
          "opacity": { "value": 0.5 },
          "stroke": { "value": "#4682b4" },
          "x": { "scale": "x", "field": "x" },
          "y": { "scale": "y", "field": "y" }
        },
        "update": {
          "fill": [
            {
              "test": "inrange(scale('x', datum.x), [brush.x, brush.x2]) && inrange(scale('y', datum.y), [brush.y, brush.y2])",
              "value": "red"
            },
            {
              "value": "transparent"
            }
          ]
        }
      }
    },
    {
      "type": "rect",
      "name": "brush",
      "encode": {
        "enter": {
          "fill": { "value": "#333" },
          "fillOpacity": { "value": 0.2 }
        },
        "update": {
          "x": { "signal": "brush.x" },
          "y": { "signal": "brush.y" },
          "x2": { "signal": "brush.x2" },
          "y2": { "signal": "brush.y2" }
        }
      }
    }
  ],

  "signals": [
    {
      "name": "brush",
      "value": {},
      "on": [
        {
          "events": { "type": "mousedown" },
          "update": "{x: x(event.clientX), y: y(event.clientY), x2: x(event.clientX), y2: y(event.clientY), down: true}"
        },
        {
          "events": { "type": "mousemove" },
          "update": "brush.down ? {x: brush.x, y: brush.y, x2: x(event.clientX), y2: y(event.clientY), down:true} : brush"
        },
        {
          "events": { "type": "mouseup" },
          "update": "brush.down ? {x: brush.x, y: brush.y, x2: x(event.clientX), y2: y(event.clientY), down: false} : brush"
        }
      ]
    }
  ]
}


#####vega/scatter_click.json:#####


#####vega/scatter_excentric_labeling.json:#####


#####vega/scatter_hover.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic scatter plot example depicting automobile statistics.",
  "width": 200,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "source",
      "url": "data/test100.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['x'] != null && datum['y'] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": { "data": "source", "field": "x" },
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": { "data": "source", "field": "y" },
      "range": "height"
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "x"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "y"
    }
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": { "data": "source" },
      "encode": {
        "update": {
          "x": { "scale": "x", "field": "x" },
          "y": { "scale": "y", "field": "y" },
          "shape": { "value": "circle" },
          "strokeWidth": { "value": 2 },
          "opacity": { "value": 0.5 },
          "stroke": { "value": "#4682b4" },
          "fill": { "value": "transparent" }
        },
        "hover": {
          "fill": { "value": "firebrick" },
          "fillOpacity": { "value": 1 },
          "zindex": { "value": 1 }
        }
      }
    }
  ]
}


#####vega/scatter_panzoom.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "An interactive scatter plot example supporting pan and zoom.",
  "width": 500,
  "height": 300,
  "padding": {
    "top": 10,
    "left": 40,
    "bottom": 20,
    "right": 10
  },
  "autosize": "none",

  "config": {
    "axis": {
      "domain": false,
      "tickSize": 3,
      "tickColor": "#888",
      "labelFont": "Monaco, Courier New"
    }
  },

  "signals": [
    {
      "name": "margin",
      "value": 20
    },
    {
      "name": "hover",
      "on": [
        { "events": "*:pointerover", "encode": "hover" },
        { "events": "*:pointerout", "encode": "leave" },
        { "events": "*:pointerdown", "encode": "select" },
        { "events": "*:pointerup", "encode": "release" }
      ]
    },
    {
      "name": "xoffset",
      "update": "-(height + padding.bottom)"
    },
    {
      "name": "yoffset",
      "update": "-(width + padding.left)"
    },
    { "name": "xrange", "update": "[0, width]" },
    { "name": "yrange", "update": "[height, 0]" },

    {
      "name": "down",
      "value": null,
      "on": [
        { "events": "touchend", "update": "null" },
        { "events": "pointerdown, touchstart", "update": "xy()" }
      ]
    },
    {
      "name": "xcur",
      "value": null,
      "on": [
        {
          "events": "pointerdown, touchstart, touchend",
          "update": "slice(xdom)"
        }
      ]
    },
    {
      "name": "ycur",
      "value": null,
      "on": [
        {
          "events": "pointerdown, touchstart, touchend",
          "update": "slice(ydom)"
        }
      ]
    },
    {
      "name": "delta",
      "value": [0, 0],
      "on": [
        {
          "events": [
            {
              "source": "window",
              "type": "pointermove",
              "consume": true,
              "between": [
                { "type": "pointerdown" },
                { "source": "window", "type": "pointerup" }
              ]
            },
            {
              "type": "touchmove",
              "consume": true,
              "filter": "event.touches.length === 1"
            }
          ],
          "update": "down ? [down[0]-x(), y()-down[1]] : [0,0]"
        }
      ]
    },

    {
      "name": "anchor",
      "value": [0, 0],
      "on": [
        {
          "events": "wheel",
          "update": "[invert('xscale', x()), invert('yscale', y())]"
        },
        {
          "events": {
            "type": "touchstart",
            "filter": "event.touches.length===2"
          },
          "update": "[(xdom[0] + xdom[1]) / 2, (ydom[0] + ydom[1]) / 2]"
        }
      ]
    },
    {
      "name": "zoom",
      "value": 1,
      "on": [
        {
          "events": "wheel!",
          "force": true,
          "update": "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
        },
        {
          "events": { "signal": "dist2" },
          "force": true,
          "update": "dist1 / dist2"
        }
      ]
    },
    {
      "name": "dist1",
      "value": 0,
      "on": [
        {
          "events": {
            "type": "touchstart",
            "filter": "event.touches.length===2"
          },
          "update": "pinchDistance(event)"
        },
        {
          "events": { "signal": "dist2" },
          "update": "dist2"
        }
      ]
    },
    {
      "name": "dist2",
      "value": 0,
      "on": [
        {
          "events": {
            "type": "touchmove",
            "consume": true,
            "filter": "event.touches.length===2"
          },
          "update": "pinchDistance(event)"
        }
      ]
    },

    {
      "name": "xdom",
      "update": "slice(xext)",
      "on": [
        {
          "events": { "signal": "delta" },
          "update": "[xcur[0] + span(xcur) * delta[0] / width, xcur[1] + span(xcur) * delta[0] / width]"
        },
        {
          "events": { "signal": "zoom" },
          "update": "[anchor[0] + (xdom[0] - anchor[0]) * zoom, anchor[0] + (xdom[1] - anchor[0]) * zoom]"
        }
      ]
    },
    {
      "name": "ydom",
      "update": "slice(yext)",
      "on": [
        {
          "events": { "signal": "delta" },
          "update": "[ycur[0] + span(ycur) * delta[1] / height, ycur[1] + span(ycur) * delta[1] / height]"
        },
        {
          "events": { "signal": "zoom" },
          "update": "[anchor[1] + (ydom[0] - anchor[1]) * zoom, anchor[1] + (ydom[1] - anchor[1]) * zoom]"
        }
      ]
    },
    {
      "name": "size",
      "update": "clamp(2000 / span(xdom), 1, 100)"
    }
  ],

  "data": [
    {
      "name": "points",
      "url": "data/test100.json",
      "transform": [
        { "type": "extent", "field": "x", "signal": "xext" },
        { "type": "extent", "field": "y", "signal": "yext" }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "zero": false,
      "domain": { "signal": "xdom" },
      "range": { "signal": "xrange" }
    },
    {
      "name": "yscale",
      "zero": false,
      "domain": { "signal": "ydom" },
      "range": { "signal": "yrange" }
    }
  ],

  "axes": [
    {
      "scale": "xscale",
      "orient": "top",
      "offset": { "signal": "xoffset" }
    },
    {
      "scale": "yscale",
      "orient": "right",
      "offset": { "signal": "yoffset" }
    }
  ],

  "marks": [
    {
      "type": "symbol",
      "from": { "data": "points" },
      "clip": true,
      "encode": {
        "enter": {
          "fillOpacity": { "value": 0.6 },
          "fill": { "value": "steelblue" }
        },
        "update": {
          "x": { "scale": "xscale", "field": "x" },
          "y": { "scale": "yscale", "field": "y" },
          "size": { "signal": "size" }
        },
        "hover": { "fill": { "value": "firebrick" } },
        "leave": { "fill": { "value": "steelblue" } },
        "select": { "size": { "signal": "size", "mult": 5 } },
        "release": { "size": { "signal": "size" } }
      }
    }
  ]
}


#####vega/scatter_semantic_panzoom.json:#####


#####vega/splom_brush.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A scatter plot matrix of penguin data with interactive linked selections.",
  "padding": 10,
  "config": { "axis": { "tickColor": "#ccc" } },
  "signals": [
    { "name": "chartSize", "value": 197 },
    { "name": "chartPad", "value": 28 },
    { "name": "chartStep", "update": "chartSize + chartPad" },
    { "name": "width", "update": "chartStep * 4" },
    { "name": "height", "update": "chartStep * 4" },
    {
      "name": "cell",
      "value": null,
      "on": [
        { "events": "@cell:mousedown", "update": "group()" },
        {
          "events": "@cell:mouseup",
          "update": "!span(brushX) && !span(brushY) ? null : cell"
        }
      ]
    },
    {
      "name": "brushX",
      "value": 0,
      "on": [
        { "events": "@cell:mousedown", "update": "[x(cell), x(cell)]" },
        {
          "events": "[@cell:mousedown, window:mouseup] > window:mousemove",
          "update": "[brushX[0], clamp(x(cell), 0, chartSize)]"
        },
        {
          "events": { "signal": "delta" },
          "update": "clampRange([anchorX[0] + delta[0], anchorX[1] + delta[0]], 0, chartSize)"
        }
      ]
    },
    {
      "name": "brushY",
      "value": 0,
      "on": [
        { "events": "@cell:mousedown", "update": "[y(cell), y(cell)]" },
        {
          "events": "[@cell:mousedown, window:mouseup] > window:mousemove",
          "update": "[brushY[0], clamp(y(cell), 0, chartSize)]"
        },
        {
          "events": { "signal": "delta" },
          "update": "clampRange([anchorY[0] + delta[1], anchorY[1] + delta[1]], 0, chartSize)"
        }
      ]
    },
    {
      "name": "down",
      "value": [0, 0],
      "on": [{ "events": "@brush:mousedown", "update": "[x(cell), y(cell)]" }]
    },
    {
      "name": "anchorX",
      "value": null,
      "on": [{ "events": "@brush:mousedown", "update": "slice(brushX)" }]
    },
    {
      "name": "anchorY",
      "value": null,
      "on": [{ "events": "@brush:mousedown", "update": "slice(brushY)" }]
    },
    {
      "name": "delta",
      "value": [0, 0],
      "on": [
        {
          "events": "[@brush:mousedown, window:mouseup] > window:mousemove",
          "update": "[x(cell) - down[0], y(cell) - down[1]]"
        }
      ]
    },
    {
      "name": "rangeX",
      "value": [0, 0],
      "on": [
        {
          "events": { "signal": "brushX" },
          "update": "invert(cell.datum.x.data + 'X', brushX)"
        }
      ]
    },
    {
      "name": "rangeY",
      "value": [0, 0],
      "on": [
        {
          "events": { "signal": "brushY" },
          "update": "invert(cell.datum.y.data + 'Y', brushY)"
        }
      ]
    },
    {
      "name": "cursor",
      "value": "'default'",
      "on": [
        {
          "events": "[@cell:mousedown, window:mouseup] > window:mousemove!",
          "update": "'nwse-resize'"
        },
        {
          "events": "@brush:mousemove, [@brush:mousedown, window:mouseup] > window:mousemove!",
          "update": "'move'"
        },
        { "events": "@brush:mouseout, window:mouseup", "update": "'default'" }
      ]
    }
  ],
  "data": [
    {
      "name": "penguins",
      "url": "data/md100.csv",
      "format": { "type": "csv", "parse": "auto" },
      "transform": [
        { "type": "filter", "expr": "datum['culmen_length_mm'] != 'NaN'" }
      ]
    },
    {
      "name": "fields",
      "values": [
        "culmen_length_mm",
        "culmen_depth_mm",
        "flipper_length_mm",
        "body_mass_g"
      ]
    },
    {
      "name": "cross",
      "source": "fields",
      "transform": [
        { "type": "cross", "as": ["x", "y"] },
        { "type": "formula", "as": "xscale", "expr": "datum.x.data + 'X'" },
        { "type": "formula", "as": "yscale", "expr": "datum.y.data + 'Y'" }
      ]
    }
  ],
  "scales": [
    {
      "name": "groupx",
      "type": "band",
      "range": "width",
      "domain": { "data": "fields", "field": "data" }
    },
    {
      "name": "groupy",
      "type": "band",
      "range": [{ "signal": "height" }, 0],
      "domain": { "data": "fields", "field": "data" }
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": { "data": "penguins", "field": "species" },
      "range": "category"
    },
    {
      "name": "culmen_length_mmX",
      "zero": false,
      "nice": true,
      "domain": { "data": "penguins", "field": "culmen_length_mm" },
      "range": [0, { "signal": "chartSize" }]
    },
    {
      "name": "culmen_depth_mmX",
      "zero": false,
      "nice": true,
      "domain": { "data": "penguins", "field": "culmen_depth_mm" },
      "range": [0, { "signal": "chartSize" }]
    },
    {
      "name": "flipper_length_mmX",
      "zero": false,
      "nice": true,
      "domain": { "data": "penguins", "field": "flipper_length_mm" },
      "range": [0, { "signal": "chartSize" }]
    },
    {
      "name": "body_mass_gX",
      "zero": false,
      "nice": true,
      "domain": { "data": "penguins", "field": "body_mass_g" },
      "range": [0, { "signal": "chartSize" }]
    },
    {
      "name": "culmen_length_mmY",
      "zero": false,
      "nice": true,
      "domain": { "data": "penguins", "field": "culmen_length_mm" },
      "range": [{ "signal": "chartSize" }, 0]
    },
    {
      "name": "culmen_depth_mmY",
      "zero": false,
      "nice": true,
      "domain": { "data": "penguins", "field": "culmen_depth_mm" },
      "range": [{ "signal": "chartSize" }, 0]
    },
    {
      "name": "flipper_length_mmY",
      "zero": false,
      "nice": true,
      "domain": { "data": "penguins", "field": "flipper_length_mm" },
      "range": [{ "signal": "chartSize" }, 0]
    },
    {
      "name": "body_mass_gY",
      "zero": false,
      "nice": true,
      "domain": { "data": "penguins", "field": "body_mass_g" },
      "range": [{ "signal": "chartSize" }, 0]
    }
  ],
  "axes": [
    {
      "orient": "left",
      "scale": "culmen_length_mmY",
      "minExtent": 25,
      "title": "culmen_length_mm",
      "tickCount": 5,
      "domain": false,
      "position": { "signal": "3 * chartStep" }
    },
    {
      "orient": "left",
      "scale": "culmen_depth_mmY",
      "minExtent": 25,
      "title": "culmen_depth_mm",
      "tickCount": 5,
      "domain": false,
      "position": { "signal": "2 * chartStep" }
    },
    {
      "orient": "left",
      "scale": "flipper_length_mmY",
      "minExtent": 25,
      "title": "flipper_length_mm",
      "tickCount": 5,
      "domain": false,
      "position": { "signal": "1 * chartStep" }
    },
    {
      "orient": "left",
      "scale": "body_mass_gY",
      "minExtent": 25,
      "title": "body_mass_g",
      "tickCount": 5,
      "domain": false
    },
    {
      "orient": "bottom",
      "scale": "culmen_length_mmX",
      "title": "culmen_length_mm",
      "tickCount": 5,
      "domain": false,
      "offset": { "signal": "-chartPad" }
    },
    {
      "orient": "bottom",
      "scale": "culmen_depth_mmX",
      "title": "culmen_depth_mm",
      "tickCount": 5,
      "domain": false,
      "offset": { "signal": "-chartPad" },
      "position": { "signal": "1 * chartStep" }
    },
    {
      "orient": "bottom",
      "scale": "flipper_length_mmX",
      "title": "flipper_length_mm",
      "tickCount": 5,
      "domain": false,
      "offset": { "signal": "-chartPad" },
      "position": { "signal": "2 * chartStep" }
    },
    {
      "orient": "bottom",
      "scale": "body_mass_gX",
      "title": "body_mass_g",
      "tickCount": 5,
      "domain": false,
      "offset": { "signal": "-chartPad" },
      "position": { "signal": "3 * chartStep" }
    }
  ],
  "legends": [
    {
      "fill": "color",
      "title": "species",
      "offset": 0,
      "encode": {
        "symbols": {
          "update": {
            "fillOpacity": { "value": 0.5 },
            "stroke": { "value": "transparent" }
          }
        }
      }
    }
  ],
  "marks": [
    {
      "type": "rect",
      "encode": {
        "enter": { "fill": { "value": "#eee" } },
        "update": {
          "opacity": { "signal": "cell ? 1 : 0" },
          "x": { "signal": "cell ? cell.x + brushX[0] : 0" },
          "x2": { "signal": "cell ? cell.x + brushX[1] : 0" },
          "y": { "signal": "cell ? cell.y + brushY[0] : 0" },
          "y2": { "signal": "cell ? cell.y + brushY[1] : 0" }
        }
      }
    },
    {
      "name": "cell",
      "type": "group",
      "from": { "data": "cross" },
      "encode": {
        "enter": {
          "x": { "scale": "groupx", "field": "x.data" },
          "y": { "scale": "groupy", "field": "y.data" },
          "width": { "signal": "chartSize" },
          "height": { "signal": "chartSize" },
          "fill": { "value": "transparent" },
          "stroke": { "value": "#ddd" }
        }
      },
      "marks": [
        {
          "type": "symbol",
          "from": { "data": "penguins" },
          "interactive": false,
          "encode": {
            "enter": {
              "x": {
                "scale": { "parent": "xscale" },
                "field": { "datum": { "parent": "x.data" } }
              },
              "y": {
                "scale": { "parent": "yscale" },
                "field": { "datum": { "parent": "y.data" } }
              },
              "fillOpacity": { "value": 0.5 },
              "size": { "value": 36 }
            },
            "update": {
              "fill": [
                {
                  "test": "!cell || inrange(datum[cell.datum.x.data], rangeX) && inrange(datum[cell.datum.y.data], rangeY)",
                  "scale": "color",
                  "field": "species"
                },
                { "value": "#ddd" }
              ]
            }
          }
        }
      ]
    },
    {
      "type": "rect",
      "name": "brush",
      "encode": {
        "enter": { "fill": { "value": "transparent" } },
        "update": {
          "x": { "signal": "cell ? cell.x + brushX[0] : 0" },
          "x2": { "signal": "cell ? cell.x + brushX[1] : 0" },
          "y": { "signal": "cell ? cell.y + brushY[0] : 0" },
          "y2": { "signal": "cell ? cell.y + brushY[1] : 0" }
        }
      }
    }
  ]
}


#####vega/timeseries_overviewdetail.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "Area charts of stock Closes, with an interactive overview and filtered detail views.",
  "width": 720,
  "height": 480,
  "padding": 5,

  "data": [
    {
      "name": "sp500",
      "url": "data/stocks/ts100.csv",
      "format": {
        "type": "csv",
        "parse": { "Close": "number", "Date": "date" }
      }
    }
  ],

  "signals": [
    {
      "name": "detailDomain"
    }
  ],

  "marks": [
    {
      "type": "group",
      "name": "detail",
      "encode": {
        "enter": {
          "height": { "value": 390 },
          "width": { "value": 720 }
        }
      },
      "scales": [
        {
          "name": "xDetail",
          "type": "time",
          "range": "width",
          "domain": { "data": "sp500", "field": "Date" },
          "domainRaw": { "signal": "detailDomain" }
        },
        {
          "name": "yDetail",
          "type": "linear",
          "range": [390, 0],
          "domain": { "data": "sp500", "field": "Close" },
          "nice": true,
          "zero": true
        }
      ],
      "axes": [
        { "orient": "bottom", "scale": "xDetail" },
        { "orient": "left", "scale": "yDetail" }
      ],
      "marks": [
        {
          "type": "group",
          "encode": {
            "enter": {
              "height": { "field": { "group": "height" } },
              "width": { "field": { "group": "width" } },
              "clip": { "value": true }
            }
          },
          "marks": [
            {
              "type": "area",
              "from": { "data": "sp500" },
              "encode": {
                "update": {
                  "x": { "scale": "xDetail", "field": "Date" },
                  "y": { "scale": "yDetail", "field": "Close" },
                  "y2": { "scale": "yDetail", "value": 0 },
                  "fill": { "value": "steelblue" }
                }
              }
            }
          ]
        }
      ]
    },

    {
      "type": "group",
      "name": "overview",
      "encode": {
        "enter": {
          "x": { "value": 0 },
          "y": { "value": 430 },
          "height": { "value": 70 },
          "width": { "value": 720 },
          "fill": { "value": "transparent" }
        }
      },
      "signals": [
        {
          "name": "brush",
          "value": 0,
          "on": [
            {
              "events": "@overview:mousedown",
              "update": "[x(), x()]"
            },
            {
              "events": "[@overview:mousedown, window:mouseup] > window:mousemove!",
              "update": "[brush[0], clamp(x(), 0, width)]"
            },
            {
              "events": { "signal": "delta" },
              "update": "clampRange([anchor[0] + delta, anchor[1] + delta], 0, width)"
            }
          ]
        },
        {
          "name": "anchor",
          "value": null,
          "on": [{ "events": "@brush:mousedown", "update": "slice(brush)" }]
        },
        {
          "name": "xdown",
          "value": 0,
          "on": [{ "events": "@brush:mousedown", "update": "x()" }]
        },
        {
          "name": "delta",
          "value": 0,
          "on": [
            {
              "events": "[@brush:mousedown, window:mouseup] > window:mousemove!",
              "update": "x() - xdown"
            }
          ]
        },
        {
          "name": "detailDomain",
          "push": "outer",
          "on": [
            {
              "events": { "signal": "brush" },
              "update": "span(brush) ? invert('xOverview', brush) : null"
            }
          ]
        }
      ],
      "scales": [
        {
          "name": "xOverview",
          "type": "time",
          "range": "width",
          "domain": { "data": "sp500", "field": "Date" }
        },
        {
          "name": "yOverview",
          "type": "linear",
          "range": [70, 0],
          "domain": { "data": "sp500", "field": "Close" },
          "nice": true,
          "zero": true
        }
      ],
      "axes": [{ "orient": "bottom", "scale": "xOverview" }],
      "marks": [
        {
          "type": "area",
          "interactive": false,
          "from": { "data": "sp500" },
          "encode": {
            "update": {
              "x": { "scale": "xOverview", "field": "Date" },
              "y": { "scale": "yOverview", "field": "Close" },
              "y2": { "scale": "yOverview", "value": 0 },
              "fill": { "value": "steelblue" }
            }
          }
        },
        {
          "type": "rect",
          "name": "brush",
          "encode": {
            "enter": {
              "y": { "value": 0 },
              "height": { "value": 70 },
              "fill": { "value": "#333" },
              "fillOpacity": { "value": 0.2 }
            },
            "update": {
              "x": { "signal": "brush[0]" },
              "x2": { "signal": "brush[1]" }
            }
          }
        },
        {
          "type": "rect",
          "interactive": false,
          "encode": {
            "enter": {
              "y": { "value": 0 },
              "height": { "value": 70 },
              "width": { "value": 1 },
              "fill": { "value": "firebrick" }
            },
            "update": {
              "x": { "signal": "brush[0]" }
            }
          }
        },
        {
          "type": "rect",
          "interactive": false,
          "encode": {
            "enter": {
              "y": { "value": 0 },
              "height": { "value": 70 },
              "width": { "value": 1 },
              "fill": { "value": "firebrick" }
            },
            "update": {
              "x": { "signal": "brush[1]" }
            }
          }
        }
      ]
    }
  ]
}


#####vega/treemap_brush.json:#####


#####vega/treemap_click.json:#####


#####vega/treemap_excentric_labeling.json:#####


#####vega/treemap_hover.json:#####


#####vega/treemap_panzoom.json:#####


#####vega/treemap_semantic_panzoom.json:#####


#####vega/zoomable_circle_packing.json:#####
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "An example of a zoomable circle packing layout for hierarchical data.",
  "width": 600,
  "height": 600,
  "padding": 5,
  "signals": [
    {
      "name": "duration",
      "init": "750",
      "description": "The duration for the zoom transitions. Fade-in transitions will be the same duration, but will be delayed per the amount set here.",
      "on": [
        {
          "events": { "type": "click", "marknames": ["circles", "background"] },
          "update": "(event.metaKey || event.ctrlKey ? 4 : 1) *750"
        }
      ]
    },
    {
      "name": "k",
      "value": 1,
      "description": "The scale used for zooming based on the focused node",
      "on": [
        {
          "events": [{ "signal": "focus" }],
          "update": "focus ? width/(focus.r*2) : 1"
        }
      ]
    },
    {
      "name": "root",
      "update": "{'id': data('tree')[0]['id'], 'x': data('tree')[0]['x'], 'y': data('tree')[0]['y'], 'r': data('tree')[0]['r'], 'k': 1, 'children': data('tree')[0]['children']}",
      "description": "The root node in the hierarchy"
    },
    {
      "name": "focus",
      "init": "root",
      "description": "The zoomed-in node in the hierarchy",
      "on": [
        {
          "events": { "type": "click", "markname": "background" },
          "update": "{id: root['id'], 'x': root['x'], 'y': root['y'], 'r': root['r'], 'k': 1,'children': root['children']}"
        },
        {
          "events": { "type": "click", "markname": "circles" },
          "update": "(focus['x'] === datum['x'] && focus['y'] === datum['y'] && focus['r'] === datum['r'] && focus['r'] !== root['r']) ? {'id': root['id'], 'x': root['x'], 'y': root['y'], 'r': root['r'], 'k': 1, 'children': root['children']} : {'id': datum['id'], 'x': datum['x'], 'y': datum['y'], 'r': datum['r'], 'k': k, 'children': datum['children']}"
        }
      ]
    },
    {
      "name": "focus0",
      "update": "data('focus0') && length(data('focus0'))>0 ? data('focus0')[0] : focus",
      "description": "The prior zoomed-in node in the hierarchy"
    },
    {
      "name": "timer",
      "description": "The timer to be used for transitions such as zoom, fade, etc.",
      "on": [{ "events": "timer", "update": "now()" }]
    },
    {
      "name": "interpolateTime",
      "description": "the start and end times in miliseconds for animation interpolations",
      "on": [
        {
          "events": {
            "type": "click",
            "marknames": ["circles", "background"]
          },
          "update": "{'start': timer, 'end': timer+duration}"
        }
      ]
    },
    {
      "name": "t",
      "description": "The normalized time for easing",
      "update": "interpolateTime ? clamp((timer-interpolateTime.start)/(interpolateTime.end-interpolateTime.start), 0, 1): null"
    },
    {
      "name": "tEase",
      "description": "The easing calculation. Currently set as easeInOutCubic",
      "update": "t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1"
    },
    {
      "name": "interpolateTimeDelayed",
      "description": "The delayed time for easing",
      "on": [
        {
          "events": { "signal": "interpolateTime" },
          "update": "{'start': interpolateTime['end'], 'end': interpolateTime['end']+duration}"
        }
      ]
    },
    {
      "name": "tDelayed",
      "description": "The delayed normalized time for easing",
      "update": "interpolateTimeDelayed ? clamp((timer-interpolateTimeDelayed.start)/(interpolateTimeDelayed.end-interpolateTimeDelayed.start), 0, 1): null"
    },
    {
      "name": "tEaseDelayed",
      "description": "The delayed easing calculation. Currently set as easeInOutCubic",
      "update": "tDelayed < 0.5 ? 4 * tDelayed * tDelayed * tDelayed : (tDelayed - 1) * (2 * tDelayed - 2) * (2 * tDelayed - 2) + 1"
    },
    {
      "name": "showDetails",
      "description": "A boolean to indicate whether to show a node's details",
      "value": false,
      "on": [
        {
          "events": {
            "type": "click",
            "marknames": ["circles", "background"],
            "filter": [
              "!event.altKey && !event.shiftKey",
              "event.button === 0"
            ],
            "markname": "circles"
          },
          "update": "focus['children'] > 0 ? false : datum['id'] === root['id'] || focus0['id'] !== root['id'] && focus['id'] === root['id'] ? false : true"
        },
        {
          "events": {
            "type": "click",
            "marknames": ["circles", "background"],
            "filter": ["event.altKey || event.shiftKey", "event.button === 0"]
          },
          "update": "focus0['id'] === focus['id'] ? !showDetails : true"
        }
      ]
    }
  ],
  "data": [
    {
      "name": "source",
      "url": "data/flare.json",
      "transform": [
        {
          "type": "formula",
          "expr": "isValid(datum['parent']) ? datum['parent'] : null",
          "as": "parent"
        },
        {
          "type": "formula",
          "expr": "isValid(datum['size']) ? datum['size'] : null",
          "as": "size"
        }
      ]
    },
    {
      "name": "tree",
      "source": "source",
      "transform": [
        { "type": "stratify", "key": "id", "parentKey": "parent" },
        {
          "type": "pack",
          "field": "size",
          "sort": { "field": "value" },
          "size": [{ "signal": "width" }, { "signal": "height" }]
        }
      ]
    },
    {
      "name": "focus0",
      "on": [{ "trigger": "focus", "insert": "focus" }],
      "transform": [
        { "type": "formula", "expr": "now()", "as": "now" },
        {
          "type": "window",
          "ops": ["row_number"],
          "as": ["row"],
          "sort": { "field": "now", "order": "descending" }
        },
        {
          "type": "filter",
          "expr": "datum['row'] ? datum['row'] == 2 : true "
        },
        { "type": "project", "fields": ["id", "x", "y", "r", "children"] },
        { "type": "formula", "expr": "width/(datum['r']*2)", "as": "k" }
      ]
    },
    {
      "name": "details_data",
      "source": "tree",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['id'] === focus['id'] && showDetails"
        },
        {
          "type": "formula",
          "expr": "['hierarchy depth: ' + datum['depth'], 'children count: ' + datum['children'],isValid( datum['size']) ? 'size: ' + datum['size'] + ' bytes' : '']",
          "as": "details"
        }
      ]
    }
  ],
  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": { "data": "tree", "field": "depth" },
      "range": { "scheme": "magma" }
    }
  ],
  "marks": [
    {
      "name": "background",
      "description": "An ivisible rect that covers the entire canvas and sits behind everything",
      "type": "rect",
      "encode": {
        "enter": {
          "x": { "signal": "-padding['left']" },
          "y": { "signal": "-padding['top']" },
          "width": { "signal": "width+padding['left']+padding['right']" },
          "height": { "signal": "height+padding['top']+padding['bottom']" },
          "fillOpacity": { "value": 0 }
        }
      }
    },
    {
      "name": "circles",
      "description": "the zoomable packed circles",
      "type": "symbol",
      "from": { "data": "tree" },
      "encode": {
        "enter": {
          "shape": { "value": "circle" },
          "fill": { "scale": "color", "field": "depth" },
          "cursor": { "value": "pointer" },
          "tooltip": { "field": "name" }
        },
        "update": {
          "x": {
            "signal": "lerp([root['x']+ (datum['x'] - focus0['x']) * focus0['k'], root['x'] + (datum['x'] - focus['x']) * k], tEase)"
          },
          "y": {
            "signal": "lerp([ root['y'] + (datum['y'] - focus0['y']) * focus0['k'],  root['y'] + (datum['y'] - focus['y']) * k], tEase)"
          },
          "size": {
            "signal": "pow(2*(datum['r'] * lerp([focus0['k'], k],tEase)),2)"
          },
          "fill": {
            "signal": "showDetails && focus['id'] === datum['id'] ? '#fff' : scale('color',datum['depth'])"
          },
          "zindex": {
            "signal": "!showDetails ? 1 : (focus['id'] === root['id'] && isValid(datum['parent'])) ? -99 : indexof(pluck(treeAncestors('tree', datum['id']), 'id'), focus['id']) > 0 ? -99 : 1"
          },
          "stroke": {
            "signal": "showDetails ? scale('color', datum['depth']) : luminance(scale('color', datum['depth'])) > 0.5 ?  'black' : 'white'"
          },
          "strokeWidth": {
            "signal": "focus['id'] === datum['id'] && showDetails ? 20 : 0.5"
          },
          "strokeOpacity": {
            "signal": "!showDetails ? 0.5 : focus['id'] === root['id'] ? min(tEase, 0.35) : min(tEaseDelayed, 0.35)"
          }
        },
        "hover": {
          "color": {
            "signal": "showDetails ? scale('color', datum['depth']) : luminance(scale('color', datum['depth'])) > 0.5 ?  'black' : 'white'"
          },
          "strokeWidth": { "value": 2 }
        }
      }
    },
    {
      "name": "details_title",
      "details": "the name of the node (appears on zoom)",
      "type": "text",
      "from": { "data": "details_data" },
      "interactive": false,
      "encode": {
        "enter": {
          "text": { "signal": "datum['name']" },
          "fill": { "scale": "color", "field": "depth" },
          "fontSize": { "signal": "0.055*width" },
          "align": { "value": "center" },
          "x": { "signal": "width/2" },
          "y": { "signal": "height/4" },
          "opacity": { "value": 0 }
        },
        "update": {
          "opacity": {
            "signal": "!showDetails ? 0 : focus['id'] === root['id'] ? tEase : tEaseDelayed"
          }
        }
      }
    },
    {
      "name": "details",
      "description": "additional information about the node (appears on zoom)",
      "type": "text",
      "from": { "data": "details_data" },
      "interactive": false,
      "encode": {
        "enter": {
          "text": { "signal": "datum['details']" },
          "fontSize": { "signal": "0.045*width" },
          "align": { "value": "center" },
          "x": { "signal": "width/2" },
          "y": { "signal": "height/3" },
          "fill": { "value": "gray" },
          "opacity": { "value": 0 }
        },
        "update": {
          "opacity": {
            "signal": "!showDetails ? 0 : focus['id'] === root['id'] ? tEase : tEaseDelayed"
          }
        }
      }
    },
    {
      "name": "helper_text",
      "interactive": false,
      "description": "interactivity instructions located at the bottom of left",
      "type": "text",
      "encode": {
        "enter": {
          "fontSize": { "value": 14 },
          "text": {
            "signal": "['interactivity instructions:', ' click on a node to zoom-in',' for nodes with children, shift + click to see details for that node', ' to slow down animations,  + click (Mac) /  + click (Windows)']"
          },
          "y": { "signal": "height+5" }
        },
        "update": {
          "opacity": {
            "signal": "ceil(k) === 1 ? isValid(t) ? tEaseDelayed : 1 : 0"
          }
        }
      }
    }
  ]
}


